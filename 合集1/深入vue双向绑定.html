<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title> </title>
</head>
<body>
    <div id="app">
        <h2>{{obj}}</h2>

        <h1>{{name}}</h1>
        <p>{{obj.a.c}}</p>

    </div>
  <script>
  //监听数组变动,数组对象无法通过Object.defineProperty实现监听，Vue包含观察数组的变异方法，来触发视图更新。
// /辅助方法+++++++++++++++++++++++++++++++++++++++++++++++
//辅助方法
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key)
}
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}
function def (obj, key, val) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: true,
    writable: true,
    configurable: true
  })
}

//重新赋值Array的__proto__属性
function protoAugment (target,src) {
  target.__proto__ = src
}
//不支持__proto__的直接修改相关属性方法
function copyAugment (target, src, keys) {
  for (let i = 0, l = keys.length; i < l; i++) {
    const key = keys[i]
    def(target, key, src[key])
  }
}
//收集数组的依赖
function dependArray (value) {
  for (let e, i = 0, l = value.length; i < l; i++) {
    e = value[i]
    e && e.__ob__ && e.__ob__.dep.depend()
    if (Array.isArray(e)) {
      //循环遍历chindren进行依赖收集
        dependArray(e)
    }
  }
}
// 处理数组======================================================

const arrayProto = Array.prototype;
const arrayMethods = Object.create(arrayProto);
[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
].forEach(item=>{
  Object.defineProperty(arrayMethods,item,{
      value:function mutator(){
        //缓存原生方法，之后调用
        const original = arrayProto[item] 
        let i = arguments.length
        const args = new Array(i);
        while (i--) {
          args[i] = arguments[i];
        }
        /*调用原生的数组方法*/
        const result = original.apply(this, args);

        /*数组新插入的元素需要重新进行observe才能响应式*/
        const ob = this.__ob__;
        let inserted
        switch (item) {
          case 'push':
            inserted = args;
            break
          case 'unshift':
            inserted = args;
            break
          case 'splice':
            inserted = args.slice(2);
            break
        }
        if (inserted) ob.observeArray(inserted);

        // notify change
        /*dep通知所有注册的观察者进行响应式处理*/
        ob.dep.notify();
        return result;
      },
  })
})
//获得arrayMethods对象上所有属性的数组
const arrayKeys = Object.getOwnPropertyNames(arrayMethods)

// +++++++++++++++++++++++++++++++++++++++++++++++++++++
  // ===============================================================
  // 监听器Observer，用来劫持并监听所有属性。
    function Observer(value) {
      this.value = value;
      this.dep = new Dep();//供对象和数组使用
      def(value, '__ob__', this);//__ob__是一个对象被observe的标志
      if (Array.isArray(value)) {
        //处理数组
          const augment = value.__proto__ ? protoAugment : copyAugment  
          //此处的 arrayMethods 就是上面使用Object.defineProperty处理过
          augment(value, arrayMethods, arrayKeys)
          // 循环遍历数组children进行oberve
          this.observeArray(value)
      }else{
        this.walk(value);
      }
    }
  // 递归调用，为对象的每个属性绑定getter/setter
    Observer.prototype.walk = function(obj) {
      var keys = Object.keys(obj);
      for(var i = 0;i<keys.length;i++) {
        if(keys[i]=='__ob__') return;//防止重复observe
        this.convert(keys[i],obj[keys[i]])
      }
    }

    // 将属性转换为getter/setter
    Observer.prototype.convert = function(key, val) {
      defineReactive(this.value,key,val)
    }

    // 观察数组的每一项
    Observer.prototype.observeArray = function(items) {
      for (var i = 0; i<items.length; i++) {
          observe(items[i])
      }
    };

    function observe(value) {
      // 当值不存在或者不是对象类型时，不需要继续深入监听
      if (!value || typeof value !== 'object') {
        return;
      }
      return new Observer(value)
    }

    function defineReactive(obj,key,val) {
      var dep = new Dep();//，是为对象属性服务的.植入消息订阅器，当属性值变化时，通知该订阅器下的所有订阅者（绑定该属性值的所有watcher）更新视图
      var property = Object.getOwnPropertyDescriptor(obj, key)
      if (property && property.configurable === false) {
          return
    }
    //如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。
    var getter = property && property.get
    var setter = property && property.set
    /*对象的子对象递归进行observe并返回子节点的Observer对象*/
      var childOb = observe(val);
      Object.defineProperty(obj, key, {
         enumerable: true,
         configurable: true,
         get:function reactiveGetter() {
           // console.log(`调用了get，值为${val}`)
          var value = getter ? getter.call(obj) : val;
// 这里是Dep收集订阅者的过程，只有在Dep.target存在的情况下才进行这个操作，在Watcher收集依赖的时候才会设置Dep.target，所以Watcher收集依赖的时机就是Dep收集订阅者的时机。
//       调用get的情况有两种，一是Watcher收集依赖的时候（此时Dep收集订阅者,调用watcher的get()），二是模板或js代码里用到这个值，这个时候是不需要收集依赖的，只要返回值就可以了。

          if(Dep.target){
            dep.depend();
             if(childOb) { //不仅这个属性需要添加到依赖列表中，如果这个属性对应的值是对象或数组，那么这个属性对应的值也需要添加到依赖列表中，为了在对象属性值变化时通知到该watcher,例如添加一个属性（set）
               childOb.dep.depend(); 
              // 此处的dep就是在执行var childOb = observe(val)时产生的，是用来收集childOb的订阅者的
            }
            if(Array.isArray(value)) { 
              /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/
              dependArray(value)
            }
          }
          return value
         },
         set: function reactiveSetter (newVal) {
            var value = getter ? getter.call(obj) : val
            if (newVal === value) {
                return
            }
            if (setter) {
                setter.call(obj, newVal)
            } else {
                val = newVal;
            }
            //当为属性设置了新的值，是需要重新observe的
           childOb = observe(newVal)
           dep.notify();//如果数据变化，通知所有订阅者
        }
      })
    }
    // =====================================================================
    // 订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图
    function Watcher (vm,  expOrFn, cb) {
      this.vm = vm;
      //在Vue中cb是更新视图的核心，调用diff并更新视图的过程
      this.cb = cb;
      //收集Deps，用于移除监听
      this.depIds = [];
      this.deps = [];
      this.newDeps = [];
      this.newDepsIds =[];
      // expOrFn参数是一个字符串，比如testObj.testObjFirstVal，此时testObj仅仅是一个字符串，而不是对象，我们无法直接获取testObjFirstVal属性的值
      if(typeof expOrFn === 'function') {
        this.getter = expOrFn;
      } else {
        this.getter = this.parseExpression(expOrFn)
      }
      this.value  = this.get();// 将自己添加到订阅器的操作
    }
    Watcher.prototype.get = function () {
      // 
      Dep.target = this;// 缓存自己
      const value = this.getter.call(this.vm, this.vm);// 强制执行监听器里的getter函数
      // 依赖收集完成，置空，用于下一个Watcher使用
      Dep.target = null; // 释放自己
      this.cleanupDeps();
      return value;
    }
    Watcher.prototype.addDep = function(dep) {
      var id = dep.id;
      if(this.newDepsIds.indexOf(id)===-1) {
        this.newDepsIds.push(id);
        this.newDeps.push(dep);
        // 去重，如果depIds里包含这个id，说明在之前给depIds添加这个id的时候，已经调用过 dep.addSub(this)，即添加过订阅，不需要重复添加。
        if(this.depIds.indexOf(id) === -1) {
          dep.addSub(this);
        }
      }
    }
    Watcher.prototype.update = function () {
      this.run()
    }
    Watcher.prototype.run = function() {
      var value = this.get();
      if(value !== this.value || typeof value === 'object') {
        var oldValue = this.value;
        console.log(oldValue,value)
        // 将newVal, oldVal挂载到MVVM实例上
        this.cb.call(this.vm, value, oldValue)
      }
    }
    Watcher.prototype.parseExpression = function (exp) {
      if (/[^\w.$]/.test(exp)) {
          return
      }
      var exps = exp.split('.')

      return function(obj) {//遍历获得嵌套对象属性值
          for (var i = 0; i < exps.length; i++) {
              if (!obj) return
              obj = obj[exps[i]]
          }
          return obj
      }
    }
// Watcher里面有两个属性：deps和newDeps。他们是用来记录上一次Watcher收集的依赖和新一轮Watcher收集的依赖，每一次有数据的更新都需要重新收集依赖（数据发布更新后，会调用Watcher的notify方法，notify方法会调用run方法，run方法会调用get方法，重新获取值，并重新收集依赖。
// this.cleanupDeps()这个函数的作用就是将新收集的依赖newDeps赋值给deps，并将newDeps清空，准备在下一次数据更新时收集依赖。所以这个函数不是真正的清空Watcher的依赖，而是清除临时保存依赖的newDeps。
    Watcher.prototype.cleanupDeps = function() {
      var self = this;
      var i = self.deps.length;
      while(i--) {//去除多余的订阅者
        var dep = self.deps[i]
        // //如果Watcher不依赖于某个数据，即某个Dep,那么不需要再订阅这个数据的消息。
        if(!self.newDepsIds.indexOf(dep.id)) {
          dep.removeSub(self);
        }
      }
      self.deps = self.newDeps.slice();
      self.depIds = self.newDepsIds.slice();
      self.newDepsIds = [];
      self.newDeps = [];
    }
// ================================================================
// 订阅器Dep主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数。
// 1.Dep是发布订阅者模型中的发布者，Watcher是观察者，一个Dep实例对应一个对象属性或一个被观察的对象，用来收集订阅者和在数据改变时，发布更新。
// 2.Dep实例有两种实例：
  // 1.第一种：在observe方法里生成的，用来给被观察的对象收集订阅者和发布更新，挂在对象的__   ob__对象上，通常在defineReactive函数里的getter函数里调用childOb.dep.depend()来收集依赖，在vm.$set/Vue.set和vm.$delete/Vue.delete这些api中调用来发布更新。
  // 2.第二种：在defineReactive函数里，是用来set/get数据时收集订阅者和发布更新的，保存在getter/setter闭包函数的作用域上。get数据时收集依赖，set数据时发布更新。

// 3.当我们想要给{testObjFirstEle: "testObjFirstEle"}对象添加属性并更新视图时有两种方式：
  // 1.利用getter/setter，重新设置testObj属性的值，testObj属性的setter执行的过程中会调用dep.notify（）发布更新。比如：this.testObj = {testObjFirstEle: "testObjFirstEle", "newEle": "newEle};
  // 2.利用$set函数：this.$set(this.testObj, "newEle", "newEle")。此时是{testObjFirstEle: "testObjFirstEle"}对象的__obj __对象上的dep发布的更新
  var uid = 0;
  function Dep () {
    this.id = uid++;
    this.subs = [];
  }
  Dep.target = null;

 //  添加一个订阅者
  Dep.prototype.addSub = function (sub) {
    this.subs.push(sub)
  }

 // * 移除一个订阅者
Dep.prototype.removeSub = function (sub) {
  let index = this.subs.indexOf(sub);
  if (index !== -1) {
    this.subs.splice(index, 1);
  }
}

 // 收集依赖后，调用了Dep的addSub方法，给Dep添加了一个订阅者
Dep.prototype.depend = function () {
  Dep.target.addDep(this)
}

//发布数据更新：通过调用subs里面的每个Watcher的update发布更新
  Dep.prototype.notify = function () {  
    var subs = this.subs.slice();
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  }


// ============================================
  function Compile(el, vm) {
  this.$vm = vm;
  this.$el = this.isElementNode(el) ? el : document.querySelector(el)
  if (this.$el) {
    this.compileElement(this.$el)
  }
}

// ==============================================================
// 解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。
Compile.prototype.compileElement = function (el) {
  let self = this
  let childNodes = el.childNodes;
  [].slice.call(childNodes).forEach(node => {
    let text = node.textContent
    let reg = /\{\{((?:.|\n)+?)\}\}/
    // 处理element节点
    if (self.isElementNode(node)) {
      self.compile(node)
    } else if (self.isTextNode(node) && reg.test(text)) { // 处理text节点{}
      self.compileText(node, RegExp.$1.trim())
    }
    }
    // 解析子节点包含的指令
    if (node.childNodes && node.childNodes.length) {
      self.compileElement(node)
    }
  })
}

Compile.prototype.compile = function (node) {
  let nodeAttrs = node.attributes
  let self = this;
  [].slice.call(nodeAttrs).forEach(attr => {
    var attrName = attr.name
    if (self.isDirective(attrName)) {//指令
      let exp = attr.value
      let dir = attrName.substring(2)
      if (self.isEventDirective(dir)) {//v-on
        compileUtil.eventHandler(node, self.$vm, exp, dir)
      } else {//v-html,v-text,v-model
        compileUtil[dir] && compileUtil[dir](node, self.$vm, exp)
      }
      node.removeAttribute(attrName);
    }
  });
}

Compile.prototype.compileText = function (node, exp) {
  compileUtil.text(node, this.$vm, exp);
}

Compile.prototype.isDirective = function (attr) {
  return attr.indexOf('v-') === 0
}

Compile.prototype.isEventDirective = function (dir) {
  return dir.indexOf('on') === 0;
}

Compile.prototype.isElementNode = function (node) {
  return node.nodeType === 1;
}

Compile.prototype.isTextNode = function (node) {
  return node.nodeType === 3;
}

// 指令处理集合
var compileUtil = {
  text: function (node, vm, exp) {
    this.bind(node, vm, exp, 'text')
  },
  html: function (node, vm, exp) {
    this.bind(node, vm, exp, 'html')
  },
  model: function (node, vm, exp) {
    this.bind(node, vm, exp, 'model')

    let self = this, val = this._getVMVal(vm, exp)
    node.addEventListener('input', function (e) {
      var newValue = e.target.value
      if (val === newValue) {
        return
      }
      self._setVMVal(vm, exp, newValue)
      val = newValue
    });
  },
  bind: function (node, vm, exp, dir) {
    var updaterFn = updater[dir + 'Updater']
    updaterFn && updaterFn(node, this._getVMVal(vm, exp))
    new Watcher(vm, exp, function (value, oldValue) {
      updaterFn && updaterFn(node, value, oldValue)
    })
  },
  eventHandler: function (node, vm, exp, dir) {
    var eventType = dir.split(':')[1],
        fn = vm.$options.methods && vm.$options.methods[exp];

    if (eventType && fn) {
      node.addEventListener(eventType, fn.bind(vm), false);
    }
  },
  _getVMVal: function (vm, exp) {
    var val = vm
    exp = exp.split('.')
    exp.forEach(function (k) {
      val = val[k]
    })
    return val
  },
  _setVMVal: function (vm, exp, value) {
    var val = vm;
    exp = exp.split('.')
    exp.forEach(function (k, i) {
      // 非最后一个key，更新val的值
      if (i < exp.length - 1) {
        val = val[k]
      } else {
        val[k] = value
      }
    })
  }
}

var updater = {
  textUpdater: function (node, value) {
    node.textContent = typeof value == 'undefined' ? '' : value
  },
  htmlUpdater: function (node, value) {
    node.innerHTML = typeof value == 'undefined' ? '' : value
  },
  modelUpdater: function (node, value, oldValue) {
    node.value = typeof value == 'undefined' ? '' : value
  }
}
// ====================================================================
/**
 * @class 双向绑定类 MVVM
 * @param {[type]} options [description]
 */
function MVVM(options) {
  this.$options = options || {}
  // 简化了对data的处理
  let data = this._data = this.$options.data,self = this;
  this.methods = options.methods;
  Object.keys(data).forEach(function(key) {
        self._proxy(key);
    });
  // 监听数据
  observe(data)
  new Compile(options.el || document.body, this);
  options.mounted.call(this); // 所有事情处理好后执行mounted函数
}

MVVM.prototype.$watch = function (expOrFn, cb) {
  new Watcher(this, expOrFn, cb)
}

MVVM.prototype._proxy = function (key) {// 绑定代理属性
  Object.defineProperty(this, key, {
    configurable: true,
    enumerable: true,
    get: () => this._data[key],
    set: (val) => {
      this._data[key] = val
    }
  })
}
var i=0;
let vm = new MVVM({
  el: '#app',
  data: {
      title: 'hello world',
      name: 'canfoo',
      list:[1,2,3,4,5],
      obj:{
        a:{c:'嵌套对象'},
        b:{c:{d:2}}
      },
      a:1,
      b:"<em>苏州</em>",
      mix:[{a:1},{b:2}]
  },
  methods: {
      clickMe: function () {

          this.list.push(parseInt(Math.random(0,1)*10))
      }
  },
  mounted: function () {
      // window.setTimeout(() => {
      //     this.title = '你好';
      // }, 1000);
  }
  })

MVVM.prototype.set = function(target, key, val) {
  //对于数组的处理，调用变异方法splice，这个时候数组的Dep会发布更新消息
  if(Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length,key);
    target.splice(key, 1, val);
    return val;
  }
  //如果set的是对象已经有的属性，那么该属性已经有getter/setter函数了，此时直接修改即可
  if(hasOwn(target, key)) {
    target[key] = val;
    return val;
  }
  var ob = (target).__ob__;
  if(!ob) {
    target[key] = val;
    return val;
  }
  //如果是对象没有的属性，则添加getter/setter
  defineReactive(ob.value, key, val);
  //对象发布更新
  ob.dep.notify();// data={testkey:{testValueKey:testValueValue}}，这个时候模板里有{{testkey}}，模板的Watcher在执行getter函数的时候，testkey属性的getter对应的dep会将此Watcher收集为订阅者；同时{testValueKey:testValueValue}对象也会将此Watcher收集为订阅者（我们在给testkey属性设置getter/setter函数时，会执行var childOb = observe(val)和childOb.dep.depend()，而此时的val就是{testValueKey:testValueValue}对象）。
// 在这个时候我们设置this.$set(this.testkey, "addKey", "addValue")，就会触发this.testkey对应的值：{testValueKey:testValueValue}对象的dep发布更新，而此时dep的订阅者中包含模板{{testkey}}的watcher,此时模板更新视图。同理每个数组也是有相应的dep来发布更新的，比如data={arr:[1,2,2]}}，此时[1,2,2]这个数组的__ obj__属性下也会有dep的。
  return val;
}


// 无法检测对象内部深层变化,删除属性

//表达式：a[0];简单运算;多个依赖

// 解决数组访问下标志修改:调用set更改
// 解决数组修改length:调用变异方法splice(length)
// 解决对象添加属性，set
  </script>
</body>
</html>

