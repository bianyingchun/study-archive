[参考文章](https://zhuanlan.zhihu.com/p/77733656)

### 进程

进程 Process 是计算机中的程序关于某数据集合上的一次运行活动，是**系统进行资源分配和调度的基本单位**，是操作系统结构的基础，进程是线程的容器（来自百科）。进程是资源分配的最小单位。我们启动一个服务、运行一个实例，就是开一个服务进程，例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 node app.js 开启一个服务进程，**多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。**

### 线程

线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。

### 单线程

单线程就是一个进程只开一个线程

Javascript 就是属于单线程，程序顺序执行(这里暂且不提 JS 异步)，可以想象一下队列，前面一个执行完之后，后面才可以执行，当你在使用单线程语言编码时切勿有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理。你如果采用 Javascript 进行编码时候，请尽可能的利用 Javascript 异步操作的特性。

### 单线程的一些说明

Node.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。
当你的项目中需要有大量计算，CPU 耗时的操作时候，要注意考虑开启多进程来完成了。
Node.js 开发过程中，错误会引起整个应用退出，应用的健壮性值得考验，尤其是错误的异常抛出，以及进程守护是必须要做的。
单线程无法利用多核 CPU，但是后来 Node.js 提供的 API 以及一些第三方工具相应都得到了解决，文章后面都会讲到。

### Node.js 中的进程与线程

Node.js 是 Javascript 在服务端的运行环境，构建在 chrome 的 V8 引擎之上，基于事件驱动、非阻塞 I/O 模型，充分利用操作系统提供的异步 I/O 进行多任务的执行，适合于 I/O 密集型的应用场景，因为异步，程序无需阻塞等待结果返回，而是基于回调通知的机制，原本同步模式等待的时间，则可以用来处理其它任务，

在单核 CPU 系统之上我们采用 单进程 + 单线程 的模式来开发。在多核 CPU 系统之上，可以通过 child_process.fork 开启多个进程（Node.js 在 v0.8 版本之后新增了 Cluster 来实现多进程架构） ，即 多进程 + 单线程 模式。注意：开启多进程不是为了解决高并发，主要是解决了单进程模式下 Node.js CPU 利用率不足的情况，充分利用多核 CPU 的性能。

### child_process

### cluster

cluster 模块调用 fork 方法来创建子进程，该方法与 child_process 中的 fork 是同一个方法。

cluster 模块采用的是经典的主从模型，Cluster 会创建一个 master，然后根据你指定的数量复制出多个子进程，可以使用 cluster.isMaster 属性判断当前进程是 master 还是 worker(工作进程)。由 master 进程来管理所有的子进程，**主进程不负责具体的任务处理，主要工作是负责调度和管理**。

cluster 模块使用内置的负载均衡来更好地处理线程之间的压力，该**负载均衡使用了 Round-robin 算法**（也被称之为循环算法）。当使用 Round-robin 调度策略时，master accepts()所有传入的连接请求，然后将相应的 TCP 请求处理发送给选中的工作进程（该方式仍然通过 IPC 来进行通信）。

开启多进程时候端口疑问讲解：如果多个 Node 进程监听同一个端口时会出现 Error:listen EADDRIUNS 的错误，**而 cluster 模块为什么可以让多个子进程监听同一个端口呢?原因是 master 进程内部启动了一个 TCP 服务器，而真正监听端口的只有这个服务器，当来自前端的请求触发服务器的 connection 事件后，master 会将对应的 socket 具柄发送给子进程**。

#### child_process 模块与 cluster 模块总结

无论是 child_process 模块还是 cluster 模块，为了解决 Node.js 实例单线程运行，无法利用多核 CPU 的问题而出现的。核心就是父进程（即 master 进程）负责监听端口，接收到新的请求后将其分发给下面的 worker 进程。

cluster 内部隐时的构建 TCP 服务器的方式来说对使用者确实简单和透明了很多，但是这种方式无法像使用 child_process 那样灵活，因为一直主进程只能管理一组相同的工作进程，而自行通过 child_process 来创建工作进程，一个主进程可以控制多组进程。原因是 child_process 操作子进程时，可以隐式的创建多个 TCP 服务器

### Node.js 进程通信原理

前面讲解的无论是 child_process 模块，还是 cluster 模块，都需要主进程和工作进程之间的通信。通过 fork()或者其他 API，创建了子进程之后，为了实现父子进程之间的通信，父子进程之间才能通过 message 和 send()传递信息。

IPC 这个词我想大家并不陌生，不管那一张开发语言只要提到进程通信，都会提到它。**IPC 的全称是 Inter-Process Communication,即进程间通信**。它的目的是为了让不同的进程能够互相访问资源并进行协调工作。**实现进程间通信的技术有很多，如命名管道，匿名管道，socket，信号量，共享内存，消息队列等**。Node 中实现 IPC 通道是依赖于 **libuv**。**windows 下由命名管道(name pipe)实现，linux 系统则采用 Unix Domain Socket 实现**。表现在应用层上的进程间通信只有简单的 message 事件和 send()方法，接口十分简洁和消息化。

父进程在实际创建子进程之前，会**创建 IPC 通道并监听它，然后才真正的创建出子进程**，这个过程中也会通过环境变量（NODE_CHANNEL_FD）告诉子进程这个**IPC 通道的文件描述符**。子进程在启动的过程中，根据文件描述符去连接这个已存在的 IPC 通道，从而完成父子进程之间的连接。
