## 事件循环流程

1. timers 阶段: 这个阶段执行 setTimeout(callback) and setInterval(callback)预定的 callback;
2. I/O  阶段: 上一轮循环中有少数的 I/O callback 会被延迟到这一轮的这一阶段执行
3. idle, prepare 阶段: 仅 node 内部使用;
4. poll 阶段: 获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里;
5. check 阶段: 执行 setImmediate() 设定的 callbacks;
6. close callbacks 阶段: 比如 socket.on(‘close’, callback)的 callback 会在这个阶段执行.

event loop 按顺序执行上面的六个阶段，每一个阶段都有一个装有 callbacks 的 fifo queue(队列)，当 event loop 运行到一个指定阶段时，node 将执行该阶段的 fifo queue(队列)，当队列 callback 执行完或者执行 callbacks 数量超过该阶段的上限时，event loop 会转入下一下阶段.

那么我们平常的异步 io 是在哪个阶段执行的呢，答案是 poll 阶段。

## 核心 poll 阶段

在 node.js 里，除了上面几个特定阶段的 callback 之外，任何异步方法完成时，都会将其callbacks callback 加到 poll queue 里。

- 当 event loop 到 poll 阶段时，且不存在 timer，将会发生下面的情况

  - 如果 poll queue 不为空，event loop 将同步的执行 queue 里的 callback,直至 queue 为空，或执行的 callback 到达系统上限;
  - 如果 poll queue 为空，将会发生下面情况：
    - 如果代码已经被 setImmediate()设定了 callback 或者有满足 close callbacks 阶段的 callback, event loop 将结束 poll 阶段进入 check 阶段，并执行 check 阶段的 queue (check 阶段的 queue 是 setImmediate 设定的)
    - 如果代码没有设定 setImmediate(callback)或者没有满足 close callbacks 阶段的 callback，event loop 将阻塞在该阶段等待 callbacks 加入 poll queue;

- 当 event loop 到 poll 阶段时，如果存在 timer 并且 timer 未到超时时间，将会发生下面情况：

则会把最近的一个 timer 剩余超时时间作为参数传入 io_poll()中，这样 event loop 阻塞在 poll 阶段等待时，如果没有任何 I/O 事件触发，也会由 timerout 触发跳出等待的操作，结束本阶段，然后在 close callbacks 阶段结束之后会在进行一次 timer 超时判断

所以实际上，timer 检查会发生在两个地方：timers 阶段和 close callbacks 阶段结束之后。

> 其实 event 是由 uv_run 驱动的，并且是在 UV_RUN_ONCE 的模式下执行
> UV_RUN_ONCE 就是你文中描述的 poll 阶段: 获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里;
> 中的“适当条件”，它会阻塞在 kqueue 的 kevent()函数中（这里以 mac 为例，linux 下这一块由 epoll_wait()函数处理，windows 下则是 IOCP）
> 这里描述 UV_RUN_ONCE 为适当条件，是因为 uv_run 还有两种模式，对于 UV_RUN_NOWAIT 的模式，io_poll 不会阻塞，会立即触发超时结束当前的 event_loop，进入下一次循环（v4.4.2 版本中仅用在进程退出前的最后检查）
> 实际上，你描述的 timer，在一次 event loop 中可能在两个地方执行：
> 最开始以及 close callbacks 结束之后,为什么这么说呢，就算不看源代码，我们也可以思考这样的一个场景：当你设置了一个超时 timer，那么第一次进入 uv_run_timer 时，超时时间未到；此时进入 kevent()阻塞等待,如果此处不提供超时机制，那就会永远阻塞在 kevent()的 I/O 等待中；所以我们在
> 当前的 event loop 循环中的某一次时，如果存在 timer 且为达到设定时间，则会把最近的一个 timer 剩余超时时间作为参数传入 io_poll()中，这样 kevent()等待时，如果没有任何 I/O 事件触发，也会由 timerout 触发跳出等待的操作，结束本次时间循环
> 所以呢，在 UV_RUN_ONCE 的模式下，每次循环结束前，即你说的 close callback 执行结束后，会再执行一次对 timer 的超时判断
> 具体涉及到的代码如下：

```c++
//deps/uv/src/unix/core.c
int uv_run(uv_loop_t *loop, uv_run_mode mode) {
	int timeout;
	int r;
	int ran_pending;
	//uv__loop_alive返回的是event loop中是否还有待处理的handle或者request
	//以及closing_handles是否为NULL,如果均没有,则返回0
	r = uv__loop_alive(loop);
	//更新当前event loop的时间戳,单位是ms
	if (!r)
    	uv__update_time(loop);
	while (r != 0 && loop->stop_flag == 0) {
    	//使用Linux下的高精度Timer hrtime更新loop->time,即event loop的时间戳
    	uv__update_time(loop);
    	//执行判断当前loop->time下有无到期的Timer,显然在同一个loop里面timer拥有最高的优先级
    	uv__run_timers(loop);
    	//判断当前的pending_queue是否有事件待处理,并且一次将&loop->pending_queue中的uv__io_t对应的cb全部拿出来执行
    	ran_pending = uv__run_pending(loop);
    	//实现在loop-watcher.c文件中,一次将&loop->idle_handles中的idle_cd全部执行完毕(如果存在的话)
    	uv__run_idle(loop);
    	//实现在loop-watcher.c文件中,一次将&loop->prepare_handles中的prepare_cb全部执行完毕(如果存在的话)
    	uv__run_prepare(loop);

    	timeout = 0;
    	//如果是UV_RUN_ONCE的模式,并且pending_queue队列为空,或者采用UV_RUN_DEFAULT(在一个loop中处理所有事件),则将timeout参数置为
    	//最近的一个定时器的超时时间,防止在uv_io_poll中阻塞住无法进入超时的timer中
    	if ((mode == UV_RUN_ONCE && !ran_pending) || mode == UV_RUN_DEFAULT)
        	timeout = uv_backend_timeout(loop);
    	//进入I/O处理的函数(重点分析的部分),此处挂载timeout是为了防止在uv_io_poll中陷入阻塞无法执行timers;并且对于mode为
    	//UV_RUN_NOWAIT类型的uv_run执行,timeout为0可以保证其立即跳出uv__io_poll,达到了非阻塞调用的效果
    	uv__io_poll(loop, timeout);
    	//实现在loop-watcher.c文件中,一次将&loop->check_handles中的check_cb全部执行完毕(如果存在的话)
    	uv__run_check(loop);
    	//执行结束时的资源释放,loop->closing_handles指针指向NULL
    	uv__run_closing_handles(loop);

    	if (mode == UV_RUN_ONCE) {
        	//如果是UV_RUN_ONCE模式,继续更新当前event loop的时间戳
        	uv__update_time(loop);
        	//执行timers,判断是否有已经到期的timer
        	uv__run_timers(loop);
    	}
    	r = uv__loop_alive(loop);
    	//在UV_RUN_ONCE和UV_RUN_NOWAIT模式中,跳出当前的循环
    	if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)
        	break;
		}

	//标记当前的stop_flag为0,表示当前的loop执行完毕
	if (loop->stop_flag != 0)
    	loop->stop_flag = 0;
	//返回r的值
	return r;
}
```

## 实例

以上便是整个 event loop 时间循环的各个阶段运行机制，有了这层理解，我们来看几个例子

注意，例子中给出的时间在不同机器下和同一机器下不同执行时刻，其值都会有差异。

### example1

```js
var fs = require("fs");

function someAsyncOperation(callback) {
  // 花费2毫秒
  fs.readFile(__dirname + "/" + __filename, callback);
}

var timeoutScheduled = Date.now();
var fileReadTime = 0;

setTimeout(function () {
  var delay = Date.now() - timeoutScheduled;
  console.log("setTimeout: " + delay + "ms have passed since I was scheduled");
  console.log("fileReaderTime", fileReadtime - timeoutScheduled);
}, 10);

someAsyncOperation(function () {
  fileReadtime = Date.now();
  while (Date.now() - fileReadtime < 20) {}
});
```

结果: 先执行 someAsyncOperation 的 callback,再执行 setTimeout callback

```bash
-> node eventloop.js
setTimeout: 22ms have passed since I was scheduled
fileReaderTime 2
```

解释：
当时程序启动时，event loop 初始化：

1. timer 阶段（无 callback 到达，setTimeout 需要 10 毫秒）
2. i/o callback 阶段，无异步 i/o 完成
3. 忽略
4. poll 阶段，阻塞在这里，当运行 2ms 时，fs.readFile 完成，将其 callback 加入 poll 队列，并执行 callback， 其中 callback 要消耗 20 毫秒,等 callback 之行完，poll 处于空闲状态，由于之前设定了 timer，因此检查 timers,发现 timer 设定时间是 20ms，当前时间运行超过了该值，因此，立即循环回到 timer 阶段执行其 callback,因此，虽然 setTimeout 的 20 毫秒，但实际是 22 毫秒后执行。

### example 2

```js
var fs = require("fs");

function someAsyncOperation(callback) {
  var time = Date.now();
  // 花费9毫秒
  fs.readFile("/path/to/xxxx.pdf", callback);
}

var timeoutScheduled = Date.now();
var fileReadTime = 0;
var delay = 0;

setTimeout(function () {
  delay = Date.now() - timeoutScheduled;
}, 5);

someAsyncOperation(function () {
  fileReadtime = Date.now();
  while (Date.now() - fileReadtime < 20) {}
  console.log("setTimeout: " + delay + "ms have passed since I was scheduled");
  console.log("fileReaderTime", fileReadtime - timeoutScheduled);
});
```

结果：setTimeout callback 先执行，someAsyncOperation callback 后执行

```bSH
-> node eventloop.js
setTimeout: 7ms have passed since I was scheduled
fileReaderTime 9
```

解释：

当时程序启动时，event loop 初始化：

1. timer 阶段（无 callback 到达，setTimeout 需要 10 毫秒）
2. i/o callback 阶段，无异步 i/o 完成
3. 忽略
4. poll 阶段，阻塞在这里，当运行 5ms 时，poll 依然空闲，但已设定 timer,且时间已到达，因此，event loop 需要循环到 timer 阶段,执行 setTimeout callback,由于从 poll --> timer 中间要经历 check,close 阶段,这些阶段也会消耗一定时间，因此执行 setTimeout callback 实际是 7 毫秒 然后又回到 poll 阶段等待异步 i/o 完成，在 9 毫秒时 fs.readFile 完成，其 callback 加入 poll queue 并执行。

## setTimeout 和 setImmediate

```js
setTimeout(function timeout() {
  console.log("timeout");
}, 0);

setImmediate(function immediate() {
  console.log("immediate");
});
```

**上述二者的执行顺序是不确定的。**

因为在 node 中，setTimeout(cb, 0) === setTimeout(cb, 1);而 setImmediately 属于 uv_run_check 的部分确实每次 loop 进来，都是先检查 uv_run_timer 的，但是由于 cpu 工作耗费时间，比如第一次获取的 hrtime 为 0 那么 setTimeout(cb, 1)，超时时间就是 loop->time = 1(ms，node 定时器精确到 1ms，但是 hrtime 是精确到纳秒级别的)所以第一次 loop 进来的时候就有两种情况：

1. 由于第一次 loop 前的准备耗时超过 1ms，当前的 loop->time >=1 ，则 uv_run_timer 生效，timeout 先执行
2. 由于第一次 loop 前的准备耗时小于 1ms，当前的 loop->time < 1，则本次 loop 中的第一次 uv_run_timer 不生效，那么 io_poll 后先执行 uv_run_check，即 immediate 先执行，然后等 close cb 执行完后，继续执行 uv_run_timer

**但当二者在异步 i/o callback 内部调用时，总是先执行 setImmediate，再执行 setTimeout**

```js
var fs = require("fs");

fs.readFile(__filename, () => {
  setTimeout(() => {
    console.log("timeout");
  }, 0);
  setImmediate(() => {
    console.log("immediate");
  });
});
```

因为 fs.readFile callback 执行完后，程序设定了 timer 和 setImmediate，因此 poll 阶段不会被阻塞进而进入 check 阶段先执行 setImmediate，最后 close callbacks 阶段结束后检查 timer，执行 timeout 事件

## Process.nexTick()

process.nextTick()不在 event loop 的任何阶段执行，而是在各个阶段切换的中间执行,即从一个阶段切换到下个阶段前执行。

```js
var fs = require('fs');

fs.readFile(\_\_filename, () => {
  setTimeout(() => {
    console.log('setTimeout');
  }, 0);
  setImmediate(() => {
    console.log('setImmediate');
    process.nextTick(()=>{
    console.log('nextTick3');
  })
  });
  process.nextTick(()=>{
    console.log('nextTick1');
  })
  process.nextTick(()=>{
    console.log('nextTick2');
  })
  });
// 执行结果：
// nextTick1
// nextTick2
// setImmediate
// nextTick3
// setTimeout
```

从 poll —> check 阶段，先执行 process.nextTick，nextTick1，nextTick2。然后进入 check 执行 setImmediate，setImmediate 执行完后，出 check,进入 close callback 前，执行 process.nextTick ，nextTick3。最后进入 timer 执行 setTimeout

process.nextTick()是 node 早期版本无 setImmediate 时的产物，node 作者推荐我们尽量使用 setImmediate。

### 参考文章

1. https://cnodejs.org/topic/57d68794cb6f605d360105bf
2. https://juejin.cn/post/6844903650708602888
3. https://cnodejs.org/topic/5a9108d78d6e16e56bb80882
