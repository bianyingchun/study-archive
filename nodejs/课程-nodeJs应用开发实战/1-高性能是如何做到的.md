Node.js 10+ 版本后虽然在运行结果上与浏览器一致，但是两者在原理上一个是基于**浏览器**，一个是基于 **libev 库**。浏览器核心的是**宏任务和微任务**，而在 Node.js 还有**阶段性任务执行阶段**。

## 事件循环

![event loop](http://cdn.bianyc.xyz/node-event-loop.png)

#### 运行起点

Node.js 事件循环的发起点有 4 个：

- Node.js 启动后；

- setTimeout 回调函数；

- setInterval 回调函数；

- 也可能是一次 I/O 后的回调函数。

#### 任务

1. 微任务：在 Node.js 中微任务包含 2 种——process.nextTick 和 Promise。process.nextTick 高于 Promise。微任务在事件循环中优先级是最高的，因此在同一个事件循环中有其他任务存在时，优先执行微任务队列。

2. 宏任务：在 Node.js 中宏任务包含 4 种——setTimeout、setInterval、setImmediate 和 I/O。宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么优先将微任务队列清空，再执行宏任务队列。

### nodejs 的特点

- nodejs 具有**事件驱动和非阻塞 I/O**的特点。

- 事件驱动是指 nodejs 把**每一个任务当成事件来处理**。

- 非阻塞 I/O 是指 nodejs 遇到 I/O 任务时，会从**线程池调度单独的线程处理 I/O 操作**，不会阻塞主线程。

#### NodeJs 是单线程还是多线程

Node.js 本身是一个多线程平台，而它对 JavaScript 层面的任务处理是单线程的。

主线程是单线程执行的，但是 Node.js 存在多线程执行，多线程包括 setTimeout 和异步 I/O 事件。其实 Node.js 还存在其他的线程，包括垃圾回收、内存优化等。

#### 事件循环原理

1. Node.js 在**主线程里维护了一个事件队列**，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。

2. 当**主线程空闲**时(没有请求接入时)，就开始**循环事件队列**，检查队列中是否有要处理的事件，这时要分两种情况：

   - 如果是**非 I/O 任务，就亲自处理**，并通过回调函数返回到上层调用；

   - 如果是**I/O 任务，就从 线程池 中拿出一个线程来处理这个事件**，并指定回调函数，然后继续循环队列中的其他事件。

3. 当 **I/O 任务完成以后就执行回调**，把请求结果存入事件中，并将该**事件重新放入队列中，等待循环，最后释放当前线程**，当**主线程再次循环到该事件时，就直接处理**了。

![](http://cdn.bianyc.xyz/node-event-loop2.png)

### 6 个阶段

1. timers：执行 setTimeout() 和 setInterval()中到期的 callback。

   timers 指定 可执行所提供回调 的 时间阈值，poll 阶段 控制何时定时器执行。

   一旦 poll queue 为空，事件循环将检查 已达到时间阈值的 timer 计时器。如果 S 一个或多个计时器已准备就绪，则事件循环将回到 timer 阶段以执行这些计时器的回调

2. pending callacks：**上一轮循环中有少数的 I/O callback** 会被延迟到这一轮的这一阶段执行。

3. idle, prepare：仅供系统内部使用
4. poll：**检索新的 I/O 事件，执行与 I/O 相关的回调**，其他情况 Node.js 将在适当的时候在此阻塞。这也是最复杂的一个阶段，**所有的事件循环以及回调处理都在这个阶段执行**，接下来会详细分析这个过程。

poll 阶段有两个重要的功能：

- 计算应该阻塞和 poll I/O 的时间。
- 然后，处理 poll 队列里的事件。当事件循环进入 poll 阶段且 timers scheduled，将发生以下两种情况之一：

  - if the poll queue is not empty, 事件循环将循环访问其回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬限制
  - If the poll queue is empty，还有两件事发生
    如果脚本已按 setImmediate() 排定，则事件循环将结束 poll 阶段，并继续 check 阶段以执行这些计划脚本。
    如果脚本尚未按 setImmediate()排定，则事件循环将等待回调添加到队列中，然后立即执行。
    一旦 poll queue 为空，事件循环将检查 已达到时间阈值的 timer 计时器。如果一个或多个计时器已准备就绪，则事件循环将回到 timer 阶段以执行这些计时器的回调

5. check：**setImmediate() 回调函数在这里执行**，setImmediate 并不是立马执行，而是当事件循环 poll 中没有新的事件处理时就执行该部分。

6. close callbacks：**执行一些关闭的回调函数**，例如 socket.on("close",func)

#### 下面我们来按照代码第一次进入 libuv 引擎后的顺序来详细解说这些阶段：

当个 v8 引擎将 js 代码解析后传入 libuv 引擎后，循环首先进入 poll 阶段。

poll 阶段的执行逻辑如下：

1. 先查看 poll queue 中是否有事件，有事件就按先进先出的顺序依次执行回调。

2. 当 queue 为空时，会检查是否有 setImmediate()的 callback，如果有就进入 check 阶段执行这些 callback。

3. 当 queue 为空时，同时也会检查是否有到期的 timer，如果有，就把这些到期的 timer 的 callback 按照调用顺序放到 timer queue 中，之后循环会进入 timer 阶段执行 queue 中的 callback。

   这两者的顺序是不固定的，收到代码运行的环境的影响。

   如果两者的 queue 都是空的，那么 loop 会在 poll 阶段停留，直到有一个 i/o 事件返回，循环会进入 i/o callback 阶段并立即执行这个事件的 callback。

4. 值得注意的是，poll 阶段在执行 poll queue 中的回调时实际上不会无限的执行下去。

5. 有两种情况 poll 阶段会终止执行 poll queue 中的下一个回调： 1. 所有回调执行完毕。 2. 执行数超过了 node 的限制。

#### 事件循环关键 POLL

在上面的核心流程中真正需要关注循环执行的就是 poll 这个过程。在 poll 过程中，主要处理的是异步 I/O 的回调函数，以及其他几乎所有的回调函数，异步 I/O 又分为网络 I/O 和文件 I/O。这是我们常见的代码逻辑部分的异步回调逻辑。

事件循环的主要包含微任务和宏任务。具体是怎么进行循环的呢？如图 所示。
![事件循环过程](./%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E8%BF%87%E7%A8%8B.png)

在图 2 的左侧，我们可以看到有一个核心的主线程，它的执行阶段主要处理三个核心逻辑。

- 同步代码。

- 将异步任务插入到微任务队列或者宏任务队列中。

- 执行微任务或者宏任务的回调函数。在主线程处理回调函数的同时，也需要判断是否插入微任务和宏任务。根据优先级，先判断微任务队列是否存在任务，存在则先执行微任务，不存在则判断在宏任务队列是否有任务，有则执行。
  如果微任务和宏任务都只有一层时，那么看起来是比较简单的，比如下面的例子：

```js
const fs = require("fs");
// 首次事件循环执行
console.log("start");
/// 将会在新的事件循环中的阶段执行
fs.readFile("./test.conf", { encoding: "utf-8" }, (err, data) => {
  if (err) throw err;
  console.log("read file success");
});
setTimeout(() => {
  // 新的事件循环的起点
  console.log("setTimeout");
}, 0);
/// 该部分将会在首次事件循环中执行
Promise.resolve().then(() => {
  console.log("Promise callback");
});
/// 执行 process.nextTick
process.nextTick(() => {
  console.log("nextTick callback");
});
// 首次事件循环执行
console.log("end");
```

根据上面介绍的执行过程，我们来分析下上面代码的执行过程：

1. 第一个事件循环主线程发起，因此先执行同步代码，所以先输出 start，然后输出 end；

2. 再从上往下分析，遇到微任务，插入微任务队列，遇到宏任务，插入宏任务队列，分析完成后，微任务队列包含：Promise.resolve 和 process.nextTick，宏任务队列包含：fs.readFile 和 setTimeout；

3. 先执行微任务队列，但是根据优先级，先执行 process.nextTick 再执行 Promise.resolve，所以先输出 nextTick callback 再输出 Promise callback；

4. 再执行宏任务队列，根据宏任务插入先后顺序执行 setTimeout 再执行 fs.readFile，这里需要注意，先执行 setTimeout 由于其回调时间较短，因此回调也先执行，并非是 setTimeout 先执行所以才先执行回调函数，但是它执行需要时间肯定大于 1ms，所以虽然 fs.readFile 先于 setTimeout 执行，但是 setTimeout 执行更快，所以先输出 setTimeout ，最后输出 read file success。

根据上面的分析，我们可以得到如下的执行结果：

```bash
start
end
nextTick callback
Promise callback
setTimeout
read file success
```

但是当微任务和宏任务又产生新的微任务和宏任务时，又应该如何处理呢？如下代码所示：

```js
const fs = require("fs");
setTimeout(() => {
  // 新的事件循环的起点
  console.log("1");
  fs.readFile("./config/test.conf", { encoding: "utf-8" }, (err, data) => {
    if (err) throw err;
    console.log("read file sync success");
  });
}, 0);
/// 回调将会在新的事件循环之前
fs.readFile("./config/test.conf", { encoding: "utf-8" }, (err, data) => {
  if (err) throw err;
  console.log("read file success");
});
/// 该部分将会在首次事件循环中执行
Promise.resolve().then(() => {
  console.log("poll callback");
});
// 首次事件循环执行
console.log("2");
```

在上面代码中，有 2 个宏任务和 1 个微任务，宏任务是 setTimeout 和 fs.readFile，微任务是 Promise.resolve。

整个过程优先执行主线程的第一个事件循环过程，所以先执行同步逻辑，先输出 2。

接下来执行微任务，输出 poll callback。

再执行宏任务中的 fs.readFile 和 setTimeout，由于 fs.readFile 优先级高，先执行 fs.readFile。但是处理时间长于 1ms，因此会先执行 setTimeout 的回调函数，输出 1。这个阶段在执行过程中又会产生新的宏任务 fs.readFile，因此又将该 fs.readFile 插入宏任务队列。

最后由于只剩下宏任务了 fs.readFile，因此执行该宏任务，并等待处理完成后的回调，输出 read file sync success。

根据上面的分析，我们可以得出最后的执行结果，如下所示：

```bash
2
poll callback
1
read file success
read file sync success
在上面的例子中，我们来思考一个问题，主线程是否会被阻塞，具体我们来看一个代码例子：

复制代码
const fs = require('fs');
setTimeout(() => { // 新的事件循环的起点
    console.log('1');
    sleep(10000)
    console.log('sleep 10s');
}, 0);
/// 将会在 poll 阶段执行
fs.readFile('./test.conf', {encoding: 'utf-8'}, (err, data) => {
    if (err) throw err;
    console.log('read file success');
});
console.log('2');

/// 函数实现，参数 n 单位 毫秒 ；
function sleep ( n ) {
    var start = new Date().getTime() ;
    while ( true ) {
        if ( new Date().getTime() - start > n ) {
            // 使用  break  实现；
            break;
        }
    }
}
```

我们在 setTimeout 中增加了一个阻塞逻辑，这个阻塞逻辑的现象是，只有等待当次事件循环结束后，才会执行 fs.readFile 回调函数。这里会发现 fs.readFile 其实已经处理完了，并且通知回调到了主线程，但是由于主线程在处理回调时被阻塞了，导致无法处理 fs.readFile 的回调。因此可以得出一个结论，**主线程会因为回调函数的执行而被阻塞**，这也符合图 2 中的执行流程图。

如果把上面代码中 setTimeout 的时间修改为 10 ms，你将会优先看到 fs.readFile 的回调函数，因为 fs.readFile 执行完成了，并且还未启动下一个事件循环，修改的代码如下：

```js
setTimeout(() => {
  // 新的事件循环的起点
  console.log("1");
  sleep(10000);
  console.log("sleep 10s");
}, 10);
```

最后我们再来回答第 5 个问题，当所有的微任务和宏任务都清空的时候，虽然当前没有任务可执行了，但是也并不能代表循环结束了。因为可能存在当前还未回调的异步 I/O，所以这个循环是没有终点的，只要进程在，并且有新的任务存在，就会去执行。

#### setImmediate() 对比 setTimeout()

setImmediate() 和 setTimeout() 很类似，但是基于被调用的时机，他们也有不同表现。

- setImmediate() 设计为一旦在当前 poll 阶段完成， 就执行脚本。
- setTimeout() 在最小阈值（ms 单位）过后运行脚本。

执行计时器的顺序将根据调用它们的上下文而异。
如果二者都从主模块内调用，则计时器将受进程性能的约束（这可能会受到计算机上其他正在运行应用程序的影响）。

例如，如果运行以下不在 I/O 周期（即主模块）内的脚本，则执行两个计时器的顺序是非确定性的，因为它受进程性能的约束：

```js
// timeout_vs_immediate.js
setTimeout(() => {
  console.log("timeout");
}, 0);

setImmediate(() => {
  console.log("immediate");
});
```

```bash
$ node timeout_vs_immediate.js
timeout
immediate

$ node timeout_vs_immediate.js
immediate
timeout
```

但是，如果你把这两个函数放入一个 I/O 循环内调用，setImmediate 总是被优先调用：

```js
// timeout_vs_immediate.js
const fs = require("fs");

fs.readFile(__filename, () => {
  setTimeout(() => {
    console.log("timeout");
  }, 0);
  setImmediate(() => {
    console.log("immediate");
  });
});
```

```bash
$ node timeout_vs_immediate.js
immediate
timeout

$ node timeout_vs_immediate.js
immediate
timeout
```

使用 setImmediate() 相对于 setTimeout() 的主要优势是，**如果 setImmediate()是在 I/O 周期内被调度的，那它将会在其中任何的定时器之前执行，跟这里存在多少个定时器无关**

#### process.nextTick

process.nextTick() 在技术上不是事件循环的一部分，无论事件循环的当前阶段如何，都将在当前操作完成后处理 nextTickQueue。这里的一个操作被视作为一个从 C++ 底层处理开始过渡，并且处理需要执行的 JavaScript 代码。

回顾我们的关系图，任何时候在给定的阶段中调用 process.nextTick()，**所有传递到 process.nextTick() 的回调将在事件循环继续之前得到解决**。这可能会造成一些糟糕的情况, 因为它允许您通过进行递归 process.nextTick() 来“饿死”您的 I/O 调用，阻止事件循环到达 poll 阶段。
一个题目

```js
// test.js
process.nextTick(function() {
  console.log('next tick');
});

setTimeout(function() {
  console.log('settimeout');
});

(async function() {
  console.log('async promise');
})();

setImmediate(function() {
  console.log('setimmediate');
});

$ node test.js
async promise
next tick
settimeout
setimmediate
```

- 没有 await，async 那句其实是同步执行的，故而第一句输出。
- next tick 在任何事件循环阶段继续之前得到解决，故而第二句
- setTimeout 在主线程中与 setImmediate 的执行顺序是非确定性的
  [初探 nodejs 事件循环机制 event loop](https://www.cnblogs.com/zifayin/p/11419808.html)

```js
// test.js
setTimeout(function () {
  process.nextTick(function() {
    console.log('next tick');
  });

  setTimeout(function() {
    console.log('settimeout');
  });

  (async function() {
    console.log('async promise');
  })();

  setImmediate(function() {
    console.log('setimmediate');
  });
})

$ node test.js
async promise
next tick
setimmediate
settimeout
```

setimmediate 与 settimeout 放入一个 I/O 循环内调用，则 setImmediate 总是被优先调用

https://blog.csdn.net/i10630226/article/details/81369841

cnblogs.com/everlose/p/12846375.html

https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/

https://www.cnblogs.com/onepixel/p/7143769.html
