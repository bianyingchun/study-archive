### 代码逻辑

#### 1. cpu 密集型计算

在 Node.js 中由于主线程是单线程的，无论是主线程逻辑，还是回调处理逻辑，最终都是在主线程处理，那么如果该线程一直在处理复杂的计算，其他请求就无法再次进来，也就是单个用户就可以阻塞所有用户的请求。因此保持主线程的通畅是非常关键的。

在 Node.js 中有以下几种情况，会影响到主线程的运行，应该主动避免：

- 大的数据循环
  比如没有利用好数据流，一次性处理非常大的数组；

- 字符串处理转化
  比如加解密、字符串序列化等；

- 图片、视频的计算处理
  比如对图片进行裁剪、缩放或者切割等。

### 2.网络 I/O

网络 I/O 中有 2 种相关的类型，同步阻塞 I/O 和 异步非阻塞 I/O：

- 同步阻塞 I/O
  字面意思是发出网络请求后需要等待返回后，再处理其他计算；

- 异步非阻塞 I/O
  就是发起网络 I/O 后，还可以处理其他的计算，这也是为什么 Node.js 在处理网络 I/O 性能较高的原因

举个例子，假设我们有个功能需要访问一个 API 的数据，Node.js 调用 API 就是一种网络 I/O：

如果该 API 处理慢，那么则所有用户请求都被阻塞了；

而如果异步的话，则无须等待处理，可以继续其他的运行。

网络 I/O 其实是 Node.js 的优势，虽然不影响主线程的处理，但是对于 http://127.0.0.1:4000/v1/cpu 这个请求，如果要提升性能，我们应该关注什么呢？

- 通道复用
  比如我们现在每次访问 :4000/v1/cpu 时都会发起一个 TCP 到 :3000/v1/cpu，如果能够通道复用，减少 TCP 握手，那么就可以提升该接口的性能，或者将某些内部服务使用 UDP 来实现。

- 增加缓存
  对于相同响应的返回数据，增加缓存处理，避免不必要的计算，对于上面的计算，我们完全可以缓存计算结果，这样来减少网络 I/O。

- 长链接链接池
  有一些网络 I/O 是长链接的形式，比如 MySQL、Mamcached 或者 Redis，为了避免排队使用长链接的问题，可以使用链接池，而由于 Redis 和 Node.js 是单线程非阻塞处理，因此可以不用链接池。

### 3.磁盘 I/O

和网络 I/O 相似，在一般情况下磁盘 I/O 是不会影响到主线程性能的，因为磁盘 I/O 也是异步其他线程处理。这里所说的也不是主线程的问题，而是涉及磁盘 I/O 的服务请求。因为服务器的磁盘性能是一定的，如果在高并发情况下，磁盘 I/O 压力较大，从而导致磁盘 I/O 的服务性能下降。

在实际开发过程中，最常见的磁盘 I/O 场景，那就是日志模块，因为日志是需要写文件，从而会有频繁的日志写入。和网络 I/O 相似，磁盘 I/O 也会从侧面的影响机器性能，导致 Node.js 服务性能受影响。

在上面 3 种情况中，只有 CPU 密集计算会真正影响到 Node.js 服务性能，而网络 I/O 和磁盘 I/O 都是直接影响服务器性能，从而侧面影响到 Node.js 服务性能，一般这时候就需要调整服务器配置或者做一些队列优化方式来提升服务器性能，

## 集群服务

后台服务一般都有集群的概念，无论是多机器部署，还是单机器（Node.js cluster 模式）

### 1.多进程 cluster 模式

这种模式的主进程也就是上一讲中的 master 进程会存在瓶颈，因为所有的请求都必须经过 master 进程进行分发，同时接收处理 worker 进程的返回。

在实际开发过程中，遇到一个问题，由于我们所用机器是一个 96 核以上的服务器，因此启用了比较多的 worker 进程，而主进程只有一个，从而在单机高并发时（2 万以上的每秒并发请求）会导致 master 进程处理瓶颈，这样就影响到了服务性能，并且这时候你会发现 worker 进程的 CPU 并没有任何压力。

以上这点非常重要，在生产环境下一般很难发现这类问题，不过你应该有一个这样的概念：大概在 2 万以上的并发时，master 进程会存在性能瓶颈。

## 其他相关

对于 Node.js 后台服务，我们不仅仅要考虑其本身的性能影响，更应该考虑它对服务器资源竞争产生的性能影响。比如无节制地使用服务器的内存或者句柄，都会导致服务器的异常，而服务器的异常则从侧面影响到 Node.js 本身的性能。

### 1.内存限制

在 32 位服务器上 Node.js 的内存限制是 0.7 G，而在 64 位服务器上则是 1.4 G，而这个限制主要是因为 Node.js 的垃圾回收线程在超过限制内存时，回收时长循环会大于 1s，从而会影响性能问题。

现网我们一般会启用多个进程，如果每个进程损耗 1.4 G，那么加起来可能超出了服务器内存上限，从而导致服务器瘫痪。其次如果内存不会超出服务器上限，而是在达到一定上限时，也就是我们上面说的 0.7 G 和 1.4 G，会导致服务器重启，从而会导致接口请求失败的问题。

### 2.句柄限制

句柄可以简单理解为一个 ID 索引，通过这个索引可以访问到其他的资源，比如说文件句柄、网络 I/O 操作句柄等等，而一般服务器句柄都有上限。当 Node.js 没有控制好句柄，比如说无限的打开文件并未关闭，就会出现句柄泄漏问题，而这样会导致服务器异常，从而影响 Node.js 服务。

以上这两点我们都需要有一定的工具检测方法，在服务上限之前进行检测，其次也需要有一定的定位的方法，在出现现网异常时，能够定位出具体的问题，这也就是我们接下来会涉及的知识点。
