### node 的事件循环

1. times： 这个阶段执行 setTimeout(callback) and setInterval(callback)预定的 callback;
2. io callback： 上一轮循环中有少数的 I/O callback 会被延迟到这一轮的这一阶段执行
3. idel： 仅 node 内部使用
4. poll ：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里;
   1. 不存在 timer
      1. poll 为空
         1. setImmediate()设定了 callback 或者有满足 close callbacks 阶段的 callback,执行下一个阶段
         2. 代码没有设定 setImmediate(callback)或者没有满足 close callbacks 阶段的 callback，event loop 将阻塞在该阶段等待 callbacks 加入 poll queue;
      2. poll 不为空
         event loop 将同步的执行 queue 里的 callback,直至 queue 为空，或执行的 callback 到达系统上限;
   2. 存在 timer,且 timer 未到超时时间
      则会把最近的一个 timer 剩余超时时间作为参数传入 io_poll()中，这样 event loop 阻塞在 poll 阶段等待时，如果没有任何 I/O 事件触发，也会由 timerout 触发跳出等待的操作，结束本阶段，然后在 close callbacks 阶段结束之后会在进行一次 timer 超时判断
5. check： 执行 setImmediate() 设定的 callbacks;
6. close： 比如 socket.on(‘close’, callback)的 callback 会在这个阶段执行.

event loop 按顺序执行上面的六个阶段，每一个阶段都有一个装有 callbacks 的 fifo queue(队列)，当 event loop 运行到一个指定阶段时，node 将执行该阶段的 fifo queue(队列)，当队列 callback 执行完或者执行 callbacks 数量超过该阶段的上限时，event loop 会转入下一下阶段.
