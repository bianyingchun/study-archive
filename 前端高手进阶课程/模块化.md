### 1.1 为什么需要模块化

没有模块化前的项目，常常在一个 JS 文件中会有很多功能的代码，这使得文件很大，分类性不强，自然而然不易维护；
那么我们将一个大的 JS 文件根据一定的规范拆分成几个小的文件的话将会便于管理，可以提高复用性，随之，可以起到分治的效果；
一个复杂的项目肯定有很多相似的功能模块，如果每次都需要重新编写模块肯定既费时又耗力。同样，某个功能别人已经造好了轮子，我们就调来用用就好，这时就要引用别人编写模块，引用的前提是要有统一的「打开姿势」，如果每个人有各自的写法，那么肯定会乱套，所以会引出模块化规范；
现在常用的 JavaScript 模块化规范有四种： Commonjs ， AMD , CMD , ES6 模块化 。个人理解，ES6 模块化才是主流。

### 1.2 模块的定义

**将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起块的内部数据相对而言是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信**

所以，我们发现学习或建立模块就是抓住两点：如何引入模块？如何暴露模块？

### 1.3 模块化的定义

编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目

### 1.4 模块化的优势

1. 方便维护代码，更好的分离，按需加载
2. 提高代码复用性
3. 降低代码耦合度（降偶）
4. 分治思想——模块化不仅仅只是复用，不管你将来是否要复用某段代码，你都有充分的理由将其分治为一个模块。（我们在开发中有时候经常会出现一个模块，实则只用到了一次，但还是抽离出来作为单个独立的模块，这就是分而治之的软件工程的思想，在前端模块化同样适用）

### 早期 JS 模块化方案

#### 普通函数

首先考虑到函数实现，因为 JS 中函数是有独立作用域的，并且函数中可以放任何代码，只需要在需要使用的地方调用即可，就比如下面代码：

```js
function fn1() {
  //...
}
function fn2() {
  //...
}
function fn3() {
  fn1();
  fn2();
}
```

可以看到这样做实现了代码分离及组织，看着挺清晰，其实是因为代码量小，如果函数过多，并且在多个文件中，还是无法保证它们不与其它模块发生命名冲突，而且模块成员之间看不出直接关系，还是会给后期的维护造成麻烦。

#### 命名空间

在上面普通函数的方式中，很多变量和函数会直接在全局作用域下面声明，很容易产生命名冲突，于是，命名空间模式（namespace）就被提出了。
因为对象可以有属性，而它的属性既可以是数据，也可以是方法，刚好能够很好地满足需求，而且对象的属性通过对象名字来访问，相当于设定了一个命名空间。
我们来看看把模块写成一个对象，所有的模块成员都放到这个对象里面是怎么样的：

```js
var myModule = {
  name: "isboyjc",
  getName: function () {
    console.log(this.name);
  },
};

// 使用
myModule.getName();
```

显然这是可行的，但是很快我们又发现了其缺点，对象内部属性全部会暴露出来，内部状态可以被外部更改，如下：

```js
myModule.name = "哈哈哈";
myModule.getName(); // 哈哈哈
```

#### 立即执行函数（IIFE）

尽管命名空间模式一定程度上解决了全局命名空间上的变量污染问题，但是它没办法解决代码和数据隔离的问题，大概在 2003 年，立即执行函数简称 IIFE 出现了 ，它其实是利用函数闭包的特性来实现私有数据和共享方法，如下：

```js
var myModule = (function () {
  var name = "isboyjc";

  function getName() {
    console.log(name);
  }

  return { getName };
})();
```

这样我们就可以通过 myModule.getName() 来获取 name，并且实现 name 属性的私有化，即外部调用不到：

```js
myModule.getName(); // isboyjc
myModule.name; // undefined
```

那假如我们这个模块需要依赖其他模块呢？这时候就用到了引入依赖，即函数传参：

```js
// otherModule.js 模块文件
var otherModule = (function () {
  return {
    a: 1,
    b: 2,
  };
})();

// myModule.js 模块文件 - 依赖 otherModule 模块
var myModule = (function (other) {
  var name = "isboyjc";

  function getName() {
    console.log(name);
    console.log(other.a, other.b);
  }

  return { getName };
})(otherModule);
```

通过这种传参的形式，我们就可以在 myModule 模块中使用其他模块，从而解决了很多问题，这也是**现代模块化规范的思想来源**。

### 现代模块化方案

#### CommonJS

```js
// a.js
module.exports = {};
// b.js
require("./a.js");
```

CommonJS 是服务器端模块的规范，Node.js 就是采用了这个规范。但目前也可用于浏览器端，需要使用 Browserify 进行提前编译打包。
CommonJS 模块化的引入方式使用 require ； 暴露的方式使用 module.exports 或 exports。

- 所有代码都运行在模块作用域，不会污染全局作用域
- **加载缓存**模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载,就直接读取缓存结果，要想让模块再次运行，必须清除缓存
- **同步加载**模块加载的顺序，按照其在代码中出现的顺序

> CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，所以同步加载没有问题。但是如果是浏览器端，同步加载很容易阻塞，这时候 AMD 规范就出来了。AMD 规范则是非同步加载模块，允许指定回调函数。故浏览器端一般会使用 AMD 规范。

#### AMD

AMD（异步模块定义）是专门为浏览器环境设计的，它定义了一套异步加载标准来解决同步的问题
语法如下：

```js
define(id?: String, dependencies?: String[], factory: Function|Object)
```

- id 即模块的名字，字符串，可选
- dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 ["require", "exports", "module"]
- factory 包裹了模块的具体实现，可为函数或对象，如果是函数，返回值就是模块的输出接口或者值

```js
// 定义依赖 myModule，该模块依赖 JQ 模块
define("myModule", ["jquery"], function ($) {
  // $ 是 jquery 模块的输出
  $("body").text("isboyjc");
});

// 引入依赖
require(["myModule"], function (myModule) {
  // todo...
});
```

##### 手写 requireJs （简化版）

```js
(function () {
  // 缓存
  const cache = {};
  let moudle = null;
  const tasks = [];

  // 创建script标签，用来加载文件模块
  const createNode = function (depend) {
    let script = document.createElement("script");
    script.src = `./${depend}.js`;
    // 嵌入自定义 data-moduleName 属性，后可由dataset获取
    script.setAttribute("data-moduleName", depend);
    let fs = document.getElementsByTagName("script")[0];
    fs.parentNode.insertBefore(script, fs);
    return script;
  };

  // 校验所有依赖是否都已经解析完成
  const hasAlldependencies = function (dependencies) {
    let hasValue = true;
    dependencies.forEach((depd) => {
      if (!cache.hasOwnProperty(depd)) {
        hasValue = false;
      }
    });
    return hasValue;
  };

  // 递归执行callback
  const implementCallback = function (callbacks) {
    if (callbacks.length) {
      callbacks.forEach((callback, index) => {
        // 所有依赖解析都已完成
        if (hasAlldependencies(callback.dependencies)) {
          const returnValue = callback.callback(
            ...callback.dependencies.map((it) => cache[it])
          );
          if (callback.name) {
            cache[callback.name] = returnValue;
          }
          tasks.splice(index, 1);
          implementCallback(tasks);
        }
      });
    }
  };

  // 根据依赖项加载js文件
  const require = function (dependencies, callback) {
    if (!dependencies.length) {
      // 此文件没有依赖项
      moudle = {
        value: callback(),
      };
    } else {
      //此文件有依赖项
      moudle = {
        dependencies,
        callback,
      };
      tasks.push(moudle);
      dependencies.forEach(function (item) {
        if (!cache[item]) {
          // script表亲加载文件结束
          createNode(item).onload = function () {
            // 获取嵌入属性值，即module名
            let modulename = this.dataset.modulename;
            console.log(moudle);
            // 校验module中是否存在value属性
            if (moudle.hasOwnProperty("value")) {
              // 存在，将其module value（模块返回值｜导出值）存入缓存
              cache[modulename] = moudle.value;
            } else {
              // 不存在
              moudle.name = modulename;
              if (hasAlldependencies(moudle.dependencies)) {
                // 所有依赖解析都已完成，执行回调，抛出依赖返回（导出）值
                cache[modulename] = callback(
                  ...moudle.dependencies.map((v) => cache[v])
                );
              }
            }
            // 递归执行callback
            implementCallback(tasks);
          };
        }
      });
    }
  };
  window.require = require;
  window.define = require;
})(window);
```

#### CMD

CMD 是根据 CommonJS 和 AMD 基础上提出的。
CMD(通用模块定义)和 AMD(异步模块定)是比较相似的。
RequireJS 遵循的是 AMD（异步模块定义）规范，SeaJS 遵循的是 CMD （通用模块定义）规范。

在 CMD 规范中，一个模块就是一个文件，define 是一个全局函数，用来定义模块。

- define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串。
- factory 为对象和字符串时，表示模块的接口就是该对象、字符串，如下：

```js
// factory 为JSON数据对象
define({ name: "isboyjc" });

// factory 为字符串模版
define("my name is {{name}}!!!");
```

factory 为函数时，表示是模块的构造方法，执行该构造方法，可以得到模块向外提供的接口，即 function(require, exports, module) ：

- require 是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口
- exports 是一个对象，用来向外提供模块接口
- module 是一个对象，上面存储了与当前模块相关联的一些属性和方法

factory 为函数时，如下：

```js
define(function (require, exports, module) {
  var a = require("./a");
  a.doSomething();

  // 依赖就近原则：依赖就近书写，什么时候用到什么时候引入
  var b = require("./b");
  b.doSomething();
});
```

再来看看更多用法：

```js
define(function (require, exports, module) {
  // 同步引入
  var a = require("./a");

  // 异步引入
  require.async("./b", function (b) {});

  // 条件引入
  if (status) {
    var c = requie("./c");
  }

  // 暴露模块
  exports.aaa = "hahaha";
});
```

##### CMD 对比 AMD

1. 第一个方面是在**模块定义时对依赖的处理不同**。

**AMD 推崇依赖前置**，在定义模块的时候就要声明其依赖的模块。

而 **CMD 推崇 就近依赖**，只有在用到 某个模块的时候再去 require。

2. 第二个方面是**依赖模块的执行时机**处理不同。

首先 AMD 和 CMD 对于 模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机.

**AMD 在 依赖模块加载完成后就直接执行依赖模块**，依赖模块的执行顺序和我们书写的顺序不一定一致。

**而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候 才执行对应的模块**，这样模块的执行顺序就和我们书写的顺序保持一致了。

#### UMD 规范

UMD（Universal Module Definition），即通用模块定义，从名字就可以看出来，这东西是做大一统的。
它随着大前端的趋势所诞生，**可以通过运行时或者编译时让同一个代码模块在使用 CommonJs、CMD 甚至是 AMD 的项目中运行，也就是说同一个 JavaScript 包运行在浏览器端、服务区端甚至是 APP 端都只需要遵守同一个写法就行了**，那它是怎样实现的呢？
**核心实现**
我们来看看这样一段代码

```js
((root, factory) => {
  if (typeof define === "function" && define.amd) {
    // AMD
    define(factory);
  } else if (typeof exports === "object") {
    // CommonJS
    module.exports = factory();
  } else if (typeof define === "function" && define.cmd) {
    // CMD
    define(function (require, exports, module) {
      module.exports = factory();
    });
  } else {
    // 都不是
    root.umdModule = factory();
  }
})(this, () => {
  console.log("我是UMD");
  // todo...
});
```

可以看到，define 是 AMD/CMD 语法，而 exports 只在 CommonJS 中存在，你会发现它在定义模块的时候会检测当前使用环境和模块的定义方式，如果匹配就使用其规范语法，全部不匹配则挂载再全局对象上，我们看到传入的是一个 this ，它在浏览器中指的就是 window ，在服务端环境中指的就是 global ，使用这样的方式将各种模块化定义都兼容。
其实社区形成的的规范还有很多，目的都是为了 JS 的模块化开发，只是我们上面说的这几个是最常用的。

截止到目前为止我们说的 CommonJS 、AMD 、 CMD 等都只是社区比较认可的统一模块化规范，但并不是官方（JS 语言层面）的，那接下来要说的这个就是 JS 的官方模块化规范了。

### 最后

其实说白了，对于 JS 模块化，上述这些方案都在解决几个同样的问题：

- 谜一样的全局变量污染
- 恼人的命名冲突
- 繁琐的文件依赖

不同的模块化手段都在致力于解决这些问题。前两个问题其实很好解决，使用闭包配合立即执行函数，高级一点使用沙箱编译，缓存输出等等。难点在于文件依赖关系梳理以及加载。CommonJS 在服务端使用 fs 模块同步读取文件，而在浏览器中，不管是 AMD 规范的 RequireJs 还是 CMD 规范的 SeaJs，其实都是使用动态创建 script 标签方式加载，在依赖加载完毕之后再执行，以此省去开发手动书写 script 标签还需关注加载顺序这一烦恼。
ESM 作为语言标准层面的模块化方案，不需要我们额外引入用于模块化的三方包，抛开兼容问题，绝对是最好的选择，也是未来趋势，这点在 Vite 上就足以证明。

### 五、 ES6 模块与 CommonJS 模块的差异

1. **CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。**

CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

2. **CommonJS 模块是运行时加载，ES6 模块是编译时输出接口**。

- 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。

- 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。

**CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成**。

> CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。这里值的拷贝是指浅拷贝

[前端模块化详解(完整版)](https://juejin.cn/post/6844903744518389768)
[从前端模块化编程切入想聊聊前端的未来](https://juejin.cn/post/6844903792987602958)
