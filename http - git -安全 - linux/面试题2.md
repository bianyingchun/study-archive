https://juejin.cn/post/6844904100035821575

## HTTP 报文结构是怎样的

header + body 的结构，具体而言:

起始行 + 头部 + 空行 + 实体

1. 起始行

- 请求报文 ： GET /home HTTP/1.1
  方法 + 路径 + http 版本。

- 响应报文，HTTP/1.1 200 OK 版本 + 状态码 + 原因
  响应报文的起始行也叫做状态行。由 http 版本、状态码和原因三部分组成。

2. 头部

3. 空行
   用来区分 起始行 和 实体
4. 实体
   就是具体的数据了，也就是 body 部分。请求报文对应请求体, 响应报文对应响应体

## http 缺点

1. 明文传输
   即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。
   这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI 陷阱就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。
2. 队头堵塞
   HTTP/1.1 默认使用了**持久连接**keep-alive，多个请求可以复用**同一个 TCP 连接**，但是在 同一个 TCP 连接里面，数据请求的通信次序 是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话， 就会造成许多请求排队等待的情况，这种情况被称为“队头堵塞”。

3. 无状态
   在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。

但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。

## http 长连接和 websocket 长连接的区别

1. HTTP1.1 通过使用 Connection:keep-alive 进行长连接，HTTP 1.1 默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是**对每个请求仍然要单独发 header，Keep-Alive 不会永久保持连接，它有一个保持时间**，可以在不同的服务器软件（如 Apache）中设定这个时间。这种长连接是一种“伪链接”

2. websocket 的长连接，是一个真的全双工。长连接第一次 tcp 链路建立之后，后续数据可以双方都进行发送，不需要发送请求头。

3. keep-alive 双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。

## http 和 https 的区别及优缺点？

- http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。
- http 协议的默认端口为 80，https 的默认端口为 443。
- http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。
- https 缓存不如 http 高效，会增加数据开销。
- Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。
- SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。

## TCP/IP / 如何保证数据包传输的有序可靠？

- 数据分块：应用数据被分割成 TCP 认为最适合发送的数据块。
- 序列号：TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
- 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
- 重复丢弃：TCP 的接收端会丢弃重复的数据。
- 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
- 拥塞控制： 当网络拥塞时，减少数据的发送。
- 停止等待协议 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

## TCP 和 UDP 的区别

TCP 是面向连接的，UDP 是无连接的
TCP 是可靠的，UDP 是不可靠的
TCP 是面向字节流的，UDP 是面向数据报文的
TCP 只支持点对点通信，UDP 支持一对一，一对多，多对多
TCP 报文首部 20 个字节，UDP 首部 8 个字节
TCP 有拥塞控制机制，UDP 没有
TCP 协议下双方发送接受缓冲区都有，UDP 并无实际意义上的发送缓冲区，但是存在接受缓冲区

## post 和 get 请求的区别

- 应用场景： GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。

- 是否缓存： 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。

- 发送的报文格式： Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。

- 安全性： Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。

- 请求长度： 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。

- 参数类型： post 的参数传递支持更多的数据类型。
- 幂等性 ： GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)

## http 特点

HTTP 的特点概括如下:

**灵活可扩展**，主要体现在两个方面。

- 一个是**语义上的自由**，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。
- 另一个是**传输形式的多样性**，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。

- **可靠传输**。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。

- **请求-应答**。也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。

- **无状态**。这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息

## Accept

- 压缩方式
  // 发送端
  Content-Encoding: gzip, deflate, br
  // 接收端
  Accept-Encoding: gzip

- 支持语言
  // 发送端
  Content-Language: zh-CN, zh, en
  // 接收端
  Accept-Language: zh-CN, zh, en

- 数据格式
  // 发送端 Content-Type 代表发送端（客户端|服务器）发送的实体数据的数据类型。
  Content-Type ：
  // 接受端 Accept 代表发送端（客户端）希望接受的数据类型。
  Accept：

  这两个字段的取值可以分为下面几类:

  text： text/html, text/plain, text/css 等
  image: image/gif, image/jpeg, image/png 等
  audio/video: audio/mpeg, video/mp4 等
  application: application/json, application/javascript, application/pdf, application/octet-stream

- 字符集
  // 发送端,
  Content-Type: text/html; charset=utf-8
  // 接收端
  Accept-Charset: charset=utf-8

## http 如何传输定长和不定长数据

### 定长数据

content-length 指定数据长度

```js
const http = require("http");

const server = http.createServer((req, res) => {
  if (req.url === "/") {
    res.setHeader("Content-Type", "text/plain");
    //  指定数据长度
    res.setHeader("Content-Length", 10);
    res.write("helloworld");
    res.end();
  }
});

server.listen(8081, () => {
  console.log("成功启动");
});
```

### 不定长数据 \*\*

Transfer-Encoding: chunked

表示分块传输数据，设置这个字段后会自动产生两个效果:

- Content-Length 字段会被忽略
- 基于长连接持续推送动态内容

```js
const server = http.createServer();

server.on("request", (req, res) => {
  if (req.url === "/") {
    res.setHeader("Content-Type", "text/html; charset=utf8");
    res.setHeader("Content-Length", 10);
    res.setHeader("Transfer-Encoding", "chunked");
    res.write("<p>来啦</p>");
    setTimeout(() => {
      res.write("第一次传输<br/>");
    }, 1000);
    setTimeout(() => {
      res.write("第二次传输");
      res.end();
    }, 2000);
  }
});

server.listen(8009, () => {
  console.log("成功启动");
});
```

## 状态码 206

https://blog.csdn.net/LU_ZHAO/article/details/104744996
HTTP/1.1 206 状态码表示的是:"客户端通过发送范围请求头 Range 抓取到了资源的部分数据"，一般用来

- 解决大文件下载问题
- 解决 CDN 和原始 HTTP 服务器问题
- 使用工具例如 lftp,wget,telnet 测试断点续传

## HTTP 如何处理大文件的传输

### 单段数据

对于单段数据的请求，返回的响应如下:

```js
HTTP/1.1 206 Partial Content
Content-Length: 10
Accept-Ranges: bytes
Content-Range: bytes 0-9/100

i am xxxxx

```

值得注意的是**Content-Range**字段，0-9 表示请求的返回，100 表示资源的总大小，很好理解。

### 多段数据

接下来我们看看多段请求的情况。得到的响应会是下面这个形式:

```js
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000010101
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes


--00000010101
Content-Type: text/plain
Content-Range: bytes 0-9/96

i am xxxxx
--00000010101
Content-Type: text/plain
Content-Range: bytes 20-29/96

eex jspy e
--00000010101--

```

这个时候出现了一个非常关键的字段**Content-Type: multipart/byteranges;boundary=00000010101**，它代表了信息量是这样的:

请求一定是多段数据请求
响应体中的分隔符是 00000010101

因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上--表示结束。
以上就是 http 针对大文件传输所采用的手段。

## HTTP 中如何处理表单数据的提交

在 http 中，有两种主要的表单提交的方式，体现在两种不同的 Content-Type 取值:

application/x-www-form-urlencoded
multipart/form-data

### 1. application/x-www-form-urlencoded

对于 application/x-www-form-urlencoded 格式的表单内容，有以下特点:

- 其中的数据会被编码成以&分隔的键值对
- 字符以 URL 编码方式编码。

### 2. multipart/form-data

对于 multipart/form-data 而言:

请求头中的**Content-Type 字段会包含 boundary，且 boundary 的值有浏览器默认指定**。例: Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe。
数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如 Content-Type，在最后的分隔符会加上--表示结束。

相应的请求体是下面这样:

```js

Content-Disposition: form-data;name="data1";
Content-Type: text/plain
data1
----WebkitFormBoundaryRRJKeWfHPGrS4LKe
Content-Disposition: form-data;name="data2";
Content-Type: text/plain
data2
----WebkitFormBoundaryRRJKeWfHPGrS4LKe--
```

## HTTP1.1 如何解决 HTTP 的队头阻塞问题？

https://blog.csdn.net/qq_37886086/article/details/109714173

### 什么是 HTTP 队头阻塞？

从前面的小节可以知道，HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的 HTTP 队头阻塞问题。

### 并发连接

**对于一个域名允许分配多个长连接，那么相当于增加了任务队列**，不至于一个队伍的任务阻塞其它所有任务。在 RFC2616 规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。
但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。

### 域名分片

一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。
比如 content1.sanyuan.com 、content2.sanyuan.com。
这样一个 sanyuan.com 域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

## Cookie

### Cookie 简介

前面说到了 HTTP 是一个无状态的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。但有时候需要保存一些状态，怎么办呢？
HTTP 为此引入了 Cookie。Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在 chrome 开发者面板的 Application 这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的 Set-Cookie 字段来对客户端写入 Cookie。举例如下:

// 请求头
Cookie: a=xxx;b=xxx
// 响应头
Set-Cookie: a=xxx
set-Cookie: b=xxx

### Cookie 属性

#### 生存周期 Expires 和 Max-Age

Cookie 的有效期可以通过 Expires 和 Max-Age 两个属性来设置。
若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。

#### 作用域 Domain 和 path

, 给 Cookie 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说，/表示域名下的任意路径都允许使用 Cookie。

#### cookie 的域名

Cookie 是不可以跨域名的，隐私安全机制禁止网站非法获取其他网站的 Cookie。
正常情况下，同一个以及域名下的两个二级域名也不能交互 Cookie，比如 test1.jianshu.com 与 test2.jianshu.com,因为二者简书的域名不完全相同，如果想要 jianshu.com 名下的二级域名都可以使用该 Cookie，需要**设置 Cookie 的 domain 参数为 jianshu.com**，这样使用 test1.jianshu.com 和 test2.jianshu.com 就能访问同一个域名了。

#### 安全相关 Secure

1. 如果带上 Secure，说明只能通过 HTTPS 传输 cookie。
2. **如果 cookie 字段带上 HttpOnly，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。**

3. 相应的，**对于 CSRF 攻击的预防，也有 SameSite 属性**。
   SameSite 可以设置为三个值，Strict、Lax 和 None。

- 在 Strict 模式下，浏览器完全禁止第三方请求携带 Cookie。比如请求 sanyuan.com 网站只能在 sanyuan.com 域名当中请求才能携带 Cookie，在其他网站请求都不能。
- 在 Lax 模式，就宽松一点了，但是只能在 get 方法提交表单况或者 a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。
- 在 None 模式下，也就是默认模式，请求会自动携带上 Cookie。

### Cookie 的缺点

- 容量缺陷。
  Cookie 的体积上限只有 4KB，只能用来存储少量的信息。

- 性能缺陷。
  Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过 Domain 和 Path 指定作用域来解决。

- 安全缺陷。
  由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在 HttpOnly 为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

## http 和 tcp 区别

**TCP 是传输层协议，所要规定的是数据应该怎么传输才能稳定且高效的传递与计算机之间。**。握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。

**HTTP 超文本传送协议(Hypertext Transfer Protocol )是应用层协议，定义的是传输数据的内容的规范**。

HTTP 协议中的数据是利用 TCP 协议传输的，特点是客户端发送的每次请求都需要服务器回送响应，它是 TCP 协议族中的一种，默认使用 TCP 80 端口。

好比网络是路，TCP 是跑在路上的车，HTTP 是车上的人。每个网站内容不一样，就像车上的每个人有不同的故事一样。

## HTTP 中的 Keep-Alive 有了解过吗？

Keep-Alive 是 HTTP 的一个头部字段 Connection 中的一个值，它是保证我们的 HTTP 请求能建立一个**持久连接。也就是说建立一次 TCP 连接即可进行多次请求和响应的交互**。它的特点就是只要有一方没有明确的提出断开连接，则保持 TCP 连接状态，减少了 TCP 连接和断开造成的额外开销。
另外，在 HTTP/1.1 中所有的连接默认都是持久连接的，但是 HTTP/1.0 并未标准化。

## 你们的 token 一般是存放在哪里的

Token 其实就是访问资源的凭证。
一般是用户通过用户名和密码登录成功之后，服务器将登陆凭证做数字签名，加密之后得到的字符串作为 token。
它在用户登录成功之后会返回给客户端，客户端主要有这么几种存储方式：

存储在 localStorage 中，每次调用接口的时候都把它当成一个字段传给后台
存储在 cookie 中，让它自动发送，不过缺点就是不能跨域
拿到之后存储在 localStorage 中，每次调用接口的时候放在 HTTP 请求头的 Authorization 字段里

## HTTP2 和 HTTP1 有什么区别

### 相对于 HTTP1.0，HTTP1.1 的优化：

1. HTTP/1.1 还引入了客户端 Cookie 机制和安全机制
   带宽优化及网络连接的使用
2. 对动态生成的内容提供了完美支持
   在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如 Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。

HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。

3. 请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。
4. 长连接： HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。
5. 不成熟的管线化
   持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。

HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。

### 相对于 HTTP1.1，HTTP2 的优化：

HTTP2 支持二进制传送（实现方便且健壮），HTTP1.x 是字符串传送
HTTP2 支持多路复用
HTTP2 采用 HPACK 压缩算法压缩头部，减小了传输的体积
HTTP2 支持服务端推送
