### 输入 url 到看见页面，发生了什么

1. 首先，在浏览器地址栏中输入 url

2. 浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。

3. 在发送 http 请求前，需要域名解析(DNS 解析)，解析获取相应的 IP 地址。

4. 浏览器向服务器发起 tcp 连接，与浏览器建立 tcp 三次握手。

5. 握手成功后，浏览器向服务器发送 http 请求，请求数据包。

6. 服务器处理收到的请求，将数据返回至浏览器

7. 浏览器收到 HTTP 响应
8. 关闭 TCP 连接：通过四次挥手释放 TCP 连接
9. 浏览器渲染：客户端（浏览器）解析 HTML 内容并渲染出来，浏览器接收到数据包后的解析流程为：

   1. 构建 DOM 树：词法分析然后解析成 DOM 树（dom tree），是由 dom 元素及属性节点组成，树的根是 document 对象
   2. 构建 CSS 规则树：生成 CSS 规则树（CSS Rule Tree）
   3. 构建 render 树：Web 浏览器将 DOM 和 CSSOM 结合，并构建出渲染树（render tree）
   4. 布局（Layout）：计算出每个节点在屏幕中的位置
   5. 绘制（Painting）：即遍历 render 树，并使用 UI 后端层绘制每个节点。

10. JS 引擎解析过程：调用 JS 引擎执行 JS 代码（JS 的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）

    1. 创建 window 对象：window 对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于 window 的属性和方法，而 DOM Tree 也会映射在 window 的 doucment 对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。
    2. 加载文件：完成 js 引擎分析它的语法与词法是否合法，如果合法进入预编译
    3. 预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为 window 的属性加入到 window 对象中，并给变量赋值为'undefined'；寻找全局函数声明，把它作为 window 的方法加入到 window 对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在 ES6 中已经解决了，函数提升还存在。
    4. 解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在 ES5 非严格模式下这个变量会成为 window 的一个属性，也就是成为全局变量。string、int 这样的值就是直接把值放在变量的存储空间里，object 对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS 作用域其实就是这样的执行流机制实现的。

11. ajax 查询

### chrome 的几个版本

1. Canary 金丝雀版本
2. 开发者 dev 版本
3. 稳定版 stable
4. 测试版 beta

### 说一下 Http 缓存策略，有什么区别，分别解决了什么问题 \*\*\*

浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起 HTTP 请求，将缓存过程划分为两个部分：强制缓存和协商缓存，强缓存优先于协商缓存。

1. 强缓存
   不会向服务器发送请求,直接从缓存中读取资源
   - expires(http/1.0,时间格式 GMT)
     该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。绝对时间。
   - cache-control(http/1.1,单位 秒)
     这两者的区别就是前者是绝对时间，而后者是相对时间。该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。
     - max-age(表示缓存内容在 xx 秒后消失)
     - no-cache(不使用强缓存，需要与服务器验证缓存是否新鲜)
     - no-store(真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。)
     - public(所有内容都将被缓存包括客户端和代理服务器， 如 cdn)
     - private(所有内容只有客户端可以缓存)
     - must-revalidate:超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。
     - s-maxage(只用于共享缓存和 max-age 效果一样,只是 max-age 用于普通缓存)
2. 协商缓存
   当协商缓存生效时,返回 304 和 Not Modified。它指的是强制缓存失效后,浏览器携带缓存标示向服务器发起请求,由服务器决定是否需要使用缓存。
   - Last-Modified 和 If-Modified-Since
     1. 服务器通过 Last-Modified 字段告知客户端，**资源最后一次被修改的时间**,浏览器将这个值和内容一起记录在缓存数据库中。
     2. 浏览器下次请求时，检测是否有 Last-Modified 字段,如果存在,在请求头中将上次的 Last-Modified 的值写入到请求头的 If-Modified-Since 字段.
     3. 服务器会将 If-Modified-Since 的值与 Last-Modified 字段进行对比, 如果没有变化则返回 304 直接从缓存中读取，否则返回新资源。
   - ETag 和 If-None-Match
     Etag 存储的是**文件的特殊标识**(一般都是 hash 生成的)，服务器存储着文件的 Etag 字段。之后的流程和 Last-Modified 一致，只是 Last-Modified 字段和它所表示的更新时间改变成了 Etag 字段和它所表示的文件 hash。
     1. Etag 是上一次加载资源时,服务器返回的。它的作用是唯一用来标示资源是否有变化。
     2. 浏览器下次请求时将 ETag 值传入 If-None-Match,服务端匹配传入的值与上次是否一致，如果一致返回 304 否则返回新资源和新的 ETag
        **Etag 的优先级高于 Last-Modified**

### 为何既有 last-modified 又有 Etag

考虑以下情况：

1. 一些文件也许会周期性的更改,但是他的内容并不改变(仅仅改变的修改时间),这个时候,我们并不希望客户端认为这个文件被修改了,而重新 get
2. 某些文件修改非常频繁,比如在秒以下的时间内进行修改(比方说 1s 内修改了 N 次),If-Modified-Since 能检查到的粒度时 s 级的,这种修改无法判断(或者说 UNIX 记录 MTIME 只能精确到秒)
3. 某些服务器不能精确得到的文件的最后修改时间

### encoding 头部有哪些编码方式

1. Unicode
2. utf-8
3. ascii
4. gbk

### utf-8 和 unicode 的区别

Unicode 是「字符集」
Unicode 本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。 编号怎么对应到二进制表示呢？有多种方案：主要有 UTF-8，UTF-16，UTF-32。

UTF-8 是「编码规则」
UTF-8 就是使用变长字节表示,顾名思义，就是使用的字节数可变，这个变化是根据 Unicode 编号的大小有关，编号小的使用的字节就少，编号大的使用的字节就多。使用的字节个数从 1 到 4 个不等。

### http 是如何复用的

从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加上 Connection、Keep-Alive 字段.多个请求可以复用**同一个 TCP 连接**

### http2.0 多路复用

[参考链接](https://blog.csdn.net/weixin_33976072/article/details/88961413)
在 HTTP1.1 的协议中，我们传输的 request 和 response 都是**基本于文本**的，这样就会引发一个问题：所有的数据必须按**顺序传输**，比如需要传输：hello world，只能从 h 到 d 一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在 HTTP1.1 是不能实现的。

HTTP/2 引入**二进制数据帧和流**的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，**就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况**。同样是因为有了序列，服务器就可以**并行的传输数据**，这就是流所做的事情。

### http2 的特性

1. 二进制分帧传输
   在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是 二进制。HTTP/2 则是一个**彻底的二进制协议**，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。

2. 多路复用
   HTTP/2 **仍然复用 TCP 连接**，但是在一个连接里， 客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送， 这样就避免了"队头堵塞"的问题。

3. 数据流
   HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。**HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流**。

4. 首部压缩
   HTTP/2 实现了头信息压缩，\*\*由于 HTTP 1.1 协议不带有状态，每次请求都必须 附上所有信息。所以，请求的很多字段都是重复的，这会浪费很多带宽，也影响 速度。
   HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，**头信息使用 gzip 或 compress 压缩后再发送**；另一方面， **客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。**

5. 服务器推送
   **HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。**使用服务器推送，提前给客户端推送必要的资源 ，这样就可以相对减少一些延迟 时间。这里需要注意的是 http2 下服务器主动推送的是**静态资源**，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

### tcp 三次握手

[tcp 三次握手](./tcp三次握手.md)

### tcp 和 udp 的区别

### 前端安全问题，如何解决

### csRf,xss 的概念，攻击原理，防御措施

### http 的缺点

1. 通信使用明文（不加密），内容可能会被窃听‘
2. 不验证通信方身份，可能遭遇伪装
3. 无法验证报文完整性，可能遭遇篡改
4. 队头堵塞
   HTTP/1.1 默认使用了**持久连接**keep-alive，多个请求可以复用**同一个 TCP 连接**，但是在 同一个 TCP 连接里面，数据请求的通信次序 是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话， 就会造成许多请求排队等待的情况，这种情况被称为“队头堵塞”。

### http 中间人劫持了解吗?如何解决呢?
假设有一个攻击者处于“浏览器”和“网站服务器”的通讯线路之间（比如公共WIFI），它的攻击过程如下：

服务器向客户端发送公钥。
攻击者截获公钥，保留在自己手上。
然后攻击者自己生成一个【伪造的】公钥，发给客户端。
客户端收到伪造的公钥后，生成加密hash值发给服务器。
攻击者获得加密hash值，用自己的私钥解密获得真秘钥。
同时生成假的加密hash值，发给服务器。
服务器用私钥解密获得假秘钥。
上面问题的根源是因为“缺乏身份认证机制”，浏览器无法鉴别自己收到的密钥是不是真的来自于网站服务器。


### 为什么 https 可以做到避免中间人劫持?
如何解决 SSL 的身份认证问题——CA 的引入：
由于双方通常都是互不相识的，显然不可能采用第一种方式，而只能采用第二种公证人方式。
那么，谁来充当这个公证人？这时候，CA 就华丽地登场啦。
浏览器验证网站发过来的证书。如果发现其中有诈，浏览器会提示“CA 证书安全警告”。
由于有了这一步，就大大降低了（注意：是“大大降低”，而不是“彻底消除”）前面提到的“中间人攻击”的风险。
为啥浏览器能发现 CA 证书是否有问题？
因为正经的 CA 证书，都是来自某个权威的 CA。如果某个 CA 足够权威，那么主流的操作系统（或浏览器）会内置该 CA 的“根证书”。
（比如 Windows 中就内置了几十个权威 CA 的根证书）
因此，浏览器就可以利用系统内置的根证书，来判断网站发过来的 CA 证书是不是某个 CA 颁发的。
### 加密套件指的是?(举例了 AES)

### 说一下 http 和 https 的区别， https 为什么更安全

### 数字签名的原理

### 说下 tls 握手

### https 的 tls 了解吗

### 301 ，302 的 https 被劫持了怎么办

### 介绍 ssl 和 TLS

### 加密握手的过程

### http 常见请求头及其作用

### http 请求组成

1. 请求行
   包含请求的方法, url， http 协议版本
2. 首部(key-value)
   user-agent
   accpet
   host
3. 实体
   post 请求中 key-value
4. 空行
   用来划分首部和实体

### http 响应报文组成

1. 状态行，
   状态码，原因短语，http 版本
2. 首部行
   服务器类型，日期，长度，内容类型
3. 实体主体。
   服务返回的数据

### 各区间状态码

2xx:请求成功
3xx:重定向
4xx:客户端请求错误
5xx 服务器错误

常见：
200-请求成功、
202-服务器端已经收到请求消息，但是尚未进行处理
301-永久重定向、
302-临时重定向、
304-所请求的资源未修改、
400-客户端请求的语法错误、
404-请求的资源不存在
500-服务器内部错误

### restful APi 分别使用拿些 http 副词

GET 查
POST 增
PUT 改
DELETE 删

### 网络的五层模型

物理层 数据链路层 网络层 传输层 应用层

### DNS 的解析过程

DNS 的查询过程一般为，

1. 我们首先将 DNS 请求发送到本地 DNS 服务器，由 本地 DNS 服务器来代为请求。
2. 从"根域名服务器"查到"顶级域名服务器"的 NS 记录和 A 记录（ IP 地 址）。
3. 从"顶级域名服务器"查到"次级域名服务器"的 NS 记录和 A 记录（ IP 地址）。
4. 从"次级域名服务器"查出"主机名"的 IP 地址。

比如我们如果想要查询 www.baidu.com 的 IP 地址，

1.  我们首先会将请求发送到 本地的 DNS 服务器中，本地 DNS 服务器会判断是否存在该域名的缓存，
2.  如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责.com 的顶级域名服务器的 IP 地址的列表。
3.  然后本地 DNS 服务器再向其中一个负责.com 的顶级域名服务器发送一个请求，负责.com 的顶级域名服务器返回负责.baidu 的权威域名服务器的 IP 地址列表。
4.  然后本地 DNS 服务器再向其中一个权威域名服 务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表

### 浏览器有哪些进程，渲染进程都有哪些线程

##### 浏览器有哪些进程

1. 浏览器主进程
2. 渲染进程
3. GPU 进程
4. 网络进程
5. 其他插件进程

#### 渲染进程都有哪些线程

1. GUI 渲染线程（与 js 线程互斥，js 引擎线程优先级会高于 GUI 渲染线程）
2. js 引擎线程
3. 事件触发线程
4. 定时处理线程
5. 异步请求 http 线程

### cdn 是什么，原理， 为什么要使用 cdn

内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。

如果用户访问的网站部署了 CDN，过程是这样的：

1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。
2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。
3. 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。
4. 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。
5. SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。
6. 浏览器再根据 SLB 发回的地址重定向到缓存服务器。
7. 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。

### pwa 是什么，对 pwa 有什么了解

### 项目中常用的 linux 命令

### 业务中打包怎么做的

### 如何查询某个进程占用的端口号(linux 中)

netstat -tunlp|grep 80 或 lsof -i:80

### git reset 和 git rebase 了解吗

### 说下上线部署流程中常用的 linux 命令

### 