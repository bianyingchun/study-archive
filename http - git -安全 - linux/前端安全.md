### XSS(跨站脚本攻击)

Cross-Site Scripting（跨站脚本攻击）简称 XSS

攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

#### 用户是通过哪种方法“注入”恶意脚本的呢？

不仅仅是业务上的“用户的 UGC 内容”可以进行注入，包括 URL 上的参数等都可以是攻击的来源。在处理输入时，以下内容都不可信：

1. 来自用户的 UGC 信息
2. 来自第三方的链接
3. URL 参数
4. POST 参数
5. Referer （可能来自不可信的来源）
6. Cookie （可能来自其他子域注入）

### 分类

|  类型  |         存储区          |     插入点      |
| :----: | :---------------------: | :-------------: |
| 存储型 |       后端数据库        |      HTML       |
| 反射型 |           URL           |      HTML       |
| DOM 型 | 后端数据库/前端存储/URL | 前端 JavaScript |

- 存储区：恶意代码存放的位置。
- 插入点：由谁取得恶意代码，并插入到网页上。

#### 1. 存储型：

##### 存储在后端数据库， 插入点是 HTML

- 场景：见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。
- 攻击步骤：
  - 攻击者将恶意代码提交到目标网站的数据库中
  - 用户打开目标网站时，服务端将恶意代码从数据库中取出来，拼接在 HTML 中返回给浏览器
  - 用户浏览器在收到响应后解析执行，混在其中的恶意代码也同时被执行
  - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

#### 2. 反射型：经过后端，不经过数据库

- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。
- 攻击步骤：

  - **攻击者构造出特殊的 URL，其中包含恶意代码。**

  - **用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出**，拼接在 HTML 中返回给浏览器。

  - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。

  - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 XSS 跟存储型 XSS 的区别是：

- 存储型 XSS 的恶意代码存在**数据库**里
- 反射型 XSS 的恶意代码存在**URL**里。

#### 3. DOM 型

- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。
- 攻击步骤:
  - 攻击者构造出特殊的 URL，其中包含恶意代码。
  - 用户打开带有恶意代码的 URL。
  - 用户浏览器接收到响应后解析执行，**前端 JavaScript 取出 URL 中的恶意代码并执行。**
  - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别：

- DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，
- 而其他两种 XSS 都属于服务端的安全漏洞。

#### 预防方案

防止攻击者提交恶意代码，防止浏览器执行恶意代码

##### 1. 预防存储型和反射型 XSS 攻击

- 改成纯前端渲染，把代码和数据分隔开。
  纯前端渲染的过程：

  - 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
  - 然后浏览器执行 HTML 中的 JavaScript。
  - JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。

- 对 HTML 做充分转义
  如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。在不同的上下文里要使用相应的转义规则。

##### 2. 预防 DOM 型 XSS 攻击

DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。

- 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。

- 如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。

- DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，\<a> 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。

##### 3. Content Security Policy

严格的 CSP 在 XSS 的防范中可以起到以下的作用：

- 禁止加载外域代码，防止复杂的攻击逻辑。
- 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
- 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。
- 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。
- 合理使用上报可以及时发现 XSS，利于尽快修复问题。

##### 4. 输入内容长度控制

对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。

##### 5. 其他安全措施

- HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，
  攻击者完成 XSS 注入后也无法窃取此 Cookie。
- 验证码：防止脚本冒充用户提交危险操作。

---

### CSRF：跨站请求伪造

CSRF（Cross-site request forgery）跨站请求伪造

攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

一个典型的 CSRF 攻击有着如下的流程：

1. 受害者登录 a.com，并保留了登录凭证（Cookie）。
2. 攻击者引诱受害者访问了 b.com。
3. b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie。
4. a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
5. a.com 以受害者的名义执行了 act=xx。
6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。

#### 攻击类型

1. GET 类型的 CSRF
   GET 类型的 CSRF 利用非常简单，只需要一个 HTTP 请求，一般会这样利用：

```html
<img src="http://bank.example/withdraw?amount=10000&for=hacker" />
```

在受害者访问含有这个 img 的页面后，浏览器会自动向http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。

2. POST 类型的 CSRF
   这种类型的 CSRF 利用起来通常使用的是一个自动提交的表单

3. 链接类型的 CSRF
   这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击

#### 防护策略

CSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提升安全性。

上文中讲了 CSRF 的两个特点：

- CSRF（通常）发生在第三方域名。
- CSRF 攻击者不能获取到 Cookie 等信息，只是使用。

针对这两点，我们可以专门制定防护策略，如下：

1. 阻止不明外域的访问

- 同源检测
  - 使用 Referer Header 和 Origin Header 确定来源域名
  - 阻止外域请求
- Samesite Cookie

2. 提交时要求附加本域才能获取的信息

- CSRF Token
  CSRF 攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个 CSRF 攻击者无法获取到的 Token。服务器通过校验请求是否携带正确的 Token，来把正常的请求和攻击的请求区分开，也可以防范 CSRF 的攻击。
- 双重 Cookie 验证
  利用 CSRF 攻击不能获取到用户 Cookie 的特点，我们可以要求 Ajax 和表单请求携带一个 Cookie 中的值。但是安全性不如 Token，可能会存在漏洞被 XSS 攻击

### 参考文章

[前端安全系列（一）：如何防止 XSS 攻击？](https://segmentfault.com/a/1190000016551188)
[前端安全系列之二：如何防止 CSRF 攻击？](https://segmentfault.com/a/1190000016659945)
