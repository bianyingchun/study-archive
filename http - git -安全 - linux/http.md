1. 对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。

2. 非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中.以及可以使用哪些 HTTP 动词和头信息字段，如果收到肯定回复后才会发起请求

### 301 302 的区别和使用场景

1. 301 永久重定向
2. 302 临时重定向

常用应用场景

1. 想换个域名，旧的域名不用啦，这样用户访问旧域名时用 301 就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。
2. 登录后重定向到指定的页面，这种场景比较常见就是登录成功跳转到具体的系统页面。
3. 有时候需要自动刷新页面，比如 5 秒后回到订单详细页面之类。
4. 有时系统进行升级或者切换某些功能时，需要临时更换地址。
5. 像微博之类的使用短域名，用户浏览后需要重定向到真实的地址之类。

#### 301 与 302 在选择上注意的问题

**网址劫持**302 引起搜索引擎的排名，而且 302 重定向很容易被搜索引擎误认为是利用多个域名指向同一网站，那么你的网站就会被封掉。是说除非真是临时重定向使用 302，其他的情况最好还是使用 301 吧

#### 301、302、307、308 的区别

1. 301、308 是永久重定向；302、303、307 是临时重定向。
2. 301、302 是 http 1.0 的内容，303、307、308 是 http1.1 的内容。
3. 308 与 301 定义一致，唯一的区别在于，308 状态码不允许浏览器将原本为 POST 的请求重顶到 GET 请求上。
4. 302 允许各种各样的重定向，一般都实现为 GET 到 GET 重定向，但是不能确保 POST 会重定向为 POST。303 只允许任意请求到 GET 的重定向。307 和 302 一样，但不允许 POST 到 GET 的重定向。

### 三次握手

最开始的时候客户端和服务器都是处于 CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器。

1. TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN（监听）状态；

2. TCP 客户进程也是先创建传输控制块 TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位 SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP 客户端进程进入了 **SYN-SENT（同步已发送状态）状态**。**TCP 规定，SYN 报文段（SYN=1 的报文段）不能携带数据，但需要消耗掉一个序号**。

3. TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 **ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己初始化一个序列号 seq=y，**此时，TCP 服务器进程进入了**SYN-RCVD（同步收到）状态**。这个报文也不能携带数据，但是同样要消耗一个序号。

4. TCP 客户进程收到确认后，还要向服务器给出确认。**确认报文的 ACK=1，ack=y+1，自己的序列号 seq=x+1**，此时，TCP 连接建立，客户端进入 ESTABLISHED（已建立连接）状态。TCP 规定，ACK 报文段可以携带数据，但是如果不携带数据则不消耗序号。

5. 当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了。

#### 为什么不是两次？

无法确认客户端的接收能力。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

**一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误**

### 四次挥手

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，**FIN=1，其序列号为 seq=u，此时，客户端进入 FIN-WAIT-1（终止等待 1）**状态。
2. 服务器收到连接释放报文，发出确认报文，**ACK=1，ack=u+1，并且带上自己的序列号 seq=v**，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。

3. 客户端收到服务器的确认请求后，此时，客户端就进入 **FIN-WAIT-2（终止等待 2）状态**，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，**FIN=1，ack=u+1， seq=w，此时，服务器就进入了 LAST-ACK（最后确认）**状态，等待客户端的确认。

5. 客户端收到服务器的连接释放报文后，必须发出确认，**ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态**。注意此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。

6. 服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态

#### 为什么客户端最后还要等待 2MSL？

### http 知道嘛？哪一层的协议？（应用层)

HTTP 超文本传送协议(Hypertext Transfer Protocol )是应用层协议，定义的是传输数据的内容的规范
**灵活可扩展**，除了规定空格分隔单词，换行分隔字段以外，其他都没有限制，不仅仅可以传输文本，还可以传输图片、视频等任意资源
**可靠传输**，基于 TCP/IP 所以继承了这一特性
**请求-应答，有来有回**
**无状态**，每次 HTTP 请求都是独立的，无关的、默认不需要保存上下文信息

### POST 一般可以发送什么类型的文件，数据处理的问题

文本、图片、视频、音频等都可以
text/image/audio/ 或 application/json 等

### post 的 ContentType 类型有哪些

Content-Type 字段来获知请求中的消息主体是用何种方式编码，

1. application/x-www-form-urlendcoded 表单
2. multipart/form-data 文件上传
3. application/json json
4. text/xml

### 输入 url 到看见页面，发生了什么

1. 浏览器的地址栏输入 URL 并按下回车。

2. 浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期。

3. DNS 解析 URL 对应的 IP。

4. 根据 IP 建立 TCP 连接（三次握手）。

5. HTTP 发起请求。

6. 服务器处理请求，浏览器接收 HTTP 响应。

7. 渲染页面，构建 DOM 树。

8. 关闭 TCP 连接（四次挥手）。

### 说一下 Http 缓存策略，有什么区别，分别解决了什么问题 \*\*\*

浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起 HTTP 请求，将缓存过程划分为两个部分：强制缓存和协商缓存，强缓存优先于协商缓存。

1. 强缓存
   不会向服务器发送请求,直接从缓存中读取资源

   - expires(http/1.0,时间格式 GMT)
     该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。绝对时间。
   - cache-control(http/1.1,单位 秒)
     这两者的区别就是前者是绝对时间，而后者是相对时间。该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。
     - max-age(表示缓存内容在 xx 秒后消失)
     - no-cache(不使用强缓存，需要与服务器验证缓存是否新鲜)
     - no-store(真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。)
     - public(所有内容都将被缓存包括客户端和代理服务器， 如 cdn)
     - private(所有内容只有客户端可以缓存)
     - must-revalidate:超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。
     - s-maxage(只用于共享缓存和 max-age 效果一样,只是 max-age 用于普通缓存)

2. 协商缓存
   当协商缓存生效时,返回 304 和 Not Modified。它指的是强制缓存失效后,浏览器携带缓存标示向服务器发起请求,由服务器决定是否需要使用缓存。
   - Last-Modified 和 If-Modified-Since
     1. 服务器通过 Last-Modified 字段告知客户端，**资源最后一次被修改的时间**,浏览器将这个值和内容一起记录在缓存数据库中。
     2. 浏览器下次请求时，检测是否有 Last-Modified 字段,如果存在,在请求头中将上次的 Last-Modified 的值写入到请求头的 If-Modified-Since 字段.
     3. 服务器会将 If-Modified-Since 的值与 Last-Modified 字段进行对比, 如果没有变化则返回 304 直接从缓存中读取，否则返回新资源。
   - ETag 和 If-None-Match
     Etag 存储的是**文件的特殊标识**(一般都是 hash 生成的)，服务器存储着文件的 Etag 字段。之后的流程和 Last-Modified 一致，只是 Last-Modified 字段和它所表示的更新时间改变成了 Etag 字段和它所表示的文件 hash。
     1. Etag 是上一次加载资源时,服务器返回的。它的作用是唯一用来标示资源是否有变化。
     2. 浏览器下次请求时将 ETag 值传入 If-None-Match,服务端匹配传入的值与上次是否一致，如果一致返回 304 否则返回新资源和新的 ETag。
        **Etag 的优先级高于 Last-Modified**

https://lvan-zhang.blog.csdn.net/article/details/105513486
Service Worker-->Memory Cache-->Disk Cache-->Push Cache。
Memory Cache 内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。

Disk Cache--> 存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上

#### 在 nginx 中配置缓存

1. 私有缓存： 作为静态网站服务器，设置 Cache-Control 头，让浏览器对页面资源进行缓存 ： add_header cache-control

   ```bash
   server {
   		# ...

    # 静态文件夹下内容，缓存时长设置为1年
    location ^~ /static/ {
   			add_header Cache-Control "public, max-age=31536000, immutable";
    }

   		# 对css 和js 文件，缓存时长设置为1年
    location ~* \.(css|js)$ {
      add_header Cache-Control "public, max-age=31536000, immutable";
    }

   		# json和html文件，每次访问都需要发送检测缓存是否过期；
    location ~* \.(json|html)$ {
      add_header Cache-Control "public, no-cache";
    }
   }
   ```

2. 共享缓存： 作为代理服务器，把源服务器返回的资源缓存到本地；

```bash
# 1、设置缓存的基本配置
proxy_cache_path /path/to/cache levels=1:2 keys_zone=my_cache:10m max_size=10g
                 inactive=60m use_temp_path=off;

server {
    # ...
    location / {
    		# 2、开启缓存功能
        proxy_cache my_cache;
        proxy_pass http://my_upstream;
    }
}
```

### 为何既有 last-modified 又有 Etag

考虑以下情况：

1. 一些文件也许会周期性的更改,但是他的内容并不改变(仅仅改变的修改时间),这个时候,我们并不希望客户端认为这个文件被修改了,而重新 get
2. 某些文件修改非常频繁,比如在秒以下的时间内进行修改(比方说 1s 内修改了 N 次),If-Modified-Since 能检查到的粒度时 s 级的,这种修改无法判断(或者说 UNIX 记录 MTIME 只能精确到秒)
3. 某些服务器不能精确得到的文件的最后修改时间

### 缓存场景

对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略

1. 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存
2. 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新
3. 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件

### encoding 头部有哪些编码方式

1. Unicode
2. utf-8
3. ascii
4. gbk

### utf-8 和 unicode 的区别

Unicode 是「字符集」
Unicode 本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。 编号怎么对应到二进制表示呢？有多种方案：主要有 UTF-8，UTF-16，UTF-32。

UTF-8 是「编码规则」
UTF-8 就是使用变长字节表示,顾名思义，就是使用的字节数可变，这个变化是根据 Unicode 编号的大小有关，编号小的使用的字节就少，编号大的使用的字节就多。使用的字节个数从 1 到 4 个不等。

### http 是如何复用的

从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加上 Connection、Keep-Alive 字段.多个请求可以复用**同一个 TCP 连接**

### http2.0 多路复用

[参考链接](https://blog.csdn.net/weixin_33976072/article/details/88961413)
在 HTTP1.1 的协议中，我们传输的 request 和 response 都是**基本于文本**的，这样就会引发一个问题：所有的数据必须按**顺序传输**，比如需要传输：hello world，只能从 h 到 d 一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在 HTTP1.1 是不能实现的。

HTTP/2 引入**二进制数据帧和流**的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，**就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况**。同样是因为有了序列，服务器就可以**并行的传输数据**，这就是流所做的事情。

### http2 的特性

1. 二进制分帧传输
   在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个**彻底的二进制协议**，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。

2. 多路复用
   HTTP/2 **仍然复用 TCP 连接**，但是在一个连接里， 客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送， 这样就避免了"队头堵塞"的问题。

3. 数据流
   HTTP/2 为此定义了一个流（Stream）的概念，它是虚拟的，可以想象成二进制帧的双向传输序列。而隶属同一个消息的所有帧都有一个相同的流 ID，不同消息的流 ID 则不同。后续在对帧进行组装的时候，根据这个 ID 来将属于同一个消息的帧组装在一起，得到类似 HTTP/1.1 中的报文，也就是传输时无序，接收时组装。所以，在 HTTP/2 中的多个请求 / 响应之间没有了顺序关系，不需要排队等待，也就不会再出现队头阻塞问题，降低了延迟，大幅度提高了连接的利用率。

**说白了在 HTTP/2 中就是将二进制的报文数据切分成多个帧进行传输，而不同消息的帧可以混在一起发送（传输时无序），而在接收时再根据流 ID 将属于同一个消息的帧组装在一起（接收时组装）。因为流是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上同时发送多个碎片化的消息，这就是常说的多路复用（ Multiplexing），多个往返通信都复用一个连接来处理**

4. 首部压缩
   HTTP/2 实现了头信息压缩，\*\*由于 HTTP 1.1 协议不带有状态，每次请求都必须 附上所有信息。所以，请求的很多字段都是重复的，这会浪费很多带宽，也影响 速度。
   HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，**头信息使用 gzip 或 compress 压缩后再发送**；另一方面， **客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。**

5. 服务器推送
   **HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。**使用服务器推送，提前给客户端推送必要的资源 ，这样就可以相对减少一些延迟 时间。这里需要注意的是 http2 下服务器主动推送的是**静态资源**，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

### http3

1. http3 基于 Qick 协议，而 QUIC 是基于传输层 UDP 上的协议，可以定义成:HTTP3.0 基于 UDP 的安全可靠的 HTTP2.0 协议。
2. 减少了 TCP 三次握手及 TLS 握手时间
3. 多路复用丢包的线头阻塞问题
   QUIC 保留了 HTTP2.0 多路复用的特性，在之前的多路复用过程中，同一个 TCP 连接上有多个 stream，假如其中一个 stream 丢包，在重传前后的 stream 都会受到影响，而 QUIC 中一个连接上的多个 stream 之间没有依赖。所以当发生丢包时，只会影响当前的 stream，也就避免了线头阻塞问题。
4. 优化重传策略
5. 流量控制
6. 连接迁移

### 为什么 HTTP3.0 要使用 UDP 协议

HTTP/3 选择了 UDP，主要是为了解决对头阻塞问题。它的底层协议，就是大名鼎鼎的 QUIC，一个运行在传输层（也可以说是应用层）的协议。与 TCP 不同的是，QUIC 代码并没有硬编码在操作系统内核中，而是完全运行在用户空间的，默认集成了 TLS。

1. QUIC 能够实现 TCP 协议的所有功能性需求，并集成了 TLS，功能上赶超了 TCP
2. 一条连接，多个 stream 并发传输，真正的多路复用，有效解决队头阻塞现象，性能上超越了 TCP
3. 减少握手次数，尤其是带 TSL 传输的握手次数，有更低的握手延迟
4. 由于易于升级，为协议的更新和发展，提供了巨大的想象空间

### tcp 三次握手

[tcp 三次握手](./tcp三次握手.md)

### http 的缺点

1. 通信使用明文（不加密），内容可能会被窃听‘
2. 不验证通信方身份，可能遭遇伪装
3. 无法验证报文完整性，可能遭遇篡改
4. 队头堵塞
   HTTP/1.1 默认使用了**持久连接**keep-alive，多个请求可以复用**同一个 TCP 连接**，但是在 同一个 TCP 连接里面，数据请求的通信次序 是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话， 就会造成许多请求排队等待的情况，这种情况被称为“队头堵塞”。

### http 中间人劫持了解吗?如何解决呢?

假设有一个攻击者处于“浏览器”和“网站服务器”的通讯线路之间（比如公共 WIFI），它的攻击过程如下：

服务器向客户端发送公钥。
攻击者截获公钥，保留在自己手上。
然后攻击者自己生成一个【伪造的】公钥，发给客户端。
客户端收到伪造的公钥后，生成加密 hash 值发给服务器。
攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。
同时生成假的加密 hash 值，发给服务器。
服务器用私钥解密获得假秘钥。
上面问题的根源是因为“缺乏身份认证机制”，浏览器无法鉴别自己收到的密钥是不是真的来自于网站服务器。

### 为什么 https 可以做到避免中间人劫持?

如何解决 SSL 的身份认证问题——CA 的引入：
由于双方通常都是互不相识的，显然不可能采用第一种方式，而只能采用第二种公证人方式。
那么，谁来充当这个公证人？这时候，CA 就华丽地登场啦。
浏览器验证网站发过来的证书。如果发现其中有诈，浏览器会提示“CA 证书安全警告”。
由于有了这一步，就大大降低了（注意：是“大大降低”，而不是“彻底消除”）前面提到的“中间人攻击”的风险。
为啥浏览器能发现 CA 证书是否有问题？
因为正经的 CA 证书，都是来自某个权威的 CA。如果某个 CA 足够权威，那么主流的操作系统（或浏览器）会内置该 CA 的“根证书”。
（比如 Windows 中就内置了几十个权威 CA 的根证书）
因此，浏览器就可以利用系统内置的根证书，来判断网站发过来的 CA 证书是不是某个 CA 颁发的。

### 加密套件指的是?(举例了 AES)

### 数字签名的原理

### 说下 tls 握手

### https 的 tls 了解吗

### 301 ，302 的 https 被劫持了怎么办

### 介绍 ssl 和 TLS

### 加密握手的过程

### http 常见请求头及其作用

```js
Accept: text/html,image*
浏览器可以接收的类型
Accept-Charset: ISO-8859-1
浏览器可以接收的编码类型
Accept-Encoding: gzip,compress
浏览器可以接收压缩编码类型
Accept-Language: en-us,zh-cn
浏览器可以接收的语言和国家类型
Host: www.lks.cn:80
浏览器请求的主机和端口
Referer: http://www.lks.cn/index.html
请求来自于哪个页面
User-Agent: Mozilla/4.0 compatible; MSIE 5.5; Windows NT 5.0
浏览器相关信息
If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT
某个页面缓存时间
Cookie：
浏览器暂存服务器发送的信息
Connection: close1.0/Keep-Alive1.1
HTTP请求的版本的特点
Date: Tue, 11 Jul 2000 18:23:51GMT
请求网站的时间
Allow:GET
请求的方法 GET 常见的还有POST
Keep-Alive：5
连接的时间；5
Connection：keep-alive
是否是长连接
Cache-Control：max-age=300
缓存的最长时间 300
```

### 常见响应头

```js
Location: http://www.lks.cn/index.html
控制浏览器显示哪个页面
Server:apache nginx
服务器的类型
Content-Encoding: gzip
服务器发送的压缩编码方式
Content-Length: 80
服务器发送显示的字节码长度
Content-Language: zh-cn
服务器发送内容的语言和国家名
Content-Type: image/jpeg; charset=UTF-8
服务器发送内容的类型和编码类型
Last-Modified: Tue, 11 Jul 2000 18:23:51GMT
服务器最后一次修改的时间
Refresh: 1;url=http://www.lks.cn
控制浏览器1秒钟后转发URL所指向的页面
Content-Disposition: attachment; filename=lks.jpg
服务器控制浏览器发下载方式打开文件
Transfer-Encoding: chunked
服务器分块传递数据到客户端
Set-Cookie:SS=Q0=5Lb_nQ; path=/search
服务器发送Cookie相关的信息
Expires: -1
资源的过期时间，提供给浏览器缓存数据,-1永远过期
Cache-Control: no-cache
告诉浏览器，一定要回服务器校验，不管有没有缓存数据。
Pragma: no-cache
服务器控制浏览器不要缓存网页
Connection: close/Keep-AliveHTTP
请求的版本的特点
Date: Tue, 11 Jul 2000 18:23:51 GMT
响应网站的时间
ETag：“ihfdgkdgnp98hdfg”
资源实体的标识(唯一标识，类似md5值，文件有修改md5就不一样)
```

### http 请求组成

1. 请求行
   包含请求的方法, url， http 协议版本
2. 首部(key-value)
   user-agent
   accpet
   host
3. 实体
   post 请求中 key-value
4. 空行
   用来划分首部和实体

### http 响应报文组成

1. 状态行，
   状态码，原因短语，http 版本
2. 首部行
   服务器类型，日期，长度，内容类型
3. 实体主体。
   服务返回的数据

### 各区间状态码

https://blog.csdn.net/wteruiycbqqvwt/article/details/120995593
2xx:请求成功
3xx:重定向
4xx:客户端请求错误
5xx 服务器错误

常见：
200-请求成功、
202-服务器端已经收到请求消息，但是尚未进行处理
204-服务器成功处理了请求，但没有返回任何内容。
301 永久重定向：会缓存，搜索引擎在抓去新内容的同时，将旧的网址替换为重定向之后的网址
302 临时重定向：不会缓存，搜索引擎会抓取新的内容，并继续保存旧的网址。
304-所请求的资源未修改、
400-客户端请求的语法错误、
404-请求的资源不存在
500 （服务器内部错误） 服务器遇到错误，无法完成请求。
501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

### restful APi 分别使用拿些 http 副词

POST 增
DELETE 删
PUT 改
GET 查

### HTTP 常用的请求方式，区别和用途？

http/1.1 规定如下请求方法：

GET：通用获取数据
HEAD：获取资源的元信息
POST：提交数据
PUT：修改数据
DELETE：删除数据
CONNECT：建立连接隧道，用于代理服务器
OPTIONS：列出可对资源实行的请求方法，常用于跨域
TRACE：追踪请求-响应的传输路径

### OSI 七层模型和 TCP/IP 四层模型

应用层
表示层
会话层
传输层
网络层
数据链路层
物理层

TCP/IP 四层概念：

应用层：应用层、表示层、会话层：HTTP
传输层：传输层：TCP/UDP
网络层：网络层：IP
数据链路层：数据链路层、物理层

### DNS 解析是去哪找的缓存

1. 浏览器缓存

当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的 IP 地址（若曾经访问过该域名且没有清空缓存便存在）；

2. 系统缓存 Hosts 文件

当浏览器缓存中无域名对应 IP 则会自动检查用户计算机系统 Hosts 文件 DNS 缓存是否有该域名对应 IP；

3. 路由器缓存

当浏览器及系统缓存中均无域名对应 IP 则进入路由器缓存中检查，以上三步均为客服端的 DNS 缓存；

4. ISP（互联网服务提供商）DNS 缓存

当在用户客服端查找不到域名对应 IP 地址，则将进入 ISP DNS 缓存中进行查询。比如你用的是电信的网络，则会进入电信的 DNS 缓存服务器中进行查找；

### DNS 的解析过程

DNS 的查询过程一般为，

1. 我们首先将 DNS 请求发送到本地 DNS 服务器，由 本地 DNS 服务器来代为请求。
2. 从"根域名服务器"查到"顶级域名服务器"的 NS 记录和 A 记录（ IP 地 址）。
3. 从"顶级域名服务器"查到"次级域名服务器"的 NS 记录和 A 记录（ IP 地址）。
4. 从"次级域名服务器"查出"主机名"的 IP 地址。

比如我们如果想要查询 www.baidu.com 的 IP 地址，

1.  我们首先会将请求发送到 本地的 DNS 服务器中，本地 DNS 服务器会判断是否存在该域名的缓存，
2.  如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责.com 的顶级域名服务器的 IP 地址的列表。
3.  然后本地 DNS 服务器再向其中一个负责.com 的顶级域名服务器发送一个请求，负责.com 的顶级域名服务器返回负责.baidu 的权威域名服务器的 IP 地址列表。
4.  然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表

### 浏览器有哪些进程，渲染进程都有哪些线程

##### 浏览器有哪些进程

1. 浏览器主进程
2. 渲染进程
3. GPU 进程
4. 网络进程
5. 其他插件进程

#### 渲染进程都有哪些线程

1. GUI 渲染线程（与 js 线程互斥，js 引擎线程优先级会高于 GUI 渲染线程）
2. js 引擎线程
3. 事件触发线程
4. 定时处理线程
5. 异步请求 http 线程

### cdn 是什么，原理， 为什么要使用 cdn

内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。

如果用户访问的网站部署了 CDN，过程是这样的：

1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。
2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。
3. 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。
4. 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。
5. SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。
6. 浏览器再根据 SLB 发回的地址重定向到缓存服务器。
7. 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。

https://juejin.cn/post/6844904100035821575

## HTTP 报文结构是怎样的

header + body 的结构，具体而言:

起始行 + 头部 + 空行 + 实体

1. 起始行

- 请求报文 ： GET /home HTTP/1.1
  方法 + 路径 + http 版本。

- 响应报文，HTTP/1.1 200 OK 版本 + 状态码 + 原因
  响应报文的起始行也叫做状态行。由 http 版本、状态码和原因三部分组成。

2. 头部

3. 空行
   用来区分 起始行 和 实体
4. 实体
   就是具体的数据了，也就是 body 部分。请求报文对应请求体, 响应报文对应响应体

## http 缺点

1. 明文传输
   即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。
   这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI 陷阱就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。
2. 队头堵塞
   HTTP/1.1 默认使用了**持久连接**keep-alive，多个请求可以复用**同一个 TCP 连接**，但是在 同一个 TCP 连接里面，数据请求的通信次序 是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话， 就会造成许多请求排队等待的情况，这种情况被称为“队头堵塞”。
3. 无状态
   在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。

但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。

## http 长连接和 websocket 长连接的区别

1. HTTP1.1 通过使用 Connection:keep-alive 进行长连接，HTTP 1.1 默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是**对每个请求仍然要单独发 header，Keep-Alive 不会永久保持连接，它有一个保持时间**，可以在不同的服务器软件（如 Apache）中设定这个时间。这种长连接是一种“伪链接”

2. websocket 的长连接，是一个真的全双工。长连接第一次 tcp 链路建立之后，后续数据可以双方都进行发送，不需要发送请求头。

3. keep-alive 双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。

## http 和 https 的区别及优缺点？

- http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。
- http 协议的默认端口为 80，https 的默认端口为 443。
- http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。
- https 缓存不如 http 高效，会增加数据开销。
- Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。
- SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。

## TCP/IP / 如何保证数据包传输的有序可靠？

- 数据分块：应用数据被分割成 TCP 认为最适合发送的数据块。
- 序列号：TCP 给发送的每一个包进行编号。接收方接收到发送方的数据包之后，回传一个 ACK 信号，标识下一个需求的数据包初始字节编号。
- 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
- 重复丢弃：TCP 的接收端会丢弃重复的数据。
- 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的**流量控制协议是可变大小的滑动窗口协议**。 （**TCP 利用滑动窗口实现流量控制**）
- 拥塞控制： **当网络拥塞时，减少数据的发送**。
- 停止等待协议 也是为了实现可靠传输的，它的基本原理就是**每发完一个分组就停止发送，等待对方确认**。在收到确认后再发下一个分组
- 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### 为什么 udp 不可靠

提供无连接、尽最大努力的数据传输服务(不保证数据传输的可靠性)，既然不保证那肯定谈不上可靠一说。

- 无连接：不需要建立连接，也不需要释放连接，减少了开销和发送数据的时延。
- **UDP 只有一个 socket 接受缓冲区，没有 socket 发送缓冲区，即只要有数据就发，不管对方是否可以正确接受。而在对方的 socket 接受缓冲区满了之后，新来的数据报无法进入到 socket 接受缓冲区，此数据报就会被丢弃，udp 是没有流量控制的，故 UDP 的数据传输是不可靠的**
- **尽最大努力的数据传输服务：不保证数据传输的可靠性，没有超时和重传功能**。

- 面向报文：发送方对应用程序交下来的服务，添加首部后就向下交付给 IP 层，不合并，也不拆分，保留文本的边界。UDP 一次性交付一个完整的报文，因此应用程序一定要选择合适大小的报文，报文太长 IP 层需要进行分片，太短会导致 IP 数据包的相对长度过大，效率过低。接收方，去除首部后就交给应用程序。

## TCP 和 UDP 的区别

TCP 是面向连接的，UDP 是无连接的
TCP 是可靠的，UDP 是不可靠的
TCP 是面向字节流的，UDP 是面向数据报文的
TCP 只支持点对点通信，UDP 支持一对一，一对多，多对多
TCP 报文首部 20 个字节，UDP 首部 8 个字节
TCP 有拥塞控制机制，UDP 没有
TCP 协议下双方发送接受缓冲区都有，UDP 并无实际意义上的发送缓冲区，但是存在接受缓冲区

## post 和 get 请求的区别

- 应用场景： GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。

- 是否缓存： 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。

- 发送的报文格式： Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。

- 安全性： Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。

- 请求长度： 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。

- 参数类型： post 的参数传递支持更多的数据类型。
- 幂等性 ： GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)

## http 特点

HTTP 的特点概括如下:

**灵活可扩展**，主要体现在两个方面。

- 一个是**语义上的自由**，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。
- 另一个是**传输形式的多样性**，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。

- **可靠传输**。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。

- **请求-应答**。也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。

- **无状态**。这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息

## Accept

- 压缩方式
  // 发送端
  Content-Encoding: gzip, deflate, br
  // 接收端
  Accept-Encoding: gzip

- 支持语言
  // 发送端
  Content-Language: zh-CN, zh, en
  // 接收端
  Accept-Language: zh-CN, zh, en

- 数据格式
  // 发送端 Content-Type 代表发送端（客户端|服务器）发送的实体数据的数据类型。
  Content-Type ：
  // 接受端 Accept 代表发送端（客户端）希望接受的数据类型。
  Accept：

  这两个字段的取值可以分为下面几类:

  text： text/html, text/plain, text/css 等
  image: image/gif, image/jpeg, image/png 等
  audio/video: audio/mpeg, video/mp4 等
  application: application/json, application/javascript, application/pdf, application/octet-stream

- 字符集
  // 发送端,
  Content-Type: text/html; charset=utf-8
  // 接收端
  Accept-Charset: charset=utf-8

## http 如何传输定长和不定长数据

### 定长数据

content-length 指定数据长度

```js
const http = require("http");

const server = http.createServer((req, res) => {
  if (req.url === "/") {
    res.setHeader("Content-Type", "text/plain");
    //  指定数据长度
    res.setHeader("Content-Length", 10);
    res.write("helloworld");
    res.end();
  }
});

server.listen(8081, () => {
  console.log("成功启动");
});
```

### 不定长数据 \*\*

Transfer-Encoding: chunked

表示分块传输数据，设置这个字段后会自动产生两个效果:

- Content-Length 字段会被忽略
- 基于长连接持续推送动态内容

```js
const server = http.createServer();

server.on("request", (req, res) => {
  if (req.url === "/") {
    res.setHeader("Content-Type", "text/html; charset=utf8");
    res.setHeader("Content-Length", 10);
    res.setHeader("Transfer-Encoding", "chunked");
    res.write("<p>来啦</p>");
    setTimeout(() => {
      res.write("第一次传输<br/>");
    }, 1000);
    setTimeout(() => {
      res.write("第二次传输");
      res.end();
    }, 2000);
  }
});

server.listen(8009, () => {
  console.log("成功启动");
});
```

## HTTP 如何处理大文件的传输

### 单段数据

对于单段数据的请求，返回的响应如下:

```js
HTTP/1.1 206 Partial Content
Content-Length: 10
Accept-Ranges: bytes
Content-Range: bytes 0-9/100

i am xxxxx

```

值得注意的是**Content-Range**字段，0-9 表示请求的返回，100 表示资源的总大小，很好理解。

### 多段数据

接下来我们看看多段请求的情况。得到的响应会是下面这个形式:

```js
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000010101
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes


--00000010101
Content-Type: text/plain
Content-Range: bytes 0-9/96

i am xxxxx
--00000010101
Content-Type: text/plain
Content-Range: bytes 20-29/96

eex jspy e
--00000010101--

```

这个时候出现了一个非常关键的字段**Content-Type: multipart/byteranges;boundary=00000010101**，它代表了信息量是这样的:

请求一定是多段数据请求
响应体中的分隔符是 00000010101

因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上--表示结束。
以上就是 http 针对大文件传输所采用的手段。

## HTTP 中如何处理表单数据的提交

在 http 中，有两种主要的表单提交的方式，体现在两种不同的 Content-Type 取值:

application/x-www-form-urlencoded
multipart/form-data

### 1. a、、、、、、、

对于 application/x-www-form-urlencoded 格式的表单内容，有以下特点:

- 其中的数据会被编码成以&分隔的键值对
- 字符以 URL 编码方式编码。

### 2. multipart/form-data

对于 multipart/form-data 而言:

请求头中的**Content-Type 字段会包含 boundary，且 boundary 的值有浏览器默认指定**。例: Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe。
数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如 Content-Type，在最后的分隔符会加上--表示结束。

相应的请求体是下面这样:

```js

Content-Disposition: form-data;name="data1";
Content-Type: text/plain
data1
----WebkitFormBoundaryRRJKeWfHPGrS4LKe
Content-Disposition: form-data;name="data2";
Content-Type: text/plain
data2
----WebkitFormBoundaryRRJKeWfHPGrS4LKe--
```

## HTTP1.1 如何解决 HTTP 的队头阻塞问题？

https://blog.csdn.net/qq_37886086/article/details/109714173

### 什么是 HTTP 队头阻塞？

从前面的小节可以知道，HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的 HTTP 队头阻塞问题。

### 并发连接

**对于一个域名允许分配多个长连接，那么相当于增加了任务队列**，不至于一个队伍的任务阻塞其它所有任务。在 RFC2616 规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。
但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。

### 域名分片

一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。
比如 content1.sanyuan.com 、content2.sanyuan.com。
这样一个 sanyuan.com 域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

## Cookie

### Cookie 简介

前面说到了 HTTP 是一个无状态的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。但有时候需要保存一些状态，怎么办呢？
HTTP 为此引入了 Cookie。Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在 chrome 开发者面板的 Application 这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的 Set-Cookie 字段来对客户端写入 Cookie。举例如下:

// 请求头
Cookie: a=xxx;b=xxx
// 响应头
Set-Cookie: a=xxx
set-Cookie: b=xxx

### Cookie 属性

#### 生存周期 Expires 和 Max-Age

Cookie 的有效期可以通过 Expires 和 Max-Age 两个属性来设置。
若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。

#### 作用域 Domain 和 path

, 给 Cookie 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说，/表示域名下的任意路径都允许使用 Cookie。

#### 安全相关 Secure

如果带上 Secure，说明只能通过 HTTPS 传输 cookie。
**如果 cookie 字段带上 HttpOnly，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。**

相应的，**对于 CSRF 攻击的预防，也有 SameSite 属性**。
SameSite 可以设置为三个值，Strict、Lax 和 None。

- 在 Strict 模式下，浏览器完全禁止第三方请求携带 Cookie。比如请求 sanyuan.com 网站只能在 sanyuan.com 域名当中请求才能携带 Cookie，在其他网站请求都不能。
- 在 Lax 模式，就宽松一点了，但是只能在 get 方法提交表单况或者 a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。
- 在 None 模式下，也就是默认模式，请求会自动携带上 Cookie。

### Cookie 的缺点

- 容量缺陷。
  Cookie 的体积上限只有 4KB，只能用来存储少量的信息。

- 性能缺陷。
  Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过 Domain 和 Path 指定作用域来解决。

- 安全缺陷。
  由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在 HttpOnly 为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

## http 和 tcp 区别

**TCP 是传输层协议，所要规定的是数据应该怎么传输才能稳定且高效的传递与计算机之间。**。握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。

**HTTP 超文本传送协议(Hypertext Transfer Protocol )是应用层协议，定义的是传输数据的内容的规范**。

HTTP 协议中的数据是利用 TCP 协议传输的，特点是客户端发送的每次请求都需要服务器回送响应，它是 TCP 协议族中的一种，默认使用 TCP 80 端口。

好比网络是路，TCP 是跑在路上的车，HTTP 是车上的人。每个网站内容不一样，就像车上的每个人有不同的故事一样。

## HTTP 中的 Keep-Alive 有了解过吗？

Keep-Alive 是 HTTP 的一个头部字段 Connection 中的一个值，它是保证我们的 HTTP 请求能建立一个**持久连接。也就是说建立一次 TCP 连接即可进行多次请求和响应的交互**。它的特点就是只要有一方没有明确的提出断开连接，则保持 TCP 连接状态，减少了 TCP 连接和断开造成的额外开销。
另外，在 HTTP/1.1 中所有的连接默认都是持久连接的，但是 HTTP/1.0 并未标准化。

## 你们的 token 一般是存放在哪里的

Token 其实就是访问资源的凭证。
一般是用户通过用户名和密码登录成功之后，服务器将登陆凭证做数字签名，加密之后得到的字符串作为 token。
它在用户登录成功之后会返回给客户端，客户端主要有这么几种存储方式：

存储在 localStorage 中，每次调用接口的时候都把它当成一个字段传给后台
存储在 cookie 中，让它自动发送，不过缺点就是不能跨域
拿到之后存储在 localStorage 中，每次调用接口的时候放在 HTTP 请求头的 Authorization 字段里

### pwa 是什么，对 pwa 有什么了解

### 项目中常用的 linux 命令

### 业务中打包怎么做的

### 如何查询某个进程占用的端口号(linux 中)

netstat -tunlp|grep 80 或 lsof -i:80

### git reset 和 git rebase 了解吗

### 说下上线部署流程中常用的 linux 命令

### 说下 https

1. 超文本安全传输协议，基于 http,会使用 tls（安全传输协议）/SSl(安全套接层)（两者可以视作同一个东西的不同阶段）
2. 运行机制： 使用混合加密方法
   1. **交换密钥**阶段采用**非对称密钥加密**方法，之后建立通信**交换报文**阶段采用**对称密钥加密**方法
   2. 防止中间人截取密钥，使用数字证书，保证公开密钥的安全性。
   3. 数字认证的过程：
      1. 使用 hash 算法将**公钥和原始信息 P** 加密生成信息摘要
      2. CA 用它的**私钥对信息摘要加密，生成签名 S**
      3. 将**原始信息和签名（P,S)**合在一起，称为**数字证书**。
      4. 认证数字证书
         当接收方收到数字证书的时候
      - 先根据**原始信息（P）使用同样的 Hash 算法生成一个摘要**
      - 然后使用**CA 公证处的公钥来对数字证书中的签名（S）进行解密得到摘要**
      - 最后将解密的摘要和我们生成的摘要进行**对比**，就能发现我们得到的信息是否被更改了。
   - **hash(公钥+原始信息 P)=>信息摘要 =>CA 私钥加密生成签名 S**;
   - **hash(原始信息 P+公钥) 生成摘要 1， 用 CA 的公钥对 S 解密得到摘要 2，摘要 1 对比摘要 2.**

### HTTP 风险

1. 通信使用**明文**（不加密），内容可能会被**窃听**
2. 不验证通信方身份，可能遭遇**伪装**
3. 无法**验证报文完整性**，可能遭遇**篡改**

### HTTPS

HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/ SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立刻发现。它还配备了身份证书，防止身份被冒充的情况出现。
HTTPS = HTTP + SSL（安全套接层）/TLS(安全传输协议 Transport Layer Security)
HTTPS = HTTP +加密+认证+完整性保护

> SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS,很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段

### SSL/TLS 协议运行机制

#### 对称加密算法

比如 AES
双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性， 因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。

#### 非对称加密算法

比如 RSA
有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。

#### HTTPS 采用混合加密方法

对称加密算法：速度快，安全性差
非对称加密算法：速度慢，安全性高
HTTPS：**交换密钥**阶段采用**非对称密钥加密**方法，之后建立通信**交换报文**阶段采用**对称密钥加密**方法

### 如何确定公开密钥的安全性

单纯的对称+非对称加密算法也不一定是安全的。因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个**中间人**，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。

##### 数字证书

为了解决这样的问题，我们可以使用数字证书的方式。

1. 首先我们使用一种 **Hash 算法**来对**我们的公钥**和其他信息（原始信息 P）进行加密生成一个**信息摘要**
2. 然后让有公信力的认证中心（简称 CA ）用**它的私钥**对消息摘要加密，形成**签名（S）**。
3. 最后将**原始信息和签名（P,S）**合在一起，称为**数字证书**。
4. 认证数字证书
   当接收方收到数字证书的时候
   - 先根据原始信息（P）使用同样的 Hash 算法生成一个摘要
   - 然后使用公证处的公钥来对数字证书中的签名（S）进行解密得到摘要
   - 最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改了。

这个方法最重要的是**认证中心的可靠性**， 一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们， 只有这样我们才能保证数据的安全。

详情可参考知乎上的这个回答:[数字证书的原理是什么？](https://www.zhihu.com/question/24294477/answer/74783418)

### SSL/TLS 协议基本过程

1. 客户端向服务器端索要并验证公钥。

2. 双方协商生成"对话密钥"。

3. 双方采用"对话密钥"进行加密通信。

上面过程的前两步，又称为"握手阶段"（handshake）。

#### 握手阶段

握手阶段"的所有通信都是明文的。

1. 客户端向服务器发起请求
   请求中包含：

- 使用的协议版本号
- 生成的一个**随机数**（用于生成对话秘钥）
- 客户端支持的**加密方法**
- 客户端支持的压缩算法

2. 服务器端接收到请求后发出响应
   响应中包含：

- **确认双方使用的加密方法**
- **服务器的证书**
- 一个服务器生成的**随机数**。

3. 客户端回应

- 客户端确认服务器证书有效后，生成一个新的**随机数**，
- **并使用数字证书中的公钥，加密这个随机数**，然后发给服务器
- 并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。表示客户端的握手阶段已经结束。

4. 服务器响应

- 服务器使用自己的**私钥，来解密客户端发送过来的随机数**。
- 并提供前面所有内容的 hash 值来供客户端检验。表示服务器的握手阶段已经结束。

5. 生成对话秘钥
   **客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。**

### 为什么不一直使用 HTTPS

1. 加密通信消耗更多内存和 CPU
2. 节约购买证书的成本
3. 敏感信息才使用 HTTPS

### 明信片问题

聊一个明信片问题吧，你有一个明信片，要寄给一个陌生人，有几个问题

你怎么保证不被快递员知道内容？（包上信封,这里埋了个坑，没有联想到另一篇看过的鸽子通信里面，用箱子锁上更加可靠）
快递员把信封拆掉呢？（在信的内容里添加线索，在信封外加上线索进行一个解密对应，当时没 get 到面试官针对上面的提示）
信封被换掉了呢？（找权威的邮局加上印章）
陌生人怎么知道哪些是权威的印章呢？（人手一份邮局的对照表）

那印章发生了更新呢？（邮局通知或者自己去更新）

### hash 摘要算法

MD(消息摘要算法)、SHA(安全散列算法)及 Mac(消息认证码算法)

### 参考文章

1. [SSL/TLS 协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)
2. [HTTPS 原理分析——带着疑问层层深入](https://blog.leapmie.com/archives)
3. [数字签名和数字证书究竟是什么？](jianshu.com/p/80aa37311151)
