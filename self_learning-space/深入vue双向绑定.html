<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title> </title>
</head>
<body>
    <div id="app">
        <h2 v-text="list"></h2>
        <input v-model="obj.a.c">
        <h1>{{name}}</h1>
        <p>{{obj.a.c}}</p>
        <button v-on:click="clickMe">click me!</button>
        <p v-text='a'></p>
        <div v-html="b"></div>
    </div>
  <script>
  //监听数组变动,数组对象无法通过Object.defineProperty实现监听，Vue包含观察数组的变异方法，来触发视图更新。
// /辅助方法+++++++++++++++++++++++++++++++++++++++++++++++
//辅助方法
function def (obj, key, val) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: true,
    writable: true,
    configurable: true
  })
}

//重新赋值Array的__proto__属性
function protoAugment (target,src) {
  target.__proto__ = src
}
//不支持__proto__的直接修改相关属性方法
function copyAugment (target, src, keys) {
  for (let i = 0, l = keys.length; i < l; i++) {
    const key = keys[i]
    def(target, key, src[key])
  }
}
//收集数组的依赖
function dependArray (value) {
  for (let e, i = 0, l = value.length; i < l; i++) {
    e = value[i]
    e && e.__ob__ && e.__ob__.dep.depend()
    if (Array.isArray(e)) {
      //循环遍历chindren进行依赖收集
        dependArray(e)
    }
  }
}
// 处理数组======================================================

const arrayProto = Array.prototype;
const arrayMethods = Object.create(arrayProto);
[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
].forEach(item=>{
  Object.defineProperty(arrayMethods,item,{
      value:function mutator(){
        //缓存原生方法，之后调用
        const original = arrayProto[item] 
        let args = Array.from(arguments)
        original.apply(this,args)
        const ob = this.__ob__;
        ob.dep.notify()
      },
  })
})
//获得arrayMethods对象上所有属性的数组
const arrayKeys = Object.getOwnPropertyNames(arrayMethods)

// +++++++++++++++++++++++++++++++++++++++++++++++++++++
  // ===============================================================
  // 监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者
    function Observer(value) {
      this.value = value;
      this.dep = new Dep();
     //将Observer实例绑定到data的__ob__属性上面去，后期如果oberve时直接使用，不需要从新Observer,
      //处理数组是也可直接获取Observer对象
      def(value, '__ob__', this)
      if (Array.isArray(value)) {
        //处理数组
          const augment = value.__proto__ ? protoAugment : copyAugment  
          //此处的 arrayMethods 就是上面使用Object.defineProperty处理过
          augment(value, arrayMethods, arrayKeys)
          // 循环遍历数组children进行oberve
          this.observeArray(value)
      }else{
        this.walk(value);
      }
    }
  // 递归调用，为对象绑定getter/setter
    Observer.prototype.walk = function(obj) {
      var keys = Object.keys(obj);
      for(var i = 0;i<keys.length;i++) {
        if(keys[i]=='__ob__') return;
        this.convert(keys[i],obj[keys[i]])
      }
    }

    // 将属性转换为getter/setter
    Observer.prototype.convert = function(key, val) {
      defineReactive(this.value,key,val)
    }

    function observe(value) {
      // 当值不存在或者不是对象类型时，不需要继续深入监听
      if (!value || typeof value !== 'object') {
        return;
      }
      return new Observer(value)
    }
    // 观察数组的每一项
    Observer.prototype.observeArray = function(items) {
      for (var i = 0; i<items.length; i++) {
        console.log(items[i])
          observe(items[i])
      }
    };

    function defineReactive(obj,key,val) {
      var dep = new Dep();//植入消息订阅器，当属性值变化时，通知该订阅器下的所有订阅者（绑定该属性值的所有watcher）更新视图
      var property = Object.getOwnPropertyDescriptor(obj, key)
      if (property && property.configurable === false) {
          return
    }
      // 保存对象属性预先定义的getter/setter
    var getter = property && property.get
    var setter = property && property.set

      var childOb = observe(val);
      Object.defineProperty(obj, key, {
         enumerable: true,
         configurable: true,
         get:function reactiveGetter() {
           console.log(`调用了get，值为${val}`)
          var value = getter ? getter.call(obj) : val
          if(Dep.target){//只在订阅者Watcher初始化的时候才需要添加订阅者
            dep.depend();
            if(childOb) {
              childOb.dep.depend();
            }
            if(Array.isArray(value)) {
              dependArray(value)
            }
          }
          return value
         },
         set: function reactiveSetter (newVal) {
            var value = getter ? getter.call(obj) : val
            if (newVal === value) {
                return
            }
            if (setter) {
                setter.call(obj, newVal)
            } else {
                val = newVal;
            }
           childOb = observe(newVal)
           dep.notify();//如果数据变化，通知所有订阅者
        }
      })
    }
    // =====================================================================
    // 订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图
    function Watcher (vm,  expOrFn, cb) {
      this.vm = vm;
      //在Vue中cb是更新视图的核心，调用diff并更新视图的过程
      this.cb = cb;
      //收集Deps，用于移除监听
      this.depIds = {};
      if(typeof expOrFn === 'function') {
        this.getter = expOrFn;
      } else {
        this.getter = this.parseExpression(expOrFn)
      }
      var value  = this.get();// 将自己添加到订阅器的操作
      if(Array.isArray(value)) {
        this.value = value.concat();
      } else {
        this.value = value;
      }
    }
    Watcher.prototype.get = function () {
      // 
      Dep.target = this;// 缓存自己
      const value = this.getter.call(this.vm, this.vm);// 强制执行监听器里的getter函数
      // 依赖收集完成，置空，用于下一个Watcher使用
      Dep.target = null; // 释放自己
      return value;
    }
    Watcher.prototype.addDep = function(dep) {
      if (!this.depIds.hasOwnProperty(dep.id)) {
        dep.addSub(this)
        this.depIds[dep.id] = dep
      }
    }
    Watcher.prototype.update = function () {
      this.run()
    }
    Watcher.prototype.run = function() {
      var value = this.get();
      console.log(11111111,value,this.value)
      if(value !== this.value) {
        var oldValue = this.value;
        console.log(oldValue,value)
        // 将newVal, oldVal挂载到MVVM实例上
        this.cb.call(this.vm, value, oldValue)
      }
    }
    Watcher.prototype.parseExpression = function (exp) {
      if (/[^\w.$]/.test(exp)) {
          return
      }
      var exps = exp.split('.')

      return function(obj) {//遍历获得嵌套对象属性值
          for (var i = 0; i < exps.length; i++) {
              if (!obj) return
              obj = obj[exps[i]]
          }
          return obj
      }
    }
// ================================================================
// 订阅器Dep主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数。
  var uid = 0;
  function Dep () {
    this.id = uid++;
    this.subs = [];
  }
  Dep.target = null;

 //  添加一个订阅者
  Dep.prototype.addSub = function (sub) {
    this.subs.push(sub)
  }

 // * 移除一个订阅者
Dep.prototype.removeSub = function (sub) {
  let index = this.subs.indexOf(sub);
  if (index !== -1) {
    this.subs.splice(index, 1);
  }
}

 // * 将自身作为依赖添加到目标watcher
Dep.prototype.depend = function () {
  Dep.target.addDep(this)
}

 // *通知数据变更
  Dep.prototype.notify = function () {
    this.subs.forEach(function(sub) {
      // 执行订阅者的update更新函数
      sub.update();
    })
  }
// ============================================
  function Compile(el, vm) {
  this.$vm = vm;
  this.$el = this.isElementNode(el) ? el : document.querySelector(el)
  if (this.$el) {
    this.compileElement(this.$el)
  }
}

// ==============================================================
// 解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。
Compile.prototype.compileElement = function (el) {
  let self = this
  let childNodes = el.childNodes;
  [].slice.call(childNodes).forEach(node => {
    let text = node.textContent
    let reg = /\{\{((?:.|\n)+?)\}\}/
    // 处理element节点
    if (self.isElementNode(node)) {
      self.compile(node)
    } else if (self.isTextNode(node) && reg.test(text)) { // 处理text节点
      self.compileText(node, RegExp.$1.trim())
    }
    // 解析子节点包含的指令
    if (node.childNodes && node.childNodes.length) {
      self.compileElement(node)
    }
  })
}

Compile.prototype.compile = function (node) {
  let nodeAttrs = node.attributes
  let self = this;
  [].slice.call(nodeAttrs).forEach(attr => {
    var attrName = attr.name
    if (self.isDirective(attrName)) {
      let exp = attr.value
      let dir = attrName.substring(2)
      if (self.isEventDirective(dir)) {//v-on
        compileUtil.eventHandler(node, self.$vm, exp, dir)
      } else {//v-html,v-text,v-model
        compileUtil[dir] && compileUtil[dir](node, self.$vm, exp)
      }
      node.removeAttribute(attrName)
    }
  });
}

Compile.prototype.compileText = function (node, exp) {
  compileUtil.text(node, this.$vm, exp);
}

Compile.prototype.isDirective = function (attr) {
  return attr.indexOf('v-') === 0
}

Compile.prototype.isEventDirective = function (dir) {
  return dir.indexOf('on') === 0;
}

Compile.prototype.isElementNode = function (node) {
  return node.nodeType === 1;
}

Compile.prototype.isTextNode = function (node) {
  return node.nodeType === 3;
}

// 指令处理集合
var compileUtil = {
  text: function (node, vm, exp) {
    this.bind(node, vm, exp, 'text')
  },
  html: function (node, vm, exp) {
    this.bind(node, vm, exp, 'html')
  },
  model: function (node, vm, exp) {
    this.bind(node, vm, exp, 'model')

    let self = this, val = this._getVMVal(vm, exp)
    node.addEventListener('input', function (e) {
      var newValue = e.target.value
      if (val === newValue) {
        return
      }
      self._setVMVal(vm, exp, newValue)
      val = newValue
    });
  },
  bind: function (node, vm, exp, dir) {
    var updaterFn = updater[dir + 'Updater']
    updaterFn && updaterFn(node, this._getVMVal(vm, exp))
    new Watcher(vm, exp, function (value, oldValue) {
      updaterFn && updaterFn(node, value, oldValue)
    })
  },
  eventHandler: function (node, vm, exp, dir) {
    var eventType = dir.split(':')[1],
        fn = vm.$options.methods && vm.$options.methods[exp];

    if (eventType && fn) {
      node.addEventListener(eventType, fn.bind(vm), false);
    }
  },
  _getVMVal: function (vm, exp) {
    var val = vm
    exp = exp.split('.')
    exp.forEach(function (k) {
      val = val[k]
    })
    return val
  },
  _setVMVal: function (vm, exp, value) {
    var val = vm;
    exp = exp.split('.')
    exp.forEach(function (k, i) {
      // 非最后一个key，更新val的值
      if (i < exp.length - 1) {
        val = val[k]
      } else {
        val[k] = value
      }
    })
  }
}

var updater = {
  textUpdater: function (node, value) {
    node.textContent = typeof value == 'undefined' ? '' : value
  },
  htmlUpdater: function (node, value) {
    node.innerHTML = typeof value == 'undefined' ? '' : value
  },
  modelUpdater: function (node, value, oldValue) {
    node.value = typeof value == 'undefined' ? '' : value
  }
}
// ====================================================================
/**
 * @class 双向绑定类 MVVM
 * @param {[type]} options [description]
 */
function MVVM(options) {
  this.$options = options || {}
  // 简化了对data的处理
  let data = this._data = this.$options.data,self = this;
  this.methods = options.methods;
  Object.keys(data).forEach(function(key) {
        self._proxy(key);
    });
  // 监听数据
  observe(data)
  new Compile(options.el || document.body, this);
  options.mounted.call(this); // 所有事情处理好后执行mounted函数
}

MVVM.prototype.$watch = function (expOrFn, cb) {
  new Watcher(this, expOrFn, cb)
}

MVVM.prototype._proxy = function (key) {// 绑定代理属性
  Object.defineProperty(this, key, {
    configurable: true,
    enumerable: true,
    get: () => this._data[key],
    set: (val) => {
      this._data[key] = val
    }
  })
}
var i=0;
let vm = new MVVM({
  el: '#app',
  data: {
      title: 'hello world',
      name: 'canfoo',
      list:[1,2,3,4,5],
      obj:{
        a:{c:'嵌套对象'}
      },
      a:1,
      b:"<em>苏州</em>"
  },
  methods: {
      clickMe: function () {

          this.list.push(parseInt(Math.random(0,1)*10))
      }
  },
  mounted: function () {
      // window.setTimeout(() => {
      //     this.title = '你好';
      // }, 1000);
  }

  })


  </script>
</body>
</html>