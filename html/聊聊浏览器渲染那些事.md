### 浏览器是多进程的，渲染进程是多线程的

浏览器是多进程的，在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）

### 浏览器包含的进程：

1. Browser 进程
   浏览器的主进程（负责协调，主控），只有一个，作用有：

- 负责浏览器的界面显示，与用户交互，如前进，后退等
- 负责各个页面的管理，创建和销毁其它进程
- 将 Rendered 进程得到的内存中的 Bitmap,绘制到用户界面上
- 网络资源的管理，下载

2. 第三方插件进程
   每种类型的插件对应一个进程，仅当使用该插件时才创建。
3. GPU 进程：最多一个，用于 3D 绘制等。
4. 浏览器渲染进程（浏览器内核）（Render 进程，内部是多线程的）
   默认每个 Tab 页面一个进程，互不影响。主要作用为：页面渲染，脚本执行，事件处理等

### 渲染进程中包含的线程

![](http://cdn.bianyc.xyz/browser.png)

### GUI 渲染线程

- **负责渲染浏览器界面**，解析 HTML,CSS,构建 DOM 树和 RenderObject 树，布局和绘制等。
- 当界面需要**重绘**或由于某种操作引发**回流**时，该线程就会执行。

- 注意，**GUI 渲染线程与 JS 引擎线程是互斥的**，当 JS 引擎执行时 GUI 线程会被挂起（相当于冻结了）,GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

#### JS 引擎线程

- 也称为 JS 内核，负责处理 JavaScript 脚本程序。（例如 V8 引擎）。
- JS 引擎线程负责**解析 JavaScript 脚本，运行代码**。
- JS 引擎一直等待着任务队列中任务的到来，然后加以处理，**一个 Tab 页（render 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序**。
- 同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以**如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞**。

#### 事件触发线程

- **归属于浏览器而不是 JS 引擎，用来控制事件循环**（可以理解成 JS 引擎自己都忙不过来，需要浏览器另开线程协助）。
- 当 JS 引擎执行代码块如 setTimeout 时（也可来自浏览器内核的其它线程，如鼠标点击，AJAX 异步请求等），会将对应任务添加到事件线程中。
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。
- **注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）**。

#### 定时触发器线程

- 传说中的 setTimeout 和 setInterval 所在的线程
- **浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）**

- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
- 注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。

##### setTimeout 和 setInterval 区别

- setTimeout: 指定延期后调用函数，每次 setTimeout 计时到后就会去执行，然后执行一段时间后才继续 setTimeout,中间就多了误差，（误差多少与代码的执行时间有关）。

- setInterval：以指定周期调用函数，而 setInterval 则是每次都精确的隔一段时间推入一个事件（但是，事件的执行时间不一定就不准确，还有可能是这个事件还没执行完毕，下一个事件就来了）

##### setInterval 存在的一些问题：

JavaScript 中使用 setInterval 开启轮询。定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。而 javascript 引擎对这个问题的解决是：
当使用 setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。
但是，这样会导致两个问题：

1. 某些间隔被跳过；
2. 多个定时器的代码执行之间的间隔可能比预期的小

#### 异步 http 请求线程

- 在 XMLHttpRequest 在连接后是通过浏览器新型一个线程请求
- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 JavaScript 引擎执行

### 渲染进程中各线程之间的关系

#### GUI 渲染线程与 JS 引擎线程互斥

由于 JavaScript 是可操作 DOM 的，如果在修改这些元素属性同时渲染界面（即 JS 线程和 GUI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此，为了防止渲染出现不可预期的结果，浏览器就设置了互斥的关系，当 JS 引擎执行时 GUI 线程会被挂起。GUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行。

#### JS 阻塞页面加载

从上述的互斥关系，可以推导出，JS 如果执行时间过长就会阻塞页面。

如果 JS 运算持续占用主线程，此时就算 GUI 有更新，也会被保存在队列中，要等到 JS 引擎空闲后执行。页面就没法得到及时的更新，就会变卡

所以，要尽量避免 JS 执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

#### css 加载不会阻塞 DOM 树解析， 但会阻塞 render 树渲染

对于一个 HTML 文档来说，不管是内联还是外链的 css，都会阻碍后续的 dom 渲染，但是不会阻碍后续 dom 的解析。

因为你加载 css 的时候，可能会修改下面 DOM 节点的样式，如果 css 加载不阻塞 render 树渲染的话，那么当 css 加载完之后，render 树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗

所以干脆把 DOM 树的结构先解析完，把可以做的工作做完，然后等 css 加载完之后，在根据最终的样式来渲染 render 树，这种做法确实对性能好一点。

#### WebWorker

HTML5 则提出了 web Worker 标准，表示 JavaScript 允许有多个线程，但是子线程完全受主线程的控制。

Web Worker 的作用，**就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。**等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。

**JS 引擎是单线程的，这一点的本质仍然未改变，Worker 可以理解是浏览器给 JS 引擎开的外挂，专门用来解决那些大量计算问题。**

### 浏览器渲染流程

##### 1. 构建 DOM 树

浏览器将 HTML 解析成树形结构的 DOM 树，一般来说，这个过程发生在页面初次加载，或页面 JavaScript 修改了节点结构的时候。

##### 2. 构建渲染 render 树

浏览器将 CSS 解析成树形结构的 CSSOM 树，再和 DOM 树合并成渲染树。

##### 3. 布局（Layout）

浏览器根据渲染树所体现的节点、各个节点的 CSS 定义以及它们的从属关系，计算出每个节点在屏幕中的位置。Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为**回流（Reflow）**。

##### 4. 绘制（Paint）

遍历渲染树，调用渲染器的 paint() 方法在屏幕上绘制出节点内容，本质上是一个像素填充的过程。这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为**重绘**（Repaint）。实际上，绘制过程是在多个层上完成的，这些层我们称为渲染层（RenderLayer）。

##### 5. 渲染层合成（Composite）

多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过 GPU 展示到屏幕上

#### load 事件与 DOMContentLoaded 事件的先后顺序

onload: 页面上所有的 DOM，样式表，脚本，图片都已经加载完成了。（渲染完毕了）

DomContentLoaded:仅当 DOM 加载完成，不包括样式表，图片。

DOMContentLoaded 先于 load

#### 什么是渲染层合成

在上面渲染流程的最后一步就提到了渲染层合成，这是一个相对复杂的浏览器特性。

在 DOM 树中每个节点都会对应一个渲染对象（RenderObject），当它们的渲染对象处于相同的坐标空间（z 轴空间）时，就会形成一个 RenderLayers，也就是渲染层。渲染层将保证页面元素以正确的顺序堆叠，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示

从浏览器的渲染过程中我们知道，页面 HTML 会被解析成 DOM 树，每个 HTML 元素对应了树结构上的一个 node 节点。而从 DOM 树转化到一个个的渲染层，并最终执行合并、绘制的过程，中间其实还存在一些过渡的数据结构，它们记录了 DOM 树到屏幕图形的转化原理，其本质也就是树结构到层结构的演化。

![pic](http://cdn.bianyc.xyz/composition.png)

> 某些特殊的 RenderLayer 会被认为是复合层（CompositingLayer ），复合层拥有单独的 GraphicsLayer，而其他不是复合层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。
> 而每个 GraphicsLayer（复合层单独拥有的图层） 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后显示到屏幕上。

翻译成人话：
，与 RenderObject 转换成 RenderLayer 一样，浏览器也是根据“某些规则”，选中一些特殊的 RenderLayer 节点（天选之子），这些节点将被称为 CompositingLayer Layers，Compositing Layers 与其他的普通节点不一样的是他们拥有自己的 GraphicsLayer，而那些没有被选中的节点，会和父层公用一个 GraphicsLayer。

每个 GraphicsLayer 都拥有 GraphicsContext，GraphicsContext 输出的位图会作为纹理上传到 GPU 中。

#### 复合层（CompositingLayer）

**满足某些特殊条件的渲染层，会被浏览器自动提升为复合层。复合层拥有单独的 GraphicsLayer，而其他不是复合层的渲染层，则和其第一个拥有 GraphicsLayer 的父层共用一个。**
那么一个渲染层满足哪些特殊条件时，才能被提升为复合层呢？元素变成一个复合图层，就是传说中的硬件加速技术。这里列举了一些常见的情况：

- 3D transforms：translate3d、translateZ 等

- video、canvas、iframe 等元素

- 通过 Element.animate() 实现的 opacity 动画转换

- 通过 СSS 动画实现的 opacity 动画转换

- position: fixed

- 具有 will-change 属性。一般配合 opacity 与 translate 使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）

- 对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition

#### 复合层的优点

**一般一个元素开启硬件加速后会变成复合层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。**

#### 硬件加速时请使用 index

使用硬件加速时，尽可能的使用 index,防止浏览器默认给后续的元素创建复合层渲染
具体的原理是：

> webkit CSS3 中，如果这个元素添加了硬件加速，并且 index 层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且 position 属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能

简单点理解，可以认为是一个**隐式合成**的概念：如果 a 是一个复合层，而且 b 在 a 上面，那么 b 也会被隐式转为一个复合图层，这点需要特别注意

#### 层爆炸

由于某些原因可能导致产生大量不在预期内的复合层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为复合层的元素因为某些不当操作成为了复合层）。解决层爆炸的问题，最佳方案是**打破 overlap 的条件，也就是说让其他元素不要和复合层元素重叠**。

简单直接的方式：使用 3D 硬件加速提升动画性能时，最好给元素增加一个 z-index 属性，人为干扰合成的排序，可以有效减少 chrome 创建不必要的复合层，提升渲染性能，移动端优化效果尤为明显。

#### 基于复合层的性能优化点

1. 提升动画效果的元素

   复合层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为复合层。 提升复合层的最好方式是使用 CSS 的 will-change 属性。从上一节复合层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为复合层。

2. 使用 transform 或者 opacity 来实现动画效果
   这样只需要做复合层的合并就好了。
   上文提到 transform 和 opacity 属性不会引发 layout 和 paint，值得注意的是，只有元素提升到复合层后才不会引发，普通元素修改 transform 和 opacity 还是会引发的。

3. 减少绘制区域

   对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航 header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘。而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的复合层。减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。

### 参考文章

[浏览器渲染机制](https://segmentfault.com/a/1190000014018604)
[浏览器层合成与页面渲染优化](https://juejin.cn/post/6844903966573068301)
