### React 性能优化

渲染列表时加 Key
自定义事件、DOM 事件及时销毁
合理使用异步组件
减少函数 bind this 的次数
合理使用 shouldComponentUpdate、PureComponent 和 memo
合理使用 ImmutableJS
webpack 层面优化
前端通用是能优化，如图片懒加载
使用 SSR

### React 和原生事件的执行顺序是什么？可以混用吗？

React 的所有事件都通过 document 进行统一分发。当真实 Dom 触发事件后冒泡到 document 后才会对 React 事件进行处理。所以原生的事件会先执行，然后执行 React 合成事件，最后执行真正在 document 上挂载的事件 React 事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation 方法，则会导致其他 React 事件失效。因为所有元素的事件将无法冒泡到 document 上，导致所有的 React 事件都将无法被触发。。

### hoc 实现

属性代理
函数返回一个我们自己定义的组件，然后在 render 中返回要包裹的组件，这样我们就可以代理所有传入的 props，并且决定如何渲染，实际上 ，这种方式生成的高阶组件就是原组件的父组件，上面的函数 visible 就是一个 HOC 属性代理的实现方式。function proxyHOC(WrappedComponent) { return class extends Component { render() { return <WrappedComponent {...this.props} />; } }}

1.  对比原生组件增强的项：
2.  可操作所有传入的 props
3.  可操作组件的生命周期
4.  可操作组件的 static 方法
5.  获取 refs

反向继承返回一个组件，继承原组件，在 render 中调用原组件的 render。由于继承了原组件，能通过 this 访问到原组件的 生命周期、props、state、render 等，相比属性代理它能操作更多的属性。

```javascript
function inheritHOC(WrappedComponent) {
  return class extends WrappedComponent {
    render() {
      return super.render();
    }
  };
}
```

对比原生组件增强的项：可操作所有传入的 props 可操作组件的生命周期可操作组件的 static 方法获取 refs 可操作 state
