### setState 传递对象和函数有什么区别？如何选择

#### 对象式的 setState

1. 语法：setState(stateChange, [callback])
   （1）stateChange 为状态改变对象(该对象可以体现出状态的更改)
   （2）callback 是可选的回调函数, 它在状态更新完毕、界面也更新后(render 调用后)才被调用
2. 注意点
   setState 是一个同步的方法，但是 setState 引起 React 后续更新状态的动作是异步的

```js
state = { count: 0 };
this.setState({ count: count + 1 });
console.log(this.state.count);
```

#### 函数式的 setState

1. 语法：setState(updater, [callback])
   （1）updater 为返回 stateChange 对象的函数。
   （2）updater 可以接收到 state 和 props。
   （3）callback 是可选的回调函数, 它在状态更新、界面也更新后(render 调用后)才被调用。

```js
<Demo name="tom" />; // 从外部传数据进去
this.setState((state, props) => {
  console.log(state, props);
  return { count: state.count + 1 };
});
```

1. 对象式的 setState 是函数式的 setState 的简写方式(语法糖)
2. 如果新状态不依赖于原状态 ===> 使用对象方式
3. 如果新状态依赖于原状态 ===> 使用函数方式
4. 如果需要在 setState()执行后获取最新的状态数据,
   要在第二个 callback 函数中读取

### 讲讲 render 的渲染流程？(React 的渲染机制——Reconciliation 过程)

https://zhuanlan.zhihu.com/p/444996907

react 的核心可以用 ui=fn(state)来表示，更详细可以用

```js
const state = reconcile(update);
const UI = commit(state);
```

上面的 fn 可以分为如下一个部分：

1. Scheduler（调度器）： 排序优先级，让优先级高的任务先进行 reconcile。
2. Reconciler（协调器）： 找出哪些节点发生了改变，并打上不同的 Flags（旧版本 react 叫 Tag）。
3. Renderer（渲染器）： 将 Reconciler 中打好标签的节点渲染到视图上。

那这些模块是怎么配合工作的呢：

1. 首先 jsx 经过 babel 的 ast 词法解析之后编程 React.createElement，React.createElement 函数执行之后就是 jsx 对象，也被称为 virtual-dom。

1. **不管是在首次渲染还是更新状态的时候，这些渲染的任务都会经过 Scheduler 的调度**，
1. **Scheduler 会根据任务的优先级来决定将哪些任务优先进入 render 阶段**，比如用户触发的更新优先级非常高，如果当前正在进行一个比较耗时的任务，则这个任务就会被用户触发的更新打断，在 Scheduler 中初始化任务的时候会计算一个过期时间，不同类型的任务过期时间不同，优先级越高的任务，过期时间越短，优先级越低的任务，过期时间越长。
1. 在最新的 Lane 模型中，则可以更加细粒度的根据二进制 1 的位置，来决定任务的优先级，通过二进制的融合和相交，判断任务的优先级是否足够在此次 render 的渲染。**Scheduler 会分配一个时间片给需要渲染的任务**，如果是一个非常耗时的任务，如果在一个时间片之内没有执行完成，则会从当前渲染到的 Fiber 节点暂停计算，让出执行权给浏览器，在之后浏览器空闲的时候从之前暂停的那个 Fiber 节点继续后面的计算，这个计算的过程就是计算 Fiber 的差异，并标记副作用。详细可阅读往期课件和视频讲解，往期文章在底部。

在 render 阶段：

render 阶段的主角是 Reconciler，在 mount 阶段和 update 阶段，它会比较 jsx 和当前 Fiber 节点的差异（diff 算法指的就是这个比较的过程），将带有副作用的 Fiber 节点标记出来，这些副作用有 Placement（插入）、Update（更新）、Deletetion（删除）等，而这些带有副作用 Fiber 节点会加入一条 EffectList 中，在 commit 阶段就会遍历这条 EffectList，处理相应的副作用，并且应用到真实节点上。而 Scheduler 和 Reconciler 都是在内存中工作的，所以他们不影响最后的呈现。

在 commit 阶段：会遍历 EffectList，处理相应的生命周期，将这些副作用应用到真实节点，这个过程会对应不同的渲染器，在浏览器的环境中就是 react-dom，在 canvas 或者 svg 中就是 react-art 等。

另外我们也可以从首次渲染和更新的时候看在 render 和 commit 这两个子阶段是如果工作的：

mount 时：

在 render 阶段会根据 jsx 对象构建新的 workInProgressFiber 树，不太了解 Fiber 双缓存的可以查看往期文章 Fiber 架构，然后将相应的 fiber 节点标记为 Placement，表示这个 fiber 节点需要被插入到 dom 树中，然后会这些带有副作用的 fiber 节点加入一条叫做 Effect List 的链表中。

在 commit 阶段会遍历 render 阶段形成的 Effect List，执行链表上相应 fiber 节点的副作用，比如 Placement 插入，或者执行 Passive（useEffect 的副作用）。将这些副作用应用到真实节点上。

update 时：

在 render 阶段会根据最新状态的 jsx 对象对比 current Fiber，再构建新的 workInProgressFiber 树，这个对比的过程就是 diff 算法，diff 算法又分成单节点的对比和多节点的对比，不太清楚的同学参见之前的文章 diff 算法 ，对比的过程中同样会经历收集副作用的过程，也就是将对比出来的差异标记出来，加入 Effect List 中，这些对比出来的副作用例如：Placement（插入）、Update(更新)、Deletion（删除）等。

在 commit 阶段同样会遍历 Effect List，将这些 fiber 节点上的副作用应用到真实节点上

### react 是 mvvm 还是 mvc

vm 是 view mode 的意思。所以 mvvm 框架是要有一个 vm 对象，来映射 view。也就是 vm 对象的属性发生改变的时候，对应的视图部分会相对应更新。比较经典的有 knockoutjs，里面比较关键的概念就是 view model，compute，view 模板等。对的，vue 中其实是有不少它的影子。然后来看看 react，它没有纯粹意义上的 vm 对象，它有的是属性和状态。用属性和状态去映射视图。那么属性和状态和 vm 有什么区别呢？个人认为，vm 对象不管你值是从外部传进来的还是自己内部定义的，最后都一视同仁。很多情况还有双向绑定的机制，可能早期的 flex，让人感到惊艳吧，后面的 mvvm 框架都有双向绑定的概念。而 react，强调的是属性不可变性，单向数据流。内部的状态内部自己控制。这样的设计可能从设计上更复杂一些，但是从使用上变得更确定，更清晰了。如果 react 用的比较熟，给合适的组件管理合适的状态，做好状态的合理分层，会大大降低应用复杂度。然后，redux 有个很先进的概念叫容器组件和纯展示组件，如果领悟了这个设计思路的话，把复杂的东西集中到少部分组件中，大部分组件就变成纯展示组件，进一步降低应用复杂性

### React 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化

1. 使用 shouldComponentUpdate 规避冗余的更新逻辑

2. PureComponent + Immutable.js
   https://segmentfault.com/a/1190000010438089

   > 在传入组件的 props 和 state 只有一层时，我们可以直接使用 React.PureComponent，它会自动帮我们进行浅比较(shallow-compare)，从而控制 shouldComponentUpdate 的返回值。
   > 但是，当传入 props 或 state 不止一层，或者未 array 和 object 时，浅比较(shallow-compare)就失效了。当然我们也可以在 shouldComponentUpdate() 中使用使用 deepCopy 和 deepCompare 来避免无必要的 render()，但 deepCopy 和 deepCompare 一般都是非常耗性能的。这个时候我们就需要 Immutable。

3. React.memo 与 useMemo
   React.memo 控制是否需要重渲染一个组件，而 useMemo 控制的则是是否需要重复执行某一段逻辑。

### react 最新版本解决了什么问题 加了哪些东西

###### React 16.x 的三大新特性 Time Slicing, Suspense，hooks

1. Time Slicing（解决 CPU 速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得 react 能在性能极其差的机器跑时，仍然保持有良好的性能
2. Suspense （解决网络 IO 问题）和 lazy 配合，实现异步加载组件。 能暂停当前组件的渲染, 当完成某件事以后再继续渲染，解决从 react 出生到现在都存在的「异步副作用」的问题，而且解决得非
   的优雅，使用的是「异步但是同步的写法」，我个人认为，这是最好的解决异步问题的方式
3. 此外，还提供了一个内置函数 componentDidCatch，当有错误发生时, 我们可以友好地展示 fallback 组件；可以捕捉到它的子元素（包括嵌套子元素）抛出的异常；可以复用错误组件。

### 为什么需要 React-hooks

1. 函数组件从设计思想上来看，更加契合 React 的理念。
2. 告别难以理解的 class
3. **this 和生命周期这两个痛点**
4. 解决业务逻辑难以拆分的问题

###### 聊聊 hooks

1. 加入 hooks，让 React 函数式组件更加灵活
   hooks 之前，React 存在很多问题
   - 在组件间复用状态逻辑很难
   - 复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。
   - class 组件的 this 指向问题
   - 难以记忆的生命周期
2. hooks 很好的解决了上述问题，hooks 提供了很多方法

- useState 返回有状态值，以及更新这个状态值的函数
- useEffect 接受包含命令式，可能有副作用代码的函数。
- useContext 接受上下文对象（从 React.createContext 返回的值）并返回当前上下文值，
- useReducer useState 的替代方案。接受类型为(state，action) => newState 的 reducer，并返回与 dispatch 方法配对的当前状态。
- useCallback 返回一个回忆的 memoized 版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性
- useMemo 纯的一个记忆函数
- useRef 返回一个可变的 ref 对象，其.current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。
- useImperativeMethods 自定义使用 ref 时公开给父组件的实例值
- useMutationEffect 更新兄弟组件之前，它在 React 执行其 DOM 改变的同一阶段同步触发
- useLayoutEffect DOM 改变后同步触发。使用它来从 DOM 读取布局并同步重新渲染

### react 合成事件了解吗？这些事件处理函数最终挂载到了哪？

（react 中都是合成事件，无论冒泡和捕获，对应于原生事件都是冒泡）

### React 事件绑定原理

[参考链接](https://github.com/lgwebdream/FE-Interview/issues/23)
[react 合成事件](./react合成事件.md)
React 的事件系统沿袭了事件委托的思想， 在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时，React 将事件内容封装并交由真正的处理函数运行。
这样的方式不仅**减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件**。

另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。

#### React 事件系统的设计动机是什么？

1. 首先一定要说的，也是 React 官方说明过的一点是：合成事件符合 W3C 规范，**在底层抹平了不同浏览器的差异，在上层面向开发者暴露统一的、稳定的、与 DOM 原生事件相同的事件接口**。开发者们由此便不必再关注烦琐的底层兼容问题，可以专注于业务逻辑的开发。

2. 此外，**自研事件系统使 React 牢牢把握住了事件处理的主动权**：比如说它想在事件系统中处理 Fiber 相关的优先级概念，或者想把多个事件揉成一个事件（比如 onChange 事件），原生 DOM 会帮它做吗？不会，因为原生讲究的就是个通用性。而 React 想要的则是“量体裁衣”，通过自研事件系统，React 能够从很大程度上干预事件的表现，使其符合自身的需求。

3. 事件注册

- 组件装载 / 更新。
- 通过 lastProps、nextProps 判断是否新增、删除事件分别调用事件注册、卸载方法。
- 调用 EventPluginHub 的 enqueuePutListener 进行事件存储
- 获取 document 对象。
- 根据事件名称（如 onClick、onCaptureClick）判断是进行冒泡还是捕获。
- 判断是否存在 addEventListener 方法，否则使用 attachEvent（兼容 IE）。
- 给 document 注册原生事件回调为 dispatchEvent（统一的事件分发机制）

2. 事件触发

- 事件触发，冒泡至 document
- 执行 dispatchEvent
- 创建时间对应的合成事件对象
- 收集事件在**捕获阶段**所波及的回调函数和对应的节点实例
- 收集事件在**冒泡阶段**所波及的回调函数和对应的节点实例
- 将前两步收集来的回调按顺序执行

3. 事件回调的收集与执行

首先我们来看收集过程对应的源码逻辑，这部分逻辑在 traverseTwoPhase 函数中，源码如下（解析在注释里）：

```javascript
function traverseTwoPhase(inst, fn, arg) {
  // 定义一个 path 数组
  var path = [];
  while (inst) {
    // 将当前节点收集进 path 数组
    path.push(inst);
    // 向上收集 tag===HostComponent 的父节点
    inst = getParent(inst);
  }
  var i;
  // 从后往前，收集 path 数组中会参与捕获过程的节点与对应回调
  for (i = path.length; i-- > 0; ) {
    fn(path[i], "captured", arg);
  }
  // 从前往后，收集 path 数组中会参与冒泡过程的节点与对应回调
  for (i = 0; i < path.length; i++) {
    fn(path[i], "bubbled", arg);
  }
}
```

- 循环收集符合条件的父节点，存进 path 数组中
- 模拟事件在捕获阶段的传播顺序，收集捕获阶段相关的节点实例与回调函数
- 模拟事件在冒泡阶段的传播顺序，收集冒泡阶段相关的节点实例与回调函数

### react 组件通信方式

1. 父组件向子组件通信
   父组件通过 props 向子组件传递需要的信息。

2. 子组件向父组件通信
   props+回调的方式。
3. 跨级组件通信
   即父组件向子组件的子组件通信，向更深层子组件通信。

4. 使用 props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递 props，增加了复杂度，并且这些 props 并不是中间组件自己需要的。
5. 使用 context，context 相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用 context 实现。

6. 非嵌套关系的组件通信

   - 可以使用自定义事件通信（发布订阅模式 eventBus）
   - 可以通过 redux 等进行全局状态管理
   - 如果是兄弟组件通信，可以借助**状态提升**，找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。

### Fiber 算法原理， 相比之前的 stack 算法哪些方面做了优化

### react fiber

[react fiber](./fiber.md)

### 介绍 JSX

JSX 是一个 JavaScript 的语法扩展，或者说是一个类似于 XML 的 ECMAScript 语法扩展。

其实 React 本身并不强制使用 JSX。在没有 JSX 的时候，React 实现一个组件依赖于使用 React.createElement 函数。

而 JSX 更像是一种语法糖。

### React key 有什么用

Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。

在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。

此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。

### react 权限路由实现

### react hooks 用过哪些

### react 使用心得

### redux 模板语法的改良(使用装饰器)

### react15 和 react16 更新机制的差异

### 为什么 react16 架构升级后就能中断更新,根据什么决定是否中断

### react 源码看过哪些？

### react 中调和的部分是在哪个包?有看过实现吗

### react 为什么要引入 hooks,解决了哪些问题

react 函数组件和类组件触发更新的方式有哪些

react 的强制更新有了解吗

react 在一秒内点击按钮多次(+1),如何获取最后一次的新状态

react-router 权限路由写一下

react diff 算法如何实现的,比对复杂度是多少

### 如何使用 react-dnd 完成拖放的,说下主要 API

## 如何阻止 react 事件冒泡

1. 在**没有涉及到原生事件注册**只有 react 事件时，用**e.stopPropagation()**阻止冒泡
1. 当用 document.addEventListener 注册了原生的事件后，用 e.stopPropagation()是不能阻止与 document 之间的冒泡，这时候需要用到 e.nativeEvent.stopImmediatePropagation()方法

### 大数据量场景前端怎么处理,让页面展示尽可能流畅

从数据上处理：

1. 分页分表，比如前端可以把数据分页展示，后端也分段吐数据从渲染上解决：
2. 异步渲染，比如进入页面先不渲染，然后加载好页面再渲染。
3. 局部渲染：只渲染目前可见区域的数据，再渲染次屏数据。
4. 还有性能瓶颈，可以考虑 web worker 做压缩和解码，也可以考虑离屏 canvas 做预渲染。
5. 减少网络耗时：压缩数据，gzip 等。

### react 中遇到的坑,怎么解决的

### 选择 hooks 的优点

### hooks 的限制

React Hooks 的限制主要有两条：

不要在循环、条件或嵌套函数中调用 Hook；

在 React 的函数组件中调用 Hook。

### 什么时候用类组件

### useEffect 和 useLayoutEffect

useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景，而 LayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 LayoutEffect 做计算量较大的耗时任务从而造成阻塞。

### MVC

MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范

Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据
View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的
Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据

### 谈一谈 MVVM

MVVM 是 Model-View-ViewModel 的简写。它本质上就是 MVC （Model-View- Controller）的改进版。即模型-视图-视图模型。

1. model 指的是后端传递的数据。
2. view 指的是所看到的页面。
3. viewmodel mvvm 模式的核心，它是连接 view 和 model 的桥梁。它有两个方向：
   - 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。
   - 二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。

总结：在 MVVM 的框架下视图和模型是不能直接通信的。它们通过 ViewModel 来通信，ViewModel 通常要实现一个 observer 观察者，当数据发生变化，ViewModel 能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel 也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且 MVVM 中的 View 和 ViewModel 可以互相通信。

#### React 是 MVVM 吗

MVVM 一个最显著的特征：双向绑定。

React 没有这个。

React 是一个单向数据流的库，状态驱动视图。

State --> View --> New State --> New View

## 说说 useRef

1. useRef 返回一个可变的 ref 对象，其.current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。

2. useRef 不仅仅是用来管理 DOM ref 的，它还相当于 this , 可以存放任何变量.本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子

3. useRef 可以很好的解决闭包带来的不方便性. 你可以在各种库中看到它的身影, 比如 react-use 中的 useInterval , usePrevious ……

4. 当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。

5. 和 createRef 的区别：
   createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用。
