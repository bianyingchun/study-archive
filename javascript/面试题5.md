## 事件冒泡和事件捕获的区别、react 中的冒泡和捕获呢

冒泡指的是：当给某个目标元素绑定了事件之后，这个事件会依次在它的父级元素中被触发(当然前提是这个父级元素也有这个同名称的事件，比如子元素和父元素都绑定了 click 事件就触发父元素的 click)。

捕获则是从上层向下层传递，与冒泡相反。
**（react 中都是合成事件，无论冒泡和捕获，对应于原生事件都是冒泡）**

## onmouseenter 和 onmouseover 的区别

onmouseover/onmouseout 触发子元素的事件时，子元素通过事件冒泡触发父元素对应的事件； 可以通过阻止冒泡 stopPropagation() 避免父元素事件触发；
onmouseenter/onmouseleave 触发子元素事件时，不会触发父元素对应的事件，内部已经进行了阻止事件冒泡的处理；
结论： 一般我们会用 onmouseenter / onmouseleave 事件；

## 所有的事件都有冒泡吗？

并不是所有的事件都有冒泡的，例如以下事件就没有：

- onblur
- onfocus
- onmouseenter
- onmouseleave

## typeof 和 instanceof 的区别

typeof 表示是对某个变量类型的检测，基本数据类型除了 null 都能正常的显示为对应的类型，引用类型除了函数会显示为'function'，其它都显示为 object。

而 instanceof 它主要是用于检测某个构造函数的原型对象在不在某个对象的原型链上。

## 为什么typeof可以检测类型，有没有更好的方法
typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断number, string, object, boolean, function, undefined, symbol 这七种类型，这种判断能帮助我们搞定一些问题，js在底层存储变量的时候会在变量的机器码的低位1-3位存储其类型信息(000：对象，010：浮点数，100：字符串，110：布尔，1：整数)，但是null所有机器码均为0，直接被当做了对象来看待。

那么有没有更好的办法区分类型呢，一般使用Object.prototype.toString.call()

## typeof 为什么对 null 错误的显示

这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。

## 词法环境

## 自定义事件

https://blog.csdn.net/AIWWY/article/details/120982861
https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent

1. createEvent initUIEvent, dispatchEvent 已被 W3C 标准弃用，浏览还支持

```js
//选择dom节点
var dom = document.getElementById("");
//dom节点上绑定自定义事件abc
dom.addEventListener(
  "abc",
  function (event) {
    console.log(event);
  },
  false
);
// 创建事件
var evt = document.createEvent("UIEvents"); //参数可以为Event,"UIEvents", "MouseEvents", "MutationEvents", 或者 "HTMLEvents"
// 初始化事件为自定abc事件
evt.initUIEvent("abc", false, false);
// 触发事件
dom.dispatchEvent(evt);
```

2. new Event(eventName,eventInit)

```js
var evt = new Event("look", { bubbles: true, cancelable: false });
var dom = document;
dom.addEventListener(
  "look",
  function (event) {
    console.log(event);
  },
  false
);
document.dispatchEvent(evt);
```

3. CustomEvent(eventName,eventInit)可以传自定义参数 detail

```js
var evt = new CustomEvent("cat", { detail: { hazcheeseburger: true } });
var dom = document;
dom.addEventListener(
  "cat",
  function (event) {
    console.log(event);
  },
  false
);
dom.dispatchEvent(evt);
```

## 为什么说 script 标签会阻塞页面的渲染呢？渲染线程和 js 引擎线程不是分开的吗？

#### GUI 渲染线程与 JS 引擎线程互斥

由于 JavaScript 是可操作 DOM 的，如果在修改这些元素属性同时渲染界面（即 JS 线程和 GUI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此，为了防止渲染出现不可预期的结果，浏览器就设置了互斥的关系，当 JS 引擎执行时 GUI 线程会被挂起。GUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行。

##### JS 阻塞页面加载

从上述的互斥关系，可以推导出，JS 如果执行时间过长就会阻塞页面。

如果 JS 运算持续占用主线程，此时就算 GUI 有更新，也会被保存在队列中，要等到 JS 引擎空闲后执行。页面就没法得到及时的更新，就会变卡

所以，要尽量避免 JS 执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

## 正则表达式

之前有用过用正则去除输入框的首尾空格，正则表达式为：

var trimReg = /(^\s+)|(\s+$)/g；
不过后来由于Vue中有一个修饰符.trim，使用起来更方便(如v-model.trim="msg")就用这种方式多一些；再或者也可以用ES10新出的trimStart和trimEnd来去除首尾空格。
用于校验手机号的正则：
var phoneReg = /^1[3456789]\d{9}$/g。
用正则写一个根据 name 获取 cookie 中的值的方法：

```js
function getCookie(name) {
  var match = document.cookie.match(new RegExp("(^| )" + name + "=([^;]*)"));
  if (match) return unescape(match[2]);
}
```

## 对象 flatten

实现一个 flatten 函数，实现如下的转换功能

```js
const obj = {
  a: 1,
  b: [1, 2, { c: true }],
  c: { e: 2, f: 3 },
  g: null,
};
// 转换为
let objRes = {
  a: 1,
  "b[0]": 1,
  "b[1]": 2,
  "b[2].c": true,
  "c.e": 2,
  "c.f": 3,
  g: null,
};

function flatten(obj) {
  const res = {};
  function traverse(key, value) {
    // 基础类型
    if (Object(value) !== value) {
      res[key] = value;
    } else if (Array.isArray(value)) {
      value.forEach((item, index) => {
        traverse(`${key}[${index}]`, item);
      });
    } else {
      for (let subKey in value) {
        traverse(`${key ? key + "." : ""}${subKey}`, value[subKey]);
      }
    }
  }
  traverse("", obj);
  return res;
}
```

## require 具体实现原理是什么

require 和 module.exports 干的事情并不复杂，我们先假设有一个全局对象{}，初始情况下是空的，当你 require 某个文件时，就将这个文件拿出来执行，如果这个文件里面存在 module.exports，当运行到这行代码时将 module.exports 的值加入这个对象，键为对应的文件名，最终这个对象就长这样：

```js
{
  "a.js": "hello world",
  "b.js": function add(){},
  "c.js": 2,
  "d.js": { num: 2 }
}
```

当你再次 require 某个文件时，如果这个对象里面有对应的值，就直接返回给你，如果没有就重复前面的步骤，执行目标文件，然后将它的 module.exports 加入这个全局对象，并返回给调用者。这个全局对象其实就是我们经常听说的缓存。所以 require 和 module.exports 并没有什么黑魔法，就只是运行并获取目标文件的值，然后加入缓存，用的时候拿出来用就行。

## 项目中内存泄漏的场景

https://blog.csdn.net/qq_38110572/article/details/121227359

1. 闭包
   闭包可以维持函数内局部变量，使其得不到释放。
2. 意外使用的全局变量
3. 未清理的 DOM 元素引用
4. 被遗忘的定时器或者回调

## setTimeout 为什么会造成内存泄露？如何防止 setTimeout 内存泄露？清除定时器为什么就不会有内存泄露？

定时器 setInterval 或者 setTimeout 在不需要使用的时候，没有被 clear，导致定时器的回调函数及其内部依赖的变量都不能被回收，这就会造成内存泄漏。
**解决方式：**当不需要 interval 或者 timeout 的时候，调用 clearInterval 或者 clearTimeout

## 怎样避免内存泄露

1. 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；

2. 注意程序逻辑，避免“死循环”之类的 ；

3. 避免创建过多的对象 原则：不用了的东西要及时归还。

## cookies、sessionStorage、localStorage 的区别

1. 一、存储的时间有效期不同

1、cookie 的有效期是可以设置的，默认的情况下是关闭浏览器后失效

2、sessionStorage 的有效期是仅保持在当前页面，关闭当前会话页或者浏览器后就会失效

3、localStorage 的有效期是在不进行手动删除的情况下是一直有效的

2. 存储的大小不同

1、cookie 的存储是 4kb 左右，存储量较小，一般页面最多存储 20 条左右信息

2、localStorage 和 sessionStorage 的存储容量是 5Mb(官方介绍，可能和浏览器有部分差异性)

3. 与服务端的通信

1、cookie 会参与到与服务端的通信中，一般会携带在 http 请求的头部中，例如一些关键密匙验证等。
2、localStorage 和 sessionStorage 是单纯的前端存储，不参与与服务端的通信

## 0.1 + 0.2 == 0.3 ？

进制转换 ：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环 ，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。
对阶运算 ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0 舍 1 入），尾数位移时可能会发生数丢失的情况，影响精度。

使用 Number.EPSILON 误差范围。

```js
function isEqual(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}

console.log(isEqual(0.1 + 0.2, 0.3)); // true
```

## 事件流

事件流是网页元素接收事件的顺序，"DOM2 级事件"规定的事件流包括三个阶段：
**事件捕获阶段、处于目标阶段、事件冒泡阶段。**
首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。
虽然捕获阶段在规范中规定不允许响应事件，但是实际上还是会执行，所以有两次机会获取到目标对象。

```js
var EventUtil = {
  addHandler: function (el, type, handler) {
    if (el.addEventListener) {
      el.addEventListener(type, handler, false);
    } else if (el.attachEvent) {
      el.attachEvent("on" + type, handler);
    } else {
      el["on" + type] = handler;
    }
  },
  removeHandler: function (el, type, handler) {
    if (el.removeEventListener) {
      el.removeEventListener(type, handler, false);
    } else if (el.detachEvent) {
      el.detachEvent("on" + type, handler);
    } else {
      el["on" + type] = null;
    }
  },
  getEvent: function (e) {
    return e ? e : window.event;
  },
  getTarget: function (e) {
    return e.target ? e.target : e.srcElement;
  },
  preventDefault: function (e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
  },
  stopPropagation: function (e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.cancelBubble = true;
    }
  },
};
```

### 事件是如何实现的？

基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。
比如点击按钮，这是个事件（Event），而负责处理事件的代码段通常被称为事件处理程序（Event Handler），也就是「启动对话框的显示」这个动作。
在 Web 端，我们常见的就是 DOM 事件：

DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。
DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件
DOM3 级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件,键盘事件

### symbol 的用处

1. 用来表示一个独一无二的变量防止命名冲突
2. 主要用来提供遍历接口，布置了  symbol.iterator  的对象才可以使用  for···of  循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。（快捷方式：generate）
   1. 数组、类数组、map、set
      https://blog.csdn.net/margin_0px/article/details/82971545
3. Symbol.for() 方法创建的的 symbol 会被放入一个全局 symbol 注册表中。Symbol.for() 并不是每次都会创建一个新的 symbol，它会首先检查给定的 key 是否已经在注册表中了。假如是，则会直接返回上次存储的那个。否则，它会再新建一个。

```js
Symbol.for("foo"); // 创建一个 symbol 并放入 symbol 注册表中，键为 "foo"
Symbol.for("foo"); // 从 symbol 注册表中读取键为"foo"的 symbol
Symbol.for("bar") === Symbol.for("bar"); // true，证明了上面说的
Symbol("bar") === Symbol("bar"); // false，Symbol() 函数每次都会返回新的一个 symbol

let obj = {
  data: ["hello", "world"],
  [Symbol.iterator]() {
    const self = this;
    let index = 0;
    return {
      next() {
        if (index < self.data.length) {
          return {
            value: self.data[index++],
            done: false,
          };
        } else {
          return { value: undefined, done: true };
        }
      },
    };
  },
};
```

- 用于创建独一无二的值，可做唯一 key 用于缓存等场景
- 用于创建类的私有变量,利用 symbol 属性不能被枚举的特性声明作为私有属性
- 用来重置对象的属性，比如 Symbol.toStringTag
- 可实现 Symbol.iterator 迭代器， 让普通对象变为可迭代对象
- 使用 Symbol.for(‘xxx’)获取全局的 symbol 值

## NaN 是什么，用 typeof 会输出什么？

Not a Number，表示非数字，typeof NaN === 'number'

## <script src=’xxx’ ’xxx’/>外部 js 文件先加载还是 onload 先执行，为什么？

onload， onload 表示页面上所有的 DOM，样式表，脚本，图片都已经加载完成了。（渲染完毕了）

DomContentLoaded:仅当 DOM 加载完成，不包括样式表，图片。

DOMContentLoaded 先于 load

## 说说 pwa

[pwa](./pwa.md)

## 变量提升

函数在运行的时候，会首先创建执行上下文，然后将执行上下文入栈，然后当此执行上下文处于栈顶时，开始运行执行上下文。
在创建执行上下文的过程中会做三件事：**创建变量对象，创建作用域链，确定 this 指向**，其中创建变量对象的过程中，首先会为 arguments 创建一个属性，值为 arguments，然后会扫码 function 函数声明，创建一个同名属性，值为函数的引用，接着会扫码 var 变量声明，创建一个同名属性，值为 undefined，这就是变量提升，如果 var 变量与函数同名，则在这个阶段，以函数值为准。

## let/const 声明的变量，是否还会变量提升

let 使得 javascript 具有块级作用域，const与let的唯一区别就是它在声明变量时必须同时初始化变量，且不能修改const声明的变量的值。

暂时性死区：在let声明之前的执行瞬间都被称为暂时性死区TDZ，在此阶段引用的任何后面才声明的变量都会抛出ReferenceError没有定义的错误。

let / const 实际上是存在变量提升的，但是由于暂时性死区的存在使let / const不能在声明之前被使用，这与var的变量提升不太一样。


## es6\es7\es8 新特性

### ES6 新特性

1. let && const
2. 箭头函数
3. Class
4. 解构赋值
5. ...操作符
6. iterable 类型 Set , Map

### ES7 常用新特性

7. Array.prototype.includes
8. Exponentiation Operator(求幂运算) \*\*

### ES8 新特性

1. Object.values/Object.entries
2. String padding(字符串填充)
   let d = str.padStart(5,"a");
3. Async/Await

## 如何判断两个对象相等：Object.is 的实现原理

```js
Object.is(+0, -0); // false
Object.is(NaN, NaN); // true

//polyfill

if (!Object.is) {
  Object.is = function (x, y) {
    if (x === y) {
      // 1/-0 -Infinity
      return x != 0 || 1 / x == 1 / y;
    } else {
      x !== x && y !== y;
    }
  };
}
```

### 帧率计算

```js
function calcFps(debounce = 1000) {
  let lastTime = performance.now();
  let count = 0; // 记录decounce周期内渲染次数
  (function loop() {
    count++;
    const now = performance.now();
    if (now - lastTime > debounce) {
      const fps = Math.round(count / ((now - lastTime) / 1000));
      lastTime = now;
      count = 0;
      console.log("fps:", fps);
    }
    requestAnimationFrame(loop);
  })();
}
calcFps();
```

## js 报错类型

https://blog.csdn.net/fifteen718/article/details/88352308

1. SyntaxError 语法错误
2. ReferenceError 引用错误(要用的变量没找到)
3. TypeError 类型错误(调用不存在的方法)
4. RangeError 第一是数组长度为负数，第二是 Number 对象的方法参数超出范围，以及函数堆栈超过最大值。
5. evalError
6. URIError
   encodeURL()或 decodeURL()但传入了格式错误的 URL 时发生
7. InternalError

## 递归的缺点

1. 递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都需要时间。->效率

2. 递归中很多计算都是重复的，由于其本质是把一个问题分解成两个或者多个小问题，多个小问题存在相互重叠的部分，则存在重复计算，如 fibonacci 斐波那契数列的递归实现。->效率

3. 调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。->性能

## 多页应用如何通信

1. localStorage
   提供事件监听 localStorage 变化
   window.addEventListener("storage", (e) => {
   console.info("localStorage 发生变化：", e)
   })
2. websocket(中介)
   假如我们 pageA 和 pageB 都与服务器建立了 websocket 连接，那么连个页面都可以实时接收服务端发来的消息，也可以实时向服务端发送消息。如果 pageA 更改了数据，那么向服务端发送一条消息或数据，服务端在将这条消息或数据发送给 pageB 即可，这样就简单实现了两个标签页之间的通信。
3. SharedWorker
4. 使用 cookie + setInterval

## 前端页面弹框遮罩禁止页面滚动

1. pc

```js
// 显示弹框时
documentTop = document.scrollingElement.scrollTop;
body.style.position = "fixed";
body.style.top = -documentTop + "px";
// 隐藏弹框时
body.style.position = "static";
body.style.top = "auto";
document.scrollingElement.scrollTop = documentTop;
```
