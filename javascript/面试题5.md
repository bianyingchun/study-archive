## 冒泡和捕获

冒泡指的是：当给某个目标元素绑定了事件之后，这个事件会依次在它的父级元素中被触发(当然前提是这个父级元素也有这个同名称的事件，比如子元素和父元素都绑定了 click 事件就触发父元素的 click)。

捕获则是从上层向下层传递，与冒泡相反。

## onmouseenter 和 onmouseover 的区别

onmouseover/onmouseout 触发子元素的事件时，子元素通过事件冒泡触发父元素对应的事件； 可以通过阻止冒泡 stopPropagation() 避免父元素事件触发；
onmouseenter/onmouseleave 触发子元素事件时，不会触发父元素对应的事件，内部已经进行了阻止事件冒泡的处理；
结论： 一般我们会用 onmouseenter / onmouseleave 事件；

## 所有的事件都有冒泡吗？

并不是所有的事件都有冒泡的，例如以下事件就没有：

- onblur
- onfocus
- onmouseenter
- onmouseleave

## typeof 和 instanceof 的区别

typeof 表示是对某个变量类型的检测，基本数据类型除了 null 都能正常的显示为对应的类型，引用类型除了函数会显示为'function'，其它都显示为 object。

而 instanceof 它主要是用于检测某个构造函数的原型对象在不在某个对象的原型链上。

## typeof 为什么对 null 错误的显示

这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。

## 词法环境

## 自定义事件

https://blog.csdn.net/AIWWY/article/details/120982861
https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent

1. createEvent initUIEvent, dispatchEvent 已被 W3C 标准弃用，浏览还支持

```js
//选择dom节点
var dom = document.getElementById("");
//dom节点上绑定自定义事件abc
dom.addEventListener(
  "abc",
  function (event) {
    console.log(event);
  },
  false
);
// 创建事件
var evt = document.createEvent("UIEvents"); //参数可以为Event,"UIEvents", "MouseEvents", "MutationEvents", 或者 "HTMLEvents"
// 初始化事件为自定abc事件
evt.initUIEvent("abc", false, false);
// 触发事件
dom.dispatchEvent(evt);
```

2. new Event(eventName,eventInit)

```js
var evt = new Event("look", { bubbles: true, cancelable: false });
var dom = document;
dom.addEventListener(
  "look",
  function (event) {
    console.log(event);
  },
  false
);
document.dispatchEvent(evt);
```

3. CustomEvent(eventName,eventInit)可以传自定义参数 detail

```js
var evt = new CustomEvent("cat", { detail: { hazcheeseburger: true } });
var dom = document;
dom.addEventListener(
  "cat",
  function (event) {
    console.log(event);
  },
  false
);
dom.dispatchEvent(evt);
```

## 为什么说 script 标签会阻塞页面的渲染呢？渲染线程和 js 引擎线程不是分开的吗？

#### GUI 渲染线程与 JS 引擎线程互斥

由于 JavaScript 是可操作 DOM 的，如果在修改这些元素属性同时渲染界面（即 JS 线程和 GUI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此，为了防止渲染出现不可预期的结果，浏览器就设置了互斥的关系，当 JS 引擎执行时 GUI 线程会被挂起。GUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行。

##### JS 阻塞页面加载

从上述的互斥关系，可以推导出，JS 如果执行时间过长就会阻塞页面。

如果 JS 运算持续占用主线程，此时就算 GUI 有更新，也会被保存在队列中，要等到 JS 引擎空闲后执行。页面就没法得到及时的更新，就会变卡

所以，要尽量避免 JS 执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

## 正则表达式

之前有用过用正则去除输入框的首尾空格，正则表达式为：

var trimReg = /(^\s+)|(\s+$)/g；
不过后来由于Vue中有一个修饰符.trim，使用起来更方便(如v-model.trim="msg")就用这种方式多一些；再或者也可以用ES10新出的trimStart和trimEnd来去除首尾空格。
用于校验手机号的正则：
var phoneReg = /^1[3456789]\d{9}$/g。
用正则写一个根据 name 获取 cookie 中的值的方法：

```js
function getCookie(name) {
  var match = document.cookie.match(new RegExp("(^| )" + name + "=([^;]*)"));
  if (match) return unescape(match[2]);
}
```

## 对象 flatten

实现一个 flatten 函数，实现如下的转换功能

```js
const obj = {
  a: 1,
  b: [1, 2, { c: true }],
  c: { e: 2, f: 3 },
  g: null,
};
// 转换为
let objRes = {
  a: 1,
  "b[0]": 1,
  "b[1]": 2,
  "b[2].c": true,
  "c.e": 2,
  "c.f": 3,
  g: null,
};

function flatten(obj) {
  const res = {};
  function traverse(key, value) {
    // 基础类型
    if (Object(value) !== value) {
      res[key] = value;
    } else if (Array.isArray(value)) {
      value.forEach((item, index) => {
        traverse(`${key}[${index}]`, item);
      });
    } else {
      for (let subKey in value) {
        traverse(`${key ? key + "." : ""}${subKey}`, value[subKey]);
      }
    }
  }
  traverse("", obj);
  return res;
}
```

## require 具体实现原理是什么

require 和 module.exports 干的事情并不复杂，我们先假设有一个全局对象{}，初始情况下是空的，当你 require 某个文件时，就将这个文件拿出来执行，如果这个文件里面存在 module.exports，当运行到这行代码时将 module.exports 的值加入这个对象，键为对应的文件名，最终这个对象就长这样：

```js
{
  "a.js": "hello world",
  "b.js": function add(){},
  "c.js": 2,
  "d.js": { num: 2 }
}
```

当你再次 require 某个文件时，如果这个对象里面有对应的值，就直接返回给你，如果没有就重复前面的步骤，执行目标文件，然后将它的 module.exports 加入这个全局对象，并返回给调用者。这个全局对象其实就是我们经常听说的缓存。所以 require 和 module.exports 并没有什么黑魔法，就只是运行并获取目标文件的值，然后加入缓存，用的时候拿出来用就行。
