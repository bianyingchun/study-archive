### 手动实现 reduce

```javascript
Array.prototype.myReduce = function (callback, initial) {
  if (!this.length) {
    if (initial !== undefined) {
      return initial;
    } else {
      throw "a empty arr need a initial";
    }
  }
  var prev = initialValue !== undefined ? initialValue : this[0];
  for (let i = 0; i < this.length; i++) {
    prev = fn(prev, this[i]);
  }
  return prev;
};
```

### 面向对象三要素

1. 封装
2. 继承
3. 多态

### 函数中的 this 有几种

1. 作为对象的方法调用
2. 作为普通函数调用
3. 构造函数调用
4. call, apply 调用
5. 箭头函数的 this

### 常用正则表达式

1. 匹配 16 进制颜色值
   var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g; //
2. 匹配日期，如 yyyy-mm-dd 格式 var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/; //
3. 匹配 qq 号 var regex = /^[1-9][0-9]{4,10}$/g; //
4. 手机号码正则 var regex = /^1[34578]\d{9}$/g; //
5. 用户名正则 var regex = /^[a-zA-Z\$][a-za-z0-9_\$]{4,16}$/;
6. ip 地址 var regIp = /^((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}$/;
7. html 标签
   var regHtml =/<\s*\/?\s*[a-zA-z\_]([^>]*?["][^"]*["])_[^>"]_>/g;

### 邮箱验证

```javascript
/^([A-Aa-z0-9_\-\.]+\@([A-Aa-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
```

### 表单可以跨域吗

form 表单是可以跨域的。

浏览器遵从同源策略，限制 ajax 跨域的原因在于 ajax 网络请求是可以携带 cookie 的（通过设置 withCredentials 为 true），比如用户打开了浏览器，登录了 weibo.com，然后又打开了百度首页，这时候百度首页内的 js，向 weibo.com 用 withCredentials 为 true 的 ajax 方式提交一个 post 请求，是会携带浏览器和 weibo.com 之间的 cookie 的，所以浏览器就默认禁止了 ajax 跨域，服务端必须设置 CORS 才可以。

而 form 提交是不会携带 cookie 的，你也没办法设置一个 hidden 的表单项，然后通过 js 拿到其他 domain 的 cookie，因为 cookie 是基于域的，无法访问其他域的 cookie，所以浏览器认为 form 提交到某个域，是无法利用浏览器和这个域之间建立的 cookie 和 cookie 中的 session 的，故而，浏览器没有限制表单提交的跨域问题。

### 搜索中文如何处理

encodeURI / encodeURIComponent

1、escape()不能直接用于 URL 编码，它的真正作用是返回一个字符的 Unicode 编码值。比如"春节"的返回结果是%u6625%u8282，，escape()不对"+"编码 主要用于汉字编码，现在已经不提倡使用。

2、encodeURI()是 Javascript 中真正用来对 URL 编码的函数。 编码整个 url 地址，但对特殊含义的符号"; / ? : @ & = + $ , #"，也不进行编码。对应的解码函数是：decodeURI()。

3、encodeURIComponent() 能编码"; / ? : @ & = + $ , #"这些特殊字符。对应的解码函数是 decodeURIComponent()。

### 中介者模式是什么？

中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信 的各个对象解耦。

### 发布订阅模式和观察着模式的区别

发布订阅模式其实属于广义上的观察者模式
在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件 并作出响应。 而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事 件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布 者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。

### 事件委托是什么？

事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点， 并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上， 由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。使用事件代理我们可 以不必要为每一个子元素都绑定一个监听事件，这样**减少了内存上的消耗**。并且使用事件代理我 们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监 听事件，它所发生的事件会交给父元素中的监听函数来处理。

--

### prototype 和 proto 区别

1. prototype 只有构造函数才有，指向的是当前对象的原型对象，用来实现基于原型的继承与属性的共享。也称为显示原型

2. 所有对象都有 proto,构造函数实例化对象的 proto 指向与构造函数的 prototype 的指向相同，也称为隐式原型。

3. function 是一个特殊对象，除了有 proto 也有 prototype;

### new 操作符具体干了什么呢？如何实现？

1. 首先创建了一个新的空对象
2. 设置原型，将对象的原型设置为函数的 prototype 对象。
3. 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回 这个引用类型的对象。

```javascript
   funciton newOperator(ctor) {
       if(typeof ctor !== 'function'){
           throw 'the first param must be a function'
       }
       const args = Array.prototype.slice.call(arguments,1);
       const obj = {};
       obj.__proto__ = ctor.prototype;
       const result = ctor.apply(obj, args);
       const isObject = typeof result === 'object' && result !== null;
       const isFunction = typeof result === 'function';
       return isObject || isFunction ? result : obj;
   }
```

### 介绍 webp 图片格式

WebP 的优势在于它具有更优的图像数据压缩算法，在拥有肉眼无法识别差异的图像质量前提下，带来更小的图片体积，同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。
webp 转换工具

1. webp-webpack-plugin

https://www.cnblogs.com/ypppt/p/13093313.html
...

### 什么是 Proxy

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

### 什么是 BigInt

一种新的基础类型，用于当整数值大于 Number 数据类型的范围时，使用 Bigint 避免整数溢出，保证计算安全。

### ajax

具体来说，AJAX 包括以下几个步骤。

1. 创建 XMLHttpRequest 对象，也就是创建一个异步调用对象
2. 创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证 信息。3. 设置响应 HTTP 请求状态变化的函数
3. 发送 HTTP 请求
4. 获取异步调用返回的数据 6.使用 JavaScript 和 DOM 实现局部刷新
   一般实现：

```javascript
const promiseAjax = function (data) {
  function formatParams(param) {
    var arr = [];
    for (var name in param) {
      arr.push(
        encodeURIComponent(name) + "=" + encodeURIComponent(param[name])
      );
    }
    arr.push(("v=" + Math.random()).replace(".", ""));
    return arr.join("&");
  }
  if (!data) data = {};
  data.params = data.params || {};

  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();

    if (data.type === "get") {
      data.params = formatParams(data.params); //options.data请求的数据

      xhr.open("GET", data.url + "?" + data.params, true);
      xhr.send(null);
    } else if (options.type == "post") {
      xhr.open("POST", data.url, true);
      xhr.setRequestHeader("Content-type", "application/json");
      xhr.send(data.params);
    }

    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4) {
        if (xhr.status === 200) {
          resolve(xhr.response);
        } else {
          reject(xhr.responseText);
        }
      }
    };
  });
};
```

### 事件流机制

W3c 规定，最先通知 window, 然后是 document ,由上到下依次进入知道最顶层的被触发的元素(目标元素)，这个过程是捕获
之后事件会从目标元素开始，冒泡，自下而上

1. 捕获阶段
2. 目标阶段
3. 冒泡阶段

```javascript
const eventUtil = {
    // 添加一个事件
    addHandle = function (element, type, handle) {
      if (element.addEventListener) {
        element.addEventListener(type, handle, false) /*非IE*/
      } else if (element.attachEvent) {
        element.attachEvent('on' + type, handle); /*IE*/
      } else {
        element[`on${type}`] = handle
      }
    },

    // 给元素删除一个事件
    removeHandle = function (element, type, handle) {
      if (element.removeEventListener) {
        element.removeEventListener(type, handle, false) /*非IE*/
      } else if (element.detachEvent) {
        element.detachEvent('on' + type, handle); /*IE*/
      } else {
        element[`on${type}`] = null;
      }
    },

    // 获取兼容所有浏览器的一个对象
    getEvent: function (event) {
      return event ? event : window.event;
    },

    //获取事件类型
    getType: function (event) { //此项不存在浏览器兼容问题
      return event.type;
    },

    // 事件来自哪个元素
    getTarget: function (event) {
      return event.target || event.srcElement;
    },

    // 阻止事件默认行为
    preventDefault = function (event) {
      if (event.preventDefault) {
        event.preventDefault(); /*非IE*/
      } else {
        event.returnValue = false; /*IE*/
      }
    },

    // 阻止事件冒泡行为
    stopPropagation=function (event) {
      if (event.stopPropagation) {
        event.stopPropagation(); /*非IE*/
      } else {
        event.cancelBubble = true; /*IE*/
      }
    }
  }
```

### 什么是原型

就是当我们创建一个函数的时候，系统就会自动分配一个 prototype 属性，可以用来存储可以让所有实例共享的属性和方法

### 什么是原型链

JavaScript 中所有的对象都是由它的原型对象继承而来。而原型对象自身也是一个对象，它也有自己的原型对象，这样层层上溯，就形成了一个类似链表的结构，这就是原型链

### 原型链继承

利用原型让一个引用类型继承另一个引用类型的属性和方法。
缺点：

1. 包含引用类型的原型属性会被所有实例属性共享，容易造成属性的修改混乱。
2. 在创建子类型的实例时，不能向超类型的构造函数中传递参数。

### 借用构造函数继承

在子类型的构造函数中调用超类型构造函数
优点：可以在子类型构造函数中向超类型构造函数添加参数

缺点：和构造函数模式一样的问题，所有的方法都在构造函数中定义，因此就无法做到函数的复用。而且超类型的原型中定义的方法，对于子类型而言也是不可见的。

### 组合继承

组合继承指的是将原型链和借用构造函数的技术组合到一块。**使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。**这样既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。

优点：组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。而且，instanceof 和 isPropertyOf() 也能够用于识别基于组合继承创建的对象。

缺点：**调用了两次超类的构造函数，导致基类的原型对象中增添了不必要的超类的实例对象中的所有属性**。

```javascript
function SuperType(name) {
  this.name = name;
  this.colors = ["red", "blue", "green"];
}

SuperType.prototype.sayName = function () {
  console.log(this.name);
};

function SubType(name, age) {
  //继承属性
  SuperType.call(this, name);
  this.age = age;
}

//继承方法
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function () {
  console.log(this.age);
};
```

### 原型式继承

原型式继承的主要思路是可以基于已有的对象创建新的对象，同时还不必因此创建自定义类型。

```javascript
function create(proto, options) {
  // 创建一个空对象
  var tmp = {};

  // 让这个新的空对象成为父类对象的实例
  tmp.__proto__ = proto;

  // 传入的方法都挂载到新对象上，新的对象将作为子类对象的原型
  Object.defineProperties(tmp, options);
  return tmp;
}
```

简单来说这个函数的作用就是，传入一个对象，返回一个原型对象为该对象的新对象。

ECMAScript 5 中新增了**Object.create() 方法规范了原型式继承。这个方法接收两个参数，一个是将被用作新对象原型的对象，一个是为新对象定义额外属性的对象（可选）**。

注意第二个参数的格式与 Object.defineProperties() 方法的第二个参数格式相同。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。在第二个参数为空的情况下，该方法与 object() 方法的行为相同。

优点：可以实现基于一个对象的简单继承，不必创建构造函数

缺点：与原型链中提到的缺点相同，一个是传参的问题，一个是属性共享的问题。

### 寄生式组合继承

组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。
寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

```javascript

function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.getName = function() {
    return this.name
}
Person.prototype.getAge = function() {
    return this.age;
}

function Student(name, age, grade) {
    // 构造函数继承
    Person.call(this, name, age);
    this.grade = grade;
}
// 原型继承
Student.prototype = Object.create(Person.prototype, {
    // 不要忘了重新指定构造函数
    constructor: {
        value: Student
    }
    getGrade: {
        value: function() {
            return this.grade
        }
    }
})


var s1 = new Student('ming', 22, 5);

console.log(s1.getName());  // ming
console.log(s1.getAge());   // 22
console.log(s1.getGrade()); // 5
```
