## es3 作用域链 [[Scopes]]

每一个函数都有一个 [[Scopes]] 属性，其存储的是这个函数运行时的作用域链，除了当前函数的 词法环境 LE，作用域链的其他部分都会在其父函数预编译时添加到函数的 [[Scopes]] 属性上（因为父函数也需要预编译后才能确定自己的 函数词法环境(function environment)），所以 js 的作用域是**词法作用域**。

```js
// 1: 全局词法环境global.LE = {t,fun}
let t = 111;
function fun() {
  // 3: fun.LE = {a,b,fun1}
  let a = 1;
  let b = 2;
  function fun1() {
    // 5: fun1.LE = {c}
    let c = 3;
  }
  // 4: fun1.[[Scopes]] = [global.LE, fun.LE]
}
// 2: fun.[[Scopes]] = [global.LE]
fun();
```

上面介绍的 [[Scopes]] 可能就是大家熟知的，这在以前是对的。

es5 后其实每一个 词法作用域 都会有一个 outer 属性指向其上级 词法作用域，根据这个 outer 链路完全可以构成作用域。

## 为什么要多此一举弄一个 Closure 出来呢？

这就是涉及到闭包和内存泄漏问题，如果单纯的通过 outer 链路来实现作用域链，那么存在一个闭包时，就会导致整个作用域链中的所有 词法环境 都无法回收，但是此时如果我们只使用了父级词法环境中的一个变量，而 V8 为了让我们能使用这个一个变量付出如此大的内存代价，很显然是不值得的。而 [[Scopes]] + Closure 就是他们的解决方案。

所以现在的 V8 中已经发生了改变（Chrome 中已经可以看到这些变化），**在为一个函数绑定词法作用域时，并不会粗暴的直接把父函数的 LE 放入其 [[Scopes]] 中，而是会分析这个函数中会使用父函数的 LE 中的哪些变量，而这些可能会被使用到的变量会被存储在一个叫做 Closure 的对象中，每一个函数都有且只有一个 Closure 对象，最终这个 Closure 将会代替父函数的 LE 出现在子函数的 [[Scopes]] 中**

## 闭包对象 Closure

在 V8 中每一个函数执行前都会进行预编译，预编译阶段都会执行 3 个重要的字节码

CreateFunctionContext 创建函数执行上下文
PushContext 上下文入栈
CreateClosure 创建函数的闭包对象

也就是说，每一个函数执行前都会创建一个闭包，无论这个闭包是否被使用，那么闭包中的内容是什么？如何确定其内容？
Closure 跟 [[Scopes]] 一样会在函数预编译时被确定，区别是当前函数的 [[Scopes]] 是在其父函数预编译时确定， 而 Closure 是在当前函数预编译时确定（在当前函数执行上下文创建完成入栈后就开始创建闭包对象了）。
当 V8 预编一个函数时，如果遇到内部函数的定义不会选择跳过，而是会快速的扫描这个内部函数中使用到的本函数 LE 中的变量，然后将这些变量的引用加入 Closure 对象。再来为这个内部函数函数绑定 [[Scopes]] ，并且使用当前函数的 Closure 作为内部函数 [[Scopes]] 的一部分。

> 注意：每一次遇到内部声明的函数/方法时都会这么做，无论其内部函数/方法的声明嵌套有多深，并且他们使用的都是**同一个 Closure 对象**。并且这个过程 是在预编译时进行的而不是在函数运行时。

```js
// 1: global.LE = {t,fun}
var t = 111;
// 2: fun.[[Scopes]] = [global.LE]
function fun() {
  // 3: fun.LE = {a,b,c,fun1,obj}，并创建一个空的闭包对象fun.Closure = {}
  let a = 1,
    b = 2,
    c = 3;
  // 4: 遇到函数，解析到函数会使用a，所以 fun.Closure={a:1} (实际没这么简单)
  // 5: fun1.[[Scopes]] = [global.LE, fun.Closure]
  function fun1() {
    debugger;
    console.log(a);
  }
  fun1();
  let obj = {
    // 6: 遇到函数，解析到函数会使用b，所以 fun.Closure={a:1,b:2}
    // 7: method.[[Scopes]] = [global.LE, fun.Closure]
    method() {
      console.log(b);
    },
  };
}

// 执行到这里时，预编译 fun
fun();
```

1、2 发生在全局代码的预编译阶段，3、4、5、6、7 发生在 fun 的预编译阶段。

对于 global.LE，不同环境下的 global.LE 内容不一样，浏览器环境下的作用域链顶层是 [window, Script]，并且 script 作用域不会产生闭包对象。但是 node 环境下是 [global, Script.Closure] , node 环境下 Script 是会产生闭包的。

fun1 执行时的作用域链是这样的：[fun1.LE, fun.Closure, global.LE]

结论：**每一个函数都会产生闭包，无论 闭包中是否存在内部函数 或者 内部函数中是否访问了当前函数变量 又或者 是否返回了内部函数，因为闭包在当前函数预编译阶段就已经创建了**。

## 内存泄漏

所谓闭包产生的内存泄漏就是因为闭包对象 Closure 无法被释放回收，那么什么情况下 Closure 才会被回收呢？
这当然是在没有任何地方引用 Closure 的时候，因为 Closure 会被所有的子函数的作用域链 [[Scopes]] 引用，所以想要 Closure 不被引用就需要所有子函数都被销毁，从而导致所有子函数的 [[Scopes]] 被销毁，然后 Closure 才会被销毁。
这与许多网络上的资料是不一样的，常见的说法是必须返回的函数中使用的自由变量才会产生闭包，也就是下面这样

```js
function fun() {
  let arr = Array(10000000);
  return function () {
    console.log(arr); // 使用了 arr
  };
}
window.f = fun();
```

复制代码
但是其实不然，即使返回的的函数没有访问自由变量，只要有任何一个函数将 arr 添加到闭包对象 Closure 中，arr 都不会正常被销毁，所以下面两段代码都会产生内存泄漏

```js
function fun() {
  let arr = Array(10000000);
  function fun1() {
    // arr 加入 Closure
    console.log(arr);
  }
  return function fun2() {};
}
window.f = fun(); // 长久持有fun2的引用
```

因为 fun1 让 arr 加入了 fun.Closure，fun2 又被 window.f 持有引用无法释放，因为 fun2 的作用域链同样包含 fun.Closure，所以 fun.Closure 也无法释放，最终导致 arr 无法释放产生内存泄漏。

```js
function fun() {
  let arr = Array(10000000);
  function fun1() {
    // arr 加入 Closure
    console.log(arr);
  }
  window.obj = {
    // 长久持有 window.obj.method 的引用
    method() {},
  };
}
fun();
```

同理是因为 window.obj.method 作用域链持有 fun 的 Closure 引用导致 arr 无法释放。

那么我们将 arr = null 会不会让 arr 被释放呢？答案是会。这说明将变量加入到 Closure 并不是简单的 Closure.arr = arr 的过程，这是一个引用传递，也就是说 Closure.arr 存储的是对变量 arr 的引用，当 arr 变化时 Closure.arr 也会发生变化。

> 闭包产生内存泄漏的根本原因是因为 Closure 被其所有子函数的作用域链引用，只要有一个子函数没有销毁，Closure 就无法销毁，导致其中的变量也无法销毁，最终产生了内存泄漏。
