### e.target 的区别

父元素 middle 和 outer，target 的 id 都是等于 inner(子元素的 id)；

middle 的 currentTarget 的 id 是 middle，outer 的 currentTarget 的 id 是 outer；

- target：事件源组件对象(事件冒泡源头)

- currentTarget：当前组件对象(就是当前对象)

### class 的 protected、 pravila 和 public

1. public 修饰的属性可以在任意位置进行访问修改，默认值，作用范围是全局
2. private 修饰的属性只能在类的内部进行访问修改，私有属性，作用范围是类的内部。通过在类中添加 set get 存取器可以在类的外部访问私有属性
3. protected 修饰的属性只能在**当前类和当前类的子类中**进行访问修改，受保护的属性，作用范围是当前类和子类的范围内

### 一、iframe 的优缺点

width 定义 iframe 的宽度
height 定义 iframe 的高度
name 规定 iframe 的名称
frameborder 规定是否显示边框，0(不显示) 、1(显示)
src 设置 iframe 的地址（页面/图片）
scrolling 规定是否在 iframe 中显示滚动条，属性值(yes ，no，auto)
vspace 设置或获取对象的水平边距
hspace 设置或获取对象的垂直边距
————————————————

#### 1. 优点

1. 实现了页面的“模块化”。可以把一些与本网页不大相关的内容（广告），或者需要多次复用的内容放在一个 iframe 中，再嵌套入本网页。
2. 同域的时候可以操作父页面的内容（DOM），同理父页面也可以操作 iframe 页面的内容。

#### 2. 缺点

1. 搜索引擎不会解读这种页面，不利于 SEO
2. 滥用 iframe 会增加页面的性能开销
3. 需要防嵌套。一个网站可能会被别人用 iframe 进行嵌套引用。因为 iframe 享有着 click 的最高优先权，当用户在伪造的主页中进行点击的话，如果点在 iframe 上，则会默认是在操作 iframe 的页面。钓鱼网站就是使用这种方式，通过诱导用户进行点击，产生一些用户非自愿产生的行为。

#### 3. 为什么的 iframe 会影响页面性能？

1. iframe 阻塞页面加载，影响网页加载速度

window 的 onload 事件需要在所有 iframe 加载完毕后才会触发，因此，滥用 iframe 就会影响主页面加载速度。

1. 唯一的连接池

浏览器只能开少量的连接到 web 服务器，所以 iframe 几乎不可能有自己独立的连接池。在大多数浏览器中，连接被主页面和它嵌套的 iframe 所共享，这意味着有可能 iframe 中的资源占用了可用连接而阻塞了主页面的资源加载。

#### 三、iframe 的使用场景

1. 常用 iframe 来加载第三方广告等
2. 可以用 iframe 解决跨域请求问题

### 使用 css3 动画代替 js 的动画有什么好处？

1. 不占用 JS 主线程

2. 可以利用硬件加速

3. 浏览器可对 css 动画做优化（元素不可见时不动画，减少对 FPS 的影响）
   https://blog.csdn.net/weixin_45601248/article/details/123583055

css 和 js 动画各有优劣

如果我们要操作一个元素向右移动，我们可能需要控制 dom.style.left 属性，每次来改变元素的位置，而结合我们所说的，几何属性的改变必然会引起回流，回流必然引起重绘，可想而知如果我们采用 JS 来实现动画，这个代价有多大，这会造成浏览器在不断的计算页面，从而导致浏览器内存堆积。**同时由于 JavaScript 运行在浏览器的主线程中，主线程中还有其他的重要任务在运行，因而可能会受到干扰导致线程阻塞，从而丢帧**

**而 CSS 的动画是运行在合成线程中的，不会阻塞主线程，并且在合成线程中完成的动作不会触发回流和重绘**

当然还有一个重要的点：**JS 动画运行在 CPU，而 CSS 动画运行在 GPU**

总的来说， CSS 动画的渲染成本小，并且它的执行效率高于 JavaScript 动画

### LRU

```js
class LRU {
  constructor(max) {
    this.max = max;
    this.cache = new Map();
  }
  get(key) {
    const { cache } = this;
    const value = cache.get(key);
    if (!value) return -1;
    cache.delete(key);
    cache.set(key, value);
    return value;
  }
  set(key, value) {
    const { cache, max } = this;
    if (cache.has(key)) {
      cache.delete(key);
    }
    if (cache.size === max) {
      cache.delete(cache.keys().next().value);
    }
    cache.set(key, value);
  }
}
```

### 聊聊微前端

将前端整体分解，每一块可以独立开发，测试和部署，同时对用户而言又是一个整体

### 什么是包装对象

包装对象，只要是为了便于基本类型调用对象的方法。
包装对象有三种：String Number Boolean
这三种原始类型可以与实例对象进行自动转换，可把原始类型的值变成（包装成）对象，比如在字符串调用函数时，引擎会将原始类型的值转换成只读的包装对象，执行完函数后就销毁。

### WebAssembly

（缩写为 wasm）是**一种使用非 Javascript 代码，并使其在浏览器中运行的方法。这些代码可以是 C、C++ 或 Rust 等。它们会被编译进你的浏览器，在你的 CPU 上以接近原生的速度运行。这些代码的形式是二进制文件，你可以直接在 Javascript 中将它们当作模块来用**。WebAssembly 不能替代 Javascript。相反，这两种技术是相辅相成的。通过 Javascript API，你可以将 WebAssembly 模块加载到你的页面中。也就是说，你可以通过 WebAssembly 来充分利用编译代码的性能，同时保持 Javascript 的灵活性。WebAssembly 这个名子有点误导人。WebAssembly 确实适用于 Web，但它的使用场景远不止于此！此外，有一个误解也是相当普遍的。**WebAssembly 不是编程语言。WebAssembly 是一种中间格式，叫做字节码，其可作为其他语言的编译目标。**

### WebSocket 与 Ajax 的区别

本质不同
Ajax 即异步 JavaScript 和 XML，是一种创建交互式网页的应用的网页开发技术
websocket 是 HTML5 的一种新协议，实现了浏览器和服务器的实时通信
生命周期不同：

websocket 是长连接，会话一直保持
ajax 发送接收之后就会断开

适用范围：

websocket 用于前后端实时交互数据
ajax 非实时

发起人：

AJAX 客户端发起
WebSocket 服务器端和客户端相互推送

### ~~

~~其实是一种利用符自号进行的类型转换,转换成数字类型
具体应用如下：
~~true == 1
~~false == 0
~~"" == 0
~~[] == 0
~~undefined ==0
~~!undefined == 1
~~null == 0
~~!null == 1

### 1. 防抖节流区分，应用, 手写

###### 函数防抖(debounce)

当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。

1. 原理：在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。
2. 适用场景：

- 按钮提交场景：防止多次提交按钮，只执行最后提交的一次
- 搜索框联想场景：防止联想发送请求，只发送最后一次输入

```javascript
function debounce(func, delay) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    clearTimeout(timeout);
    timer = setTimeout(function () {
      func.apply(context, args);
    }, delay);
  };
}
```

###### 函数节流(throttle)

当持续触发事件时，保证一定时间段内只调用一次事件处理函数。

1. 原理：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。
2. 适用场景

- 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动
- 缩放场景：监控浏览器 resize

时间戳的实现虽然可以首次立即执行，但无法确保必定执行最后一次回调

```javascript
// 时间戳版本
function throttle(fn, delay) {
  let prev = Date.now();
  return function () {
    const context = this;
    const args = arguments;
    let now = Date.now();
    if (now - prev >= delay) {
      fn.apply(context, args);
      prev = Date.now();
    }
  };
}
```

“定时器” 的方式，函数在时间段结束时执行。可理解为函数并不会立即执行，而是等待延迟计时完成才执行。（由于定时器延时，最后一次触发后，可能会再执行一次回调函数）

```javascript
// 定时器版本
function throttle(fn, delay) {
  let timer = null;
  return function () {
    const context = this;
    const args = arguments;
    if (!timer) {
      timer = setTimeout(function () {
        fn.apply(context, args);
        timer = null;
      }, delay);
    }
  };
}
```

时间戳+定时器
在节流函数内部使用开始时间 startTime、当前时间 curTime 与 delay 来计算剩余时间 remaining，当 remaining<=0 时表示该执行事件处理函数了（保证了第一次触发事件就能立即执行事件处理函数和每隔 delay 时间执行一次事件处理函数）。如果还没到时间的话就设定在 remaining 时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处理函数）。当然在 remaining 这段时间中如果又一次触发事件，那么会取消当前的计时器，并重新计算一个 remaining 来判断当前状态。

```javascript
function throttle(fn, delay) {
  let timer,
    startTime = 0;
  return function () {
    let context = this;
    let args = arguments;
    let curTime = Date.now();
    let remaining = delay - (curTime - startTime);
    timer && clearTimerOut(timer);
    if (remaining > 0) {
      timer = setTimeout(function () {
        fn.apply(context, args);
        startTime = Date.now();
      }, remaining);
    } else {
      fn.apply(this, args);
      startTime = Date.now();
    }
  };
}
```

### 2.写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b,...,a+nb 的时间，然后写一个 myClear，停止上面的 mySetInterVal

```javascript
    let count = 0;
    let timer = null;
    const loop = () => {
        timer = setTimeout(() => {
            fn();
            count++;
            loop();
        }, a + count * this.b)
    }
    loop();
    return () => {
        clearTimeout(timer)
    }
}
```

### setTimeout 模拟 setInterval

```js
function myInterval(fn, time) {
  let clear = false;
  let timer = null;
  function loop() {
    if (clear) {
      return clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn();
      loop();
    }, time);
  }
  return () => {
    clear = true;
  };

```

### 对闭包的看法，为什么要用闭包？说一下闭包原理以及应用场景

##### 什么是闭包

mdn 定义

> **一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。**在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。

可以在内部函数访问到外部函数作用域。使用闭包，
一可以读取函数中的变量，
二可以将函数中的变量存储在内存中，保护变量不被污染。
而正因闭包会把函数中的变量值存储在内存中，会对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成内存泄漏。当不需要使用闭包时，要及时释放内存，可将内层函数对象的变量赋值为 null。

###### 闭包原理

利用了**函数作用域链**的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被烧毁后才被销毁。

##### 一般如何产生闭包

当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包

1. 函数嵌套
2. 内部函数引用了外部函数的数据（变量/函数）
3. 调用外部函数

###### 优点

1. 一可以读取函数中的局部变量，
2. 二可以将函数中的变量存储在内存中，
3. 保护变量不被污染。

###### 缺点

1. 对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏

2. 对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度

3. 可能获取到意外的值(captured value)

###### 应用场景

1. 典型应用是模块封装，在各模块规范出现之前，都是用这样的方式防止变量污染全局。
2. 在循环中创建闭包，防止取到意外的值。
3. 柯里化 bind
4. 缓存
5. 在循环 / 异步回调中使用闭包，配合 IIFE 立即执行的函数表达式
6. 返回一个函数
7. 自执行函数（IIFE）

### 实现 lodash 的\_.get

在 js 中经常会出现嵌套调用这种情况，如 a.b.c.d.e，但是这么写很容易抛出异常。你需要这么写 a && a.b && a.b.c && a.b.c.d && a.b.c.d.e，但是显得有些啰嗦与冗长了。特别是在 graphql 中，这种嵌套调用更是难以避免。
这时就需要一个 get 函数，使用 get(a, 'b.c.d.e') 简单清晰，并且容错性提高了很多。

```javascript
function get(source, path, defaultValue = undefined) {
  // a[3].b -> a.3.b -> [a,3,b]
  // path 中也可能是数组的路径，全部转化成 . 运算符并组成数组
  const paths = path.replace(/\[(\d+)\]/g, ".$1").split(".");
  let result = source;
  for (let i = 0; i < paths.length; i++) {
    result = source[paths[i]];
    if (!result) return defaultValue;
  }
  return result;
}
```

### 实现柯里化

柯里化（currying）又称部分求值。一个柯里化的函数首先会接收一些参数，接收了这些参数后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。

#### 公式一当传入参数等于函数参数数量时开始执行

```javascript
// fn(a,b,c,d) => fn(a)(b)(c)(d);
// 固定参数
function curry(fn, args) {
  // 获取函数需要的参数长度
  let length = fn.length;
  args = args || [];
  return function () {
    var subArgs = Array.prototype.slice.call(arguments);
    subArgs = subArgs.concat(args);
    // 判断参数的长度是否已经满足函数所需参数的长度
    if (subArgs.length >= length) {
      // 如果满足，执行函数
      return fn.apply(this, subArgs);
    } else {
      // 如果不满足，递归返回柯里化的函数，等待参数的传入
      return curry.call(this, fn, subArgs);
    }
  };
}
// es6 实现
function curry(fn, ...args) {
  return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);
}
// test
const add = curry((a, b, c, d) => {
  return a + b + c + d;
});
add(1)(2)(3)(4);
```

#### arguments 转数组

1. Array.from
2. [...args]
3. Array.prototype.slice()

#### 公式二当没有参数传入时（且参数数量满足）开始执行

```js
// fn(a, b, c, d) => fn(a)(b)(c)(d)();
function curry2(fn, args) {
  // 获取函数需要的参数长度
  let length = fn.length;
  args = args || [];
  return function () {
    var subArgs = Array.prototype.slice.call(arguments);
    // 判断参数的长度是否已经满足函数所需参数的长度
    if (!subArgs.length && args.length >= length) {
      // 如果满足，执行函数
      return fn.apply(this, args);
    } else {
      // 如果不满足，递归返回科里化的函数，等待参数的传入
      subArgs = subArgs.concat(args);
      return curry2.call(this, fn, subArgs);
    }
  };
}
const add2 = curry2((a, b, c, d) => {
  return a + b + c + d;
});
add(1)(2)(3)(4)();
//
```

### 实现 add(1)(2)(3)() (柯里化)

```javascript
// 不固定参数
function currying(fn) {
  let args = [];
  return function temp(...tempArgs) {
    if (tempArgs.length) {
      args = [...args, ...tempArgs];
      return temp;
    } else {
      const res = fn.apply(null, args);
      args = [];
      return res;
    }
  };
}
function add(...args) {
  return args.reduce((a, b) => a + b, 0);
}
let addCurry = currying(add);
console.log(addCurry(1)(2)(3)(4, 5)()); //15
console.log(addCurry(1)(2)(3, 4, 5)()); //15
console.log(addCurry(1)(2, 3, 4, 5)()); //15
```

### 实现 bind, apply, call

```javascript
// bind

/*
bind() 除了 this 外，还可传入多个参数；
bing 创建的新函数可能传入多个参数；
新函数可能被当做构造函数调用；一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。

函数可能有返回值；
参考链接：https://juejin.cn/post/6844903733013250056
*/
Function.prototype.bind = function (context, ...args) {
  if (typeof this !== "function") {
    throw new Error(
      "Function.prototype.bind - what is trying to be bound is not callable"
    );
  }
  var self = this;
  var fNOP = function () {};
  var fBound = function () {
    // 当作为构造函数时，this 指向实例，此时 this instanceof fBound 结果为 true，
    // this instanceof fNOP 相当于 fboundx被当做构造函数使用
    return self.apply(
      this instanceof fNOP ? this : context,
      args.concat(Array.prototype.slice.call(arguments))
    );
  };
  // 原型链对象上的属性不能丢失。因此这里需要用到原型链继承（es5 Object.create()），将 this.prototype 上面的属性挂到 fbound 的原型上面，最后再返回 fbound。
  //  原型链继承
  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();
  return fBound;
};

Function.prototype.apply = function (context, args) {
  context = context || window;
  const fnSymbol = Symbol("fn");
  context[fnSymbol] = this;
  const result = context[fnSymbol](...args);
  delete context[fnSymbol];
  return result;
};
Function.prototype.call = function (context, ...args) {
  context = context || window;
  const fnSymbol = Symbol("fn");
  context[fnSymbol] = this;
  const result = context[fnSymbol](...args);
  delete context[fnSymbol];
  return result;
};
```

### 如果一个构造函数，bind 了一个对象，用这个构造函数创建出的实例会继承这个对象的属性吗？为什么？

不会继承，因为根据 this 绑定四大规则，new 绑定的优先级高于 bind 显示绑定，通过 new 进行构造函数调用时，会创建一个新对象，这个新对象会代替 bind 的对象绑定，作为此函数的 this，并且在此函数没有返回对象的情况下，返回这个新建的对象

### 实现链式调用

链式调用的核心就在于调用完的方法将自身实例返回

```javascript
function Class1() {
  console.log("初始化");
}
Class1.prototype.method = function (param) {
  console.log(param);
  return this;
};
let cl = new Class1();
//由于new 在实例化的时候this会指向创建的对象， 所以this.method这个方法会在原型链中找到。
cl.method("第一次调用").method("第二次链式调用");
```

### 类数组和数组的区别，dom 的类数组如何转换成数组

1. 定义

   1. 数组是一个特殊对象,与常规对象的区别：

      - 当由新元素添加到列表中时，自动更新 length 属性
      - 设置 length 属性，可以截断数组
      - 从 Array.protoype 中继承了方法
      - contructor 属性为'Array'

   2. **类数组是一个拥有 length 属性，并且他属性为非负整数的普通对象，类数组不能直接调用数组方法**。

2. 区别
   本质：类数组是简单对象，它的原型关系与数组不同。
3. 类数组转换为数组

- 转换方法
  - 使用 Array.from()
  - 使用 Array.prototype.slice.call()
  - 使用 Array.prototype.forEach() 进行属性遍历并组成新的数组
- 转换须知
  转换后的数组长度由 length 属性决定。索引不连续时转换结果是连续的，会自动补位。

### 介绍下 promise 的特性、优缺点，内部是如何实现的，动手实现 Promise

[promise 专题](./promise.md)

```javascript
const PENDING = "pending";
const RESOLVED = "fullfilled";
const REJECTED = "rejected";

function Promise(excutor) {
  const self = this;
  this.status = PENDING;
  this.callbacks = [];
  this.value = undefined;
  this.reason = undefined;
  function resolve(value) {
    if (self.status !== PENDING) return;
    self.status = RESOLVED;
    self.value = value;
    if (self.callbacks.length) {
      setTimeout(() => {
        self.callbacks.forEach((cb) => {
          cb.onResolved(value);
        });
      });
    }
  }
  function reject(reason) {
    if (self.status !== PENDING) return;
    self.status = REJECTED;
    self.reason = reason;
    if (self.callbacks.length) {
      setTimeout(() => {
        self.callbacks.forEach((cb) => {
          cb.onRejected(value);
        });
      });
    }
  }
  try {
    excutor(resolve, reject);
  } catch (err) {
    reject(error);
  }
}

Promise.prototype.then = function (onResolved, onRejected) {
  return new Promise((resolve, reject) => {
    if (this.state === PENDING) {
      this.callbacks.push({
        onResolved,
        onRejected,
      });
    } else if (self.status === RESOLVED) {
      setTimeout(() => {
        try {
          const result = onResolved(self.value);
          if (result instanceof Promise) {
            result.then(
              (value) => resolve(value),
              (reason) => reject(reason)
            );
          } else {
            resolve(result);
          }
        } catch (err) {
          reject(err);
        }
      });
    } else {
      setTimeout(() => {
        onRejected(self.reason);
      });
    }
  });
};
```

###### 特性

1. Promise 有三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)
2. Promise 对象接受一个回调函数作为参数, 该回调函数接受两个参数，分别是成功时的回调 resolve 和失败时的回调 reject；另外 resolve 的参数除了正常值以外， 还可能是一个 Promise 对象的实例；reject 的参数通常是一个 Error 对象的实例。

### 实现 Promise.all

注意点：

1. Promise.all 传递的参数可能不是 Promise 类型，可能不存在 then 方法。
2. 如果中间发生错误，应该直接返回错误，不执行后面操作。

```javascript
Promise.prototype.all = function (promises) {
  let results = [];
  let promiseCount = 0;
  let promisesLength = promises.length;
  return new Promise(function (resolve, reject) {
    for (let val of promises) {
      Promise.resolve(val).then(
        function (res) {
          promiseCount++;
          // results.push(res);
          results[i] = res;
          // 当所有函数都正确执行了，resolve输出所有返回结果。
          if (promiseCount === promisesLength) {
            return resolve(results);
          }
        },
        function (err) {
          return reject(err);
        }
      );
    }
  });
};
```

### 实现 Promise.any

Promise.any 的规则是这样：

空数组或者所有 Promise 都是 rejected，则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误；
只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例；
其他情况都会返回一个 pending 的新实例；

```js
Promise.any = function (promiseArr) {
  let index = 0;
  return new Promise((resolve, reject) => {
    if (promiseArr.length === 0) return;
    promiseArr.forEach((p, i) => {
      Promise.resolve(p).then(
        (val) => {
          resolve(val);
        },
        (err) => {
          index++;
          if (index === promiseArr.length) {
            reject(new AggregateError("All promises were rejected"));
          }
        }
      );
    });
  });
};
```

### 手写发布订阅模式

```javascript
class Observer {
  static events = new Map();

  static on(name, fn) {
    let list = this.event.get(name);
    if (!list) {
      list = [];
      this.event.set(name, list);
    }
    list.push({ isOnce: false, fn });
  }

  static once(name, fn) {
    let list = this.event.get(name);
    if (!list) {
      list = [];
      this.event.set(name, list);
    }
    list.push({ isOnce: true, fn });
  }

  static off(name, fn) {
    const list = this.event.get(name);
    if (list) {
      const index = list.findIndex((item) => item == fn);
      list.splice(index, 1);
    }
  }

  static emit(name, data) {
    let list = this.events.get(name);
    if (list) {
      if (cache.isOnce) this.events.delete(name);
      cache.fn(data);
    }
  }
}
```

### 使用 ES6 的 Proxy 实现数组负索引。 （负索引：例如，可以简单地使用 arr[-1]替代 arr[arr.length-1]访问最后一个元素，[-2]访问倒数第二个元素，以此类推）

```javascript
const proxyArray = (arr) => {
  const length = arr.length;
  return new Proxy(arr, {
    get(target, key) {
      key = +key;
      while (key < 0) {
        key += length;
      }
      return target[key];
    },
  });
};
var a = proxyArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);
console.log(a[1]); // 2
console.log(a[-10]); // 9
console.log(a[-20]); // 8
```

### ["1", "2", "3"].map(parseInt)

1. 答案

2. 解析
3. parseInt 方法接收两个参数
   第三个参数["1", "2", "3"]将被忽略。parseInt 方法将会通过以下方式被调用
   parseInt("1", 0)
   parseInt("2", 1)
   parseInt("3", 2)

4. parseInt 的第二个参数 radix 为 **0/undefined/未指定**时，如果输入的 string 以 "0x"或 "0x"（一个 0，后面是小写或大写的 X）开头，那么 radix 被假定为 16，字符串的其余部分被当做十六进制数去解析。如果输入的 string 以 "0"（0）开头， radix 被假定为 8（八进制）或 10（十进制）。具体选择哪一个 radix 取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。因此，在使用 parseInt 时，一定要指定一个 radix。如果输入的 string 以任何其他值开头， radix 是 10 (十进制)。

parseInt 的第二个参数 radix 为 1 时，解析结果为 NaN；

parseInt 的第二个参数 radix 在 2—36 之间时，如果 string 参数的第一个字符（除空白以外），不属于 radix 指定进制下的字符，解析结果为 NaN。
parseInt("3", 2)执行时，由于"3"不属于二进制字符，解析结果为 NaN。

### prototype 与\__proto_

**proto**是每个对象都有的一个属性，而 prototype 是函数才会有的属性!!!
使用 Object.getPrototypeOf()代替**proto**!!!

1. prototype 是通过调用构造函数而创建的那个对象实例的原型对象
2. 对象具有属性**proto**，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。
3. Object.getPrototypeOf()
   一个对象实例通过内部属性[[Prototype]]跟踪其原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。可以调用对象的 Object.getPrototypeOf()方法读取[[Prototype]]属性的值，也可以使用 isPrototypeOf()方法检查某个对象是否是另一个对象的原型对象。大部分 JavaScript 引擎在所有对象上都支持一个名为**proto**的属性，该属性可以直接读写[[Prototype]]属性。

### isNaN 和 Number.isNaN

1. isNaN

如果 isNaN 函数的参数不是 Number 类型， isNaN 函数会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是 NaN 进行判断。

```javascript
isNaN(NaN); // true
isNaN(undefined); // true
isNaN({}); // true

isNaN(true); // false
isNaN(null); // false
isNaN(37); // false

// strings
isNaN("37"); // false: 可以被转换成数值37
isNaN("37.37"); // false: 可以被转换成数值37.37
isNaN("37,5"); // true
isNaN("123ABC"); // true:  parseInt("123ABC")的结果是 123, 但是Number("123ABC")结果是 NaN
isNaN(""); // false: 空字符串被转换成0
isNaN(" "); // false: 包含空格的字符串被转换成0

// dates
isNaN(new Date()); // false
isNaN(new Date().toString()); // true

isNaN("blabla"); // true: "blabla"不能转换成数值
// 转换成数值失败， 返回NaN
```

2. Number.isNaN()
   和全局函数 isNaN() 相比，Number.isNaN() 不会自行将参数转换成数字，只有在参数是值为 NaN 的数字时，才会返回 true。

```javascript
Number.isNaN(NaN); // true
Number.isNaN(Number.NaN); // true
Number.isNaN(0 / 0); // true
// 下面这几个如果使用全局的 isNaN() 时，会返回 true。
Number.isNaN("NaN"); // false，字符串 "NaN" 不会被隐式转换成数字 NaN。
Number.isNaN(undefined); // false
Number.isNaN({}); // false
Number.isNaN("blabla"); // false

// 下面的都返回 false
Number.isNaN(true);
Number.isNaN(null);
Number.isNaN(37);
Number.isNaN("37");
Number.isNaN("37.37");
Number.isNaN("");
Number.isNaN(" ");
```

### \*\*

关于 ** 与 Math.pow（x , y）的联系
** 可以看做是 Math.pow（x , y）的语法糖，其作用与 Math.pow()一致

x \*\* y 表示：返回 x 的 y 次幂

2 \*\* 3 返回结果：8（2 的 3 次幂）

### == 与===

1. === 完全相等
2. == 会发生隐式转换
   如果两个值类型相同，进行 === 比较。

如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：

- 如果一个是 null、一个是 undefined，那么[相等]。

- 如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。

- 如果任一值是 true ，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。

- 如果原始类型的值和对象比较，对象会转为原始类型的值，再进行比较。对象转换成原始类型的值，算法是先调用 valueOf 方法；如果返回的还是对象，再接着调用 toString 方法。

- 任何其他组合，都[不相等]。

### 前端页面性能优化

从用户的角度而言，当打开一个网页，往往关心的是从输入完网页地址后到最后展现完整页面这个过程需要的时间，这个时间越短，用户体验越好。所以作为网页的开发者，就**从输入 url 到页面渲染呈现**这个过程中去提升网页的性能。

### 聊一下代码检查(eslint,ts)

### 实现 map,reduce

### 统计字符串中次数最多字母

### 实现一个 new 操作符

1. 首先创建了一个新的空对象
2. 设置原型，将对象的原型设置为函数的 prototype 对象。
3. 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回 这个引用类型的对象
   **new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象。**

```js
function objectFactory() {
  let newObject = null,
    constructor = Array.prototype.shift.call(arguments),
    result = null;
  // 参数判断
  if (typeof constructor !== "function") {
    console.error("type error");
    return;
  }
  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype);
  // 将 this 指向新建对象，并执行函数
  result = constructor.apply(newObject, arguments);
  // 判断返回对象
  let flag =
    result && (typeof result === "object" || typeof result === "function");
  // 判断返回结果
  return flag ? result : newObject;
}
// 使用方法
// objectFactory(构造函数, 初始化参数);
```

### 实现 Object.assign

```js
Object.assign2 = function (target, ...source) {
  if (target == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  let ret = Object(target); // Object.assign(2,{attr:1})
  source.forEach(function (obj) {
    if (obj != null) {
      for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
          ret[key] = obj[key];
        }
      }
    }
  });
  return ret;
};
```

### 实现 Object.create

<!-- todo 第二个参数 -->

```js
Object.create = function (proto, propertiesObject) {
  if (typeof proto !== "object" && typeof proto !== "function") {
    throw new TypeError("The prototype must be a object");
  } else if (proto === null) {
    throw new TypeError("The prototype cannot be null");
  }

  // 创建构造函数，并将构造函数的原型对象设置为proto
  const F = function () {};
  F.prototype = proto;
  // 创建新对象
  let obj = new F();
  if (propertiesObject && typeof propertiesObject === "object") {
    Object.defineProperties(obj, propertiesObject);
  }

  return obj;
};
```

### 实现数组扁平化函数 flat

js 为什么会有回调地狱呢
为什么 java 没有回调地狱
promise.all 返回的是什么
promise 和 async 你觉得差异点是什么

### 箭头函数与普通函数的区别

1. 箭头函数**没有 prototype (原型)，所以箭头函数本身没有 this​​​​​​​**
2. 箭头函数**不会创建自己的 this**
3. 箭头函数没有自己的 this
   箭头函数的 this 指向在定义（注意：是定义时，不是调用时）的时候继承自外层第一个普通函数的 this(指向其上下文的 this )。所以，箭头函数中 this 的指向在它被定义的时候就已经确定了，之后永远不会改变。
4. call | apply | bind 无法改变箭头函数中 this 的指向.
   call | apply | bind 方法可以用来动态修改函数执行时 this 的指向，但由于箭头函数的 this 定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数 this 的指向。
5. 箭头函数不能作为构造函数使用

我们先了解一下构造函数的 new 都做了些什么？简单来说，分为四步：

- JS 内部首先会先生成一个对象；
- 再把函数中的 this 指向该对象；
- 然后执行构造函数中的语句；
- 最终返回该对象实例。
  但是！！因为箭头函数没有自己的 this，它的 this 其实是继承了外层执行环境中的 this，且 this 指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用 new 调用时会报错！

6. 箭头函数不绑定 arguments，取而代之用 rest 参数...代替 arguments 对象，来访问箭头函数的参数列表

7. 箭头函数不能用作 Generator 函数，不能使用 yield 关键字

### 什么是单点登录，如何实现

[参考链接](https://blog.csdn.net/qq_41595452/article/details/122066984)
https://note.youdao.com/ynoteshare/index.html?id=d514bd8a9e7f6c4bc2d9dac4a864e211&type=note&_time=1658881142788
https://juejin.cn/post/6952839815482048548#heading-9

##### 定义

单点登录全称 Single Sign On（以下简称 SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分.

###### 原理

sso 需要一个**独立的认证中心**，所有子系统都通过认证中心的登录入口进行登录，登录时带上自己的地址，子系统只接受认证中心的授权，授权通过**令牌**（token）实现，sso 认证中心验证用户的用户名密码正确，创建**全局会话和 token**，token 作为参数发送给各个子系统，子系统拿到 token，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。

1. 用户访问系统 A 的受保护资源时，发现用户在系统 A 上并未登录，此时会携带系统 A 的地址信息，将登录请求跳转到 SSO 认证中心；
2. SSO 认证中心发现用户未登录，将指引用户到系统 A 的登录页面；
3. 用户此时应该输入用户名、密码进行登录提交申请；
4. SSO 认证中心对用户信息的用户名和密码进行校验，创建用户与 SSO 认证中心之间的全局会话，同时创建授权令牌 Token；
5. SSO 认证中心携带 Token 令牌跳转到最初的请求地址（系统 A 的地址）；
6. 当用于在此发起请求时，系统 A 拿到令牌 Token 去 SSO 认证中心校验令牌是否有效；
7. SSO 认证中心拿到 Token 后进行校验，如有效则返回，并注册系统 A 的地址；
8. 系统 A 使用该令牌 Token 创建与用户的会话，成为局部会话，返回受保护资源；
9. 当用户访问系统 B 的受保护资源时，发现用户未登录，则携带系统 B 的地址信息，将登录强求跳转到 SSO 认证中心；
10. SSO 认证中心发现用户已经登录，发现用于已经登录，则携带令牌 Token 跳转到系统 B 的地址；
11. 当向系统 B 在此发起请求时，系统 B 拿到 Token 令牌，去 SSO 认证中心校验令牌是否有效；
12. SSO 认证中心校验 Token 有效，则注册系统 B 的地址信息；
13. 系统 B 使用该 Token 信息与用户的局部会话，且向浏览器返回受保护资源。

分布式 session 方式实现单点登录
流程运行：

1. 用户第一次登录时，将会话信息（用户 Id 和用户信息），比如以用户 Id 为 Key，写入分布式 Session；

2. 用户再次登录时，获取分布式 Session，是否有会话信息，如果没有则调到登录页；

3. 一般采用 Cache 中间件实现，建议使用 Redis，因此它有持久化功能，方便分布式 Session 宕机后，可以从持久化存储中加载会话信息；

4. 存入会话时，可以设置会话保持的时间，比如 15 分钟，超过后自动超时；

### 尾递归

顾名思义，尾递归就是从最后开始计算, 每递归一次就算出相应的结果, 也就是说, 函数调用出现在调用者函数的尾部, 因为是尾部, 所以根本没有必要去保存任何局部变量. 直接让被调用的函数返回时越过调用者, 返回到调用者的调用者去。尾递归就是**把当前的运算结果（或路径）放在参数里传给下层函数，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径**。

尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如 f(n, sum) = f(n-1) + value(n) + sum; 会保存 n 个函数调用堆栈，而使用尾递归 f(n, sum) = f(n-1, sum+value(n)); 这样则只保留后一个函数堆栈即可，之前的可优化删去。

```javascript
function fibonacci(n, v1 = 1, v2 = 1) {
  if (n == 1) return v1;
  if (n == 2) return v2;
  return fibonacci(n - 1, v2, v1 + v2);
}
```

### 有 1000 个 dom, 需要更新其中的 100 个，如何操作才能减少 dom 的操作

1. 缓存 dom 对象

2. 文档片段
   document.createDocumentFragment()创建文档碎片节点，创建的是一个虚拟的节点对象，向这个节点添加 dom 节点，修改 dom 节点不会影响到真实的 dom 节点。可以利用这一点将我们需要修改的 dom 一并修改完保存到文档碎片中，然后一次性替换。

3. innerHTML 代替 高频的 appendChild

4. 虚拟 dom

### 商城列表页跳转到详情页,接口数据很慢，前端怎么优化用户体验

1. 懒加载，获取首屏数据，后边的数据进行滑动加载请求
2. 利用骨架屏提升用户体验
3. PreloadJS 预加载
4. 添加 loading 和超时 404 页面，接口部分可以添加缓存和预加载

## 预加载

链接预取是一种浏览器机制，其**利用浏览器空闲时间来下载或预取用户在不久的将来可能访问的文档**。网页向浏览器提供一组预取提示，并在浏览器完成当前页面的加载后开始静默地拉取指定的文档并将其存储在缓存中。当用户访问其中一个预取文档时，便可以快速的从浏览器缓存中得到。

##### 目前支持两种方式的预加载

- preload 立即请求

<link href=/js/chunk-vendors.5e63c7cf.js rel=preload as=script>
当浏览器解析到preload会立即进行资源的请求，需要注意的是使用preload进行预加载时需要指定文件的类型

- prefetch 空闲请求

<link href=/js/chunk-dca4e6ea.e4986a0a.js rel=prefetch>
当浏览器解析到prefetch时，不会立即请求资源，会等待浏览器空闲以后再进行资源的请求

综上所述

- preload 适用于加载当前页面需要用到的资源
- prefetch 适用于后续页面需要用到的资源

##### 在 webpack 中开启

```js
import(/* webpackPrefetch: true */ "LoginModal");
import(/* webpackPreload: true */ "ChartingLibrary");
```

### 图片懒加载

1. 不要将图片地址放到 src 中，而是放到其它属性(data-origin)中
2. 页面加载完成后/ 滚动事件中，根据 scrollTop 判断图片是否在视窗内，在则取出 data-origin 赋给 src

### 鼠标点击页面中的任意标签，alert 该标签的名称．（注意兼容性）

```javascript
function elementName(evt) {
  evt = evt || window.event;
  var selected = evt.target || evt.srcElement;
  alert(selected.tagName);
}

window.onload = function () {
  var el = document.getElementsByTagName("body");
  el[0].onclick = elementName;
};
```

### 原生实现 ES5 的 Object.create() 方法

先说一下 object.create()
es5 中新增的 object 操作方法 object.create() 接受两个参数:
Object.create(obj,propertiesObject);

obj : 一个对象，是新创建的对象的原型。 即:创建一个空对象，空对象的原型是参数 obj.
propertiesObject：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与 Object.defineProperties()的第二个参数一样）。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。 即:

```javascript
propertiesObject = {
  like: {
    value: "fish", // 初始化赋值
    writable: true, // 是否是可改写的
    configurable: true, // 是否能够删除，是否能够被修改
    enumerable: true, //是否可以用for in 进行枚举
  },
};
```

答案

```javascript
Object.create = function (prototype, properties) {
  if (typeof prototype !== "object") throw TypeError();
  function F() {}
  F.prototype = prototype;
  const o = new F();
  if (properties) {
    Object.defineProperties(o, properties);
  }
  return o;
};
```

### 如何记录前端在用户浏览器上发生的错误并上报给服务器

https://blog.csdn.net/weixin_39838846/article/details/124392578

1. 采集哪些数据
   主要原则就是避开用户敏感字段，采集浏览器版本、操作系统版本、报错的 msg 信息等。

2. 如何采集错误
   前端错误大体上可以分成两类，

   1. 代码执行的错误

      - 使用 try... catch 包裹，影响代码可读性。无法处理语法错误
      - window.onerror,要强那么一丢丢。无论是异步还是非异步错误，onerror 都能捕获到运行时错误。
        **window.onerror 的缺点：监听不到资源加载的报错,onerror 事件处理函数只能声明一次，不会重复执行多个回调.**

      - 捕获 promise 错误

   2. 资源加载的错误
      1. imgObj.onerror()
      2. performance.getEntries()这个 API 能帮我们获得资源的请求时间，包括 JS、CSS、图片等. 获取到成功加载的资源，对比可以间接的捕获错误
      3. window.addEventListener('error', fn, true) 会捕获但是不冒泡，所以 window.onerror 不会触发，捕获阶段可以触发
      - window.addEventListener 可以监听到资源加载报错，也可以注册多个事件处理函数。

3. Vue 有 errorHandler,React 有 componentDidCatch 进行捕获 https://zh-hans.reactjs.org/docs/error-boundaries.html
4. 错误上报

   1. 一般来说，大厂都是采用利用 image 对象的方式上报错误的；使用图片发送 get 请求，上报信息，由于浏览器对图片有缓存，同样的请求，图片只会发送一次，避免重复上报。

   2. navigator.sendBeacon //不支持 ie, (sendBeacon 并不像 XMLHttpRequest 一样可以直接指定 Content-Type，且不支持 application/json 等常见格式。data 的数据类型必须是 ArrayBufferView 或 Blob, DOMString 或者 FormData 类型的)

```javascript
var entry = {};
function report(url, data) {
  if (!url || !data) {
    return;
  } // @see http://jsperf.com/new-image-vs-createelement-img
  var image = document.createElement("img");
  var items = [];
  for (var key in data) {
    if (data[key]) {
      items.push(key + "=" + encodeURIComponent(data[key]));
    }
  }
  var name = "img_" + +new Date();
  entry[name] = image;
  image.onload = image.onerror = function () {
    console.log(arguments);
    entry[name] = image = image.onload = image.onerror = null;
    delete entry[name];
  };
  image.src = url + (url.indexOf("?") < 0 ? "?" : "&") + items.join("&");
}
```

### encodeURI encodeComponent escape (编码程度依次升高)

### 搜索中文如何处理

encodeURI / encodeURIComponent

1. escape()不能直接用于 URL 编码，它的真正作用是返回一个字符的 Unicode 编码值。比如"春节"的返回结果是%u6625%u8282，，escape()不对"+"编码 主要用于汉字编码，现在已经不提倡使用。

2. encodeURI()是 Javascript 中真正用来对 URL 编码的函数。 编码整个 url 地址，但对特殊含义的符号"; / ? : @ & = + $ , #"，也不进行编码。对应的解码函数是：decodeURI()。

3. encodeURIComponent() 能编码"; / ? : @ & = + $ , #"这些特殊字符。对应的解码函数是 decodeURIComponent()。

   使用场景：

4. 如果只是编码字符串，不和 URL 有半毛钱关系，那么用 escape，而且这个方法一般不会用到。
5. 如果你需要**编码整个 URL，然后需要使用这个 URL，那么用 encodeURI**。
6. 当你需要**编码 URL 中的参数的时候，那么 encodeURIComponent** 是最好方法。

### /\*

a)在不使用 vue、react 的前提下写代码解决一下问题
一个 List 页面上，含有 1000 个条目的待办列表，现其中 100 项在同一时间达到了过期时间，需要在对应项的 text-node 里添加“已过期”文字。需要尽可能减少 dom 重绘次数以提升性能。
b)尝试使用 vue 或 react 解决上述问题
\*/

1. 原生方式

```javascript
//生成大量dom
let start = new Date().getTime();
let $ul = document.getElementById("wrap");

let el = document.createDocumentFragment();
let allKeys = [];
for (var i = 0; i < 1000; i++) {
  let li = document.createElement("li");
  li.dataset.key = i; //key
  li.innerHTML = i;
  el.appendChild(li);
  allKeys.push(i);
}
$ul.appendChild(el);

// 生成过期项 模拟服务端生成的数据
function getExpireKeys() {
  let keys = [];
  while (keys.length < 100) {
    let randomKey = Math.floor(Math.random() * 1000);
    if (keys.indexOf(randomKey) === -1) {
      keys.push(randomKey);
    } else {
      continue;
    }
  }
  return keys;
}

// 暴力项 逐项遍历
document.getElementById("expire1").onclick = function () {
  let expireKeys = getExpireKeys();
  let children = $ul.children;
  let start = Date.now();
  for (let i = 0; i < expireKeys.length; i++) {
    const element = document.querySelector(`[data-key="${expireKeys[i]}"]`);
    element.innerHTML = element.innerHTML + "已过期";
  }
};

//模板字符串 innerHtml替换
document.getElementById("expire2").onclick = function () {
  let expireKeys = getExpireKeys();
  const item = [];
  for (let i = 0; i < allKeys.length; i++) {
    item.push(
      `<li>${allKeys[i]} ${
        expireKeys.indexOf(allKeys[i]) !== -1 ? "已过期" : ""
      }</li>`
    );
  }
  $ul.innerHTML = item.join("");
};
```

2. vue 方式

```vue
// template
<button @click="setExpire">过期</button>
<ul>
  <li v-for="item in allKeys" :key="item.value">
    {{item.value}}
    {{item.expire ? '已过期' : ''}}
  </li>
</ul>

// script
<script>
export default {
  data() {
    return {
      allKeys: [], //所有项
      expireKeys: [], //过期项
    };
  },
  created() {
    for (var i = 0; i < 1000; i++) {
      this.allKeys.push({
        value: i,
        expire: false,
      });
    }
  },
  methods: {
    setExpire() {
      let keys = this.getExpireKeys();
      for (let i = 0; i < this.allKeys.length; i++) {
        if (keys.indexOf(this.allKeys[i].value) !== -1) {
          this.allKeys[i].expire = true;
        }
      }
    },
    // 生成过期项 模拟服务端生成的数据
    getExpireKeys() {
      let keys = [];
      while (keys.length < 100) {
        let randomKey = Math.floor(Math.random() * 1000);
        if (keys.indexOf(randomKey) === -1) {
          keys.push(randomKey);
        } else {
          continue;
        }
      }
      return keys;
    },
  },
};
</script>
```

### js 为什么设计成单线程

JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？这样能提高效率啊。

**JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？**

所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。

### post 的 ContentType 类型有哪些

Content-Type 字段来获知请求中的消息主体是用何种方式编码，

1. application/x-www-form-urlendcoded 表单
2. multipart/form-data 文件上传
3. application/json json
4. text/xml

## 编译相关

https://blog.csdn.net/zhouhao88410234/article/details/71190691/

1. 词法分析（Lexical analysis 或 Scanning）和词法分析程序（Lexical analyzer 或 Scanner）**确定有限状态机**
   词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，即**对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)**。词法分析程序实现这个任务。词法分析程序可以使用 lex 等工具自动生成。

2. 语法分析（Syntax analysis 或 Parsing）和语法分析程序（Parser）
   语法分析是编译过程的一个逻辑阶段。语法分析的任务是**在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确**.源程序的结构由上下文无关文法描述.

3. 语义分析（Syntax analysis）
   语义分析是编译过程的一个逻辑阶段. 语义分析的任务是对结构上正确的源程序进行**上下文有关性质的审查**, 进行类型审查.例如一个 C 程序片断:
   　　 int arr[2],b;
   　　 b = arr \* 10;
   　　源程序的结构是正确的.
   语义分析将审查类型并报告错误:不能在表达式中使用一个数组变量,赋值语句的右端和左端的类型不匹配.
