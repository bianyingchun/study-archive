1.索引结构
  1.树状形式转储索引
    branch: 0x180eb0a 25225994 (0: nrow: 9, level: 2) 
      branch: 0x180eca1 25226401 (-1: nrow: 405, level:1)
        leaf: 0x180eb0b 25225995 (-1: nrow: 359 rrow: 359)
        leaf: 0x180eb0c 25225996 (0: nrow: 359 rrow:359)
        leaf: 0x180eb0d 25225997 (1: nrow: 359 rrow:359)
    每一行的
      第一列表示节点类型：branch表示分支节点（包括根节点），而leaf则表示叶子节点；
      第二列表示十六进制表示的节点的地址；
      第三列表示十进制表示的节点的地址；
      第四列表示相对于前一个节点的位置，根节点从0开始计算，其他分支节点和叶子节点从-1开始计算；
      第五列的nrow表示当前节点中所含有的索引条目的数量。比如我们可以看到根节点中含有的nrow为9，表示根节点中含有9个索引条目，分别指向9个分支节点；
      第六列中的level表示分支节点的层级，对于叶子节点来说level都是0。第六列中的rrow表示有效的索引条目（因为索引条目如果被删除，不会立即被清除出索引块中。所以nrow减rrow的数量就表示已经被删除的索引条目数量）的数量，比如对于第一个leaf来说，其rrow为359，也就是说该叶子节点中存放了359个可用索引条目，分别指向表的359条记录。

  2.转储一个索引节点
   1. 根节点
    kdxcolev 2                                           //索引层级号，由于此处转储的是根节点，level为2
    KDXCOLEV Flags = ---                                 //
    kdxcolck 0                                           //表示该索引上是否正在发生修改块结构的事务
    kdxcoopc 0x80: pcode=0: iot flags=--- is converted=Y //表示内部操作代码
    kdxconco 2                                           //索引条目中列的数量
    kdxcosdc 0                                           //索引结构发生变化的数量，当修改某个索引键值时，该值增加
    kdxconro 8                                           //当前索引节点中索引条目的数量，但是不包括kdxbrlmc指针
    kdxcofbo 44=0x2c                                     //当前索引节点可用空间的起始点相对当前块的位移量
    kdxcofeo 7918=0x1eee                                 //当前索引节点可用空间的最尾端相对当前块的位移量
    kdxcoavs 7874                                        //当前索引块的中的可用空间总量，也就是kdxcofeo减去kdxcofbo得到的
    kdxbrlmc 25226401=0x180eca1                          //分支节点的地址，该分支节点存放了索引键值小于row#0所含有的最小值的所有节点信息
    kdxbrsno 0                                           //最后一个被修改的索引条目号，这里是0，表示该索引是新建的索引
    kdxbrbksz 8060                                       //可用数据块的地址空间

//-----------------以下就是在根节点中所记录的索引条目，再加上kdxbrlmc指向的第一个分支节点，可以看出该根节点共存放了9个分支节点。----------------
    row#0[8043] dba: 25226808=0x180ee38 
    col 0; len 8; (8): 31 30 30 30 30 33 39 32 
    col 1; len 3; (3): 01 40 1a 
    „„ 
    row#7[7918] dba: 25229599=0x180f91f 
    col 0; len 8; (8): 31 30 30 31 31 32 30 33 
    col 1; len 4; (4): 01 40 8f a5

    每个索引条目都指向一个分支节点，其中col 1表示所链接的分支节点的地址，该值经过一定的转换实际就是row#所在行的dba值。如果根节点下没有其他的分支节点，则col 1为TERM;col 0表示该分支节点所链接的最小键值。其转换方式非常复杂，比如对于row #0来说，col 0为31 30 30 30 30 30 30 33，则将其中每对值都使用函数to_number(NN,’XX’)的方式从十六进制转换为十进制，于是我们得到转换后的值：49,48,48,48,48,48,48,51，因为我们已经知道索引键值是char类型的，所以对每个值都运用chr函数就可以得到被索引键值为：10000003。实际上，对10000003运用dump函数得到的结果就是：49,48,48,48,48,48,48,51。所以我们也就知道，10000003就是dba为25226808的索引块所链接的最小键值.

   2.分支节点
    如果从根节点随便找一个分支节点进行转储,发现内容与根节点完全类似,只不过该索引块中所包含的索引条目(指向叶子节点)的数量更多了。

   3.叶子节点
    //只显示与分支节点不同的地方
    „„„ kdxlespl 0                               //当前叶子节点被拆分时未提交的事务数量
    kdxlende 0 //被删除的索引条目的数量
    kdxlenxt 25226403=0x180eca3// 当前叶子节点的下一个叶子节点的地址
    kdxleprv 25226400=0x180eca0 //当前叶子节点的上一个叶子节点的地址
    kdxledsz 0 //可用空间
    kdxlebksz 8036//
    //----------索引条目----------
    row#0[8018] flag: -----, lock: 0 
    col 0; len 8; (8): 31 30 30 30 30 33 39 33 
    col 1; len 6; (6): 01 40 2e 93 00 16 
    ...
    每个条目包含一个rowId指向表里的数据项。flag表示标记，例如删除标记等，lock表示锁定信息，col 0 表示索引键值。col1表示rowId(记录行在表里的物理地址)


2.索引的访问
  如何找到索引条目所在的数据块
  1.从根节点开始查找，顺序进行，从一个索引块调到另一个索引块。
  2.全表扫描，不需要访问上一个索引块，知道要访问所有的数据块，采用同步的方式分批同时获取多个数据块，这几批的数据块可能在物理上是分散在表里的。


3.管理机制
  1.插入管理
    1.在一个已经充满了数据的表上创建索引时索引是怎么管理的
      当在一个充满了数据的表上创建索引（create index命令）时，先扫描表里的数据并对其进行排序，然后生成叶子节点。生成所有的叶子节点以后，根据叶子节点的数量生成若干层级的分支节点，最后生成根节点。

  2.当一行接着一行向表里插入或更新或删除数据时，索引是怎么管理的
    1.当一开始在一个空的表上创建索引的时候，该索引没有根节点，只有一个叶子节点
    2.随着数据不断被插入表里，该叶子节点中的索引条目也不断增加，当该叶子节点充满了索引条目而不能再放下新的索引条目时，该索引就必须扩张，必须再获取一个可用的叶子节点。这时，索引就包含了两个叶子节点，但是两个叶子节点不可能单独存在的，这时它们两必须有一个上级的分支节点，其实这也就是根节点了。于是，现在，我们的索引应该具有3个索引块，一个根节点，两个叶子节点。
    (当第一个叶子节点充满以后，进行分裂时，先获得两个可用的索引块作为新的叶子节点，然后将当前该叶子节点里所有的索引条目拷贝到这两个新获得的叶子节点，最后将原来的叶子节点改变为根节点。)
    1.叶子节点的拆分：
      1.插入的键值不是最大值
        当一个非最大键值要进入索引，但是发现应进入的索引块不足以容纳当前键值时：
          1.从索引可用列表上获得一个新的索引数据块。
          2.将当前充满了的索引条目分成两部分，一部分是具有较小键值，另一部分时具有较大键值的。(将具有较大值的部分移入新的索引数据块，较小键值得部分不动)。
          3.将当前键值插入合适的索引块中，可能是原来空间不足的索引块，也可能是新的索引块。
          4.更新原来空间不足的索引块的kdxlenxt,指向新的索引块。
          5.更新位于原来空间不足的索引块右边的索引块里的kdxleprv，使其指向新的索引块。
          6.向原来空间不足的索引块的上一级的分支索引块中添加一个索引条目，该索引条目中保存新的索引块里的最小键值，以及新的索引块的地址。

      2.插入的键值是最大值
      省略上面步骤中的第2步，直接进入第3步，将新的键值插入新的索引块中。

    2.无分支节点的根节点的拆分
      当叶子节点越来越多，导致原来的根节点不足以存放新的索引条目（这些索引条目指向叶子节点）时，则该根节点必须进行分裂。当根节点进行分裂时
      1.从索引可用列表上获得两个新的索引数据块。 
      2.将根节点中的索引条目分成两部分，这两部分分别放入两个新的索引块，从而形成两个新的分支节点。 
      3.更新原来的根节点的索引条目，使其分别指向这两个新的索引块。 
      因此，这时的索引层次就变成了2层。同时可以看出，根节点索引块在物理上始终都是同一个索引块。

    3.分支节点
      随着数据量的不断增加,导致分支节点又要进行分裂。分支节点的分裂过程与根节点类似：
      1.从索引可用列表上获得一个新的索引数据块。 
      2.将当前满了的分支节点里的索引条目分成两部分，较小键值的部分不动，而较大键值的部分移入新的索引块。 
      3.将新的索引条目插入合适的分支索引块。 
      4.在上层分支索引块中添加一个新的索引条目，使其指向新加的分支索引块。

    4.有分支节点的根节点的拆分
      当数据量再次不断增加，导致原来的根节点不足以存放新的索引条目（这些索引条目指向分支节点）时，再次引起根节点的分裂，其分裂过程与前面所说的由于叶子节点的增加而导致的根节点分裂的过程是一样的。 3.2.1

  2.删除管理
    1.当删除表里的一条记录时，其对应于索引里的索引条目不会在物理上被删除，而只是做了一个删除标记
    2.当一个新的索引条目进入到一个索引叶子节点的时候，会检查该叶子节点里是否存在被标记为删除的索引条目，如果存在，则会将所有具有删除标记的索引条目从该叶子节点里物理的删除
    3.当一个新的索引条目进入到一个索引时，将当前所有被清空的叶子节点（该叶子节点中所有的索引条目都作了删除标记）收回，再次成为可用索引块。

    尽管被删除的索引条目所占用的空间大部分情况下能够被重用，但是会存在索引空间被浪费，造成数据块很多但是索引条目很少的情况，这就是索引碎片。
      1.不合理的较高的pctfree
      2.索引键值的持续增加，同时对索引键值按照顺序连续删除
      3.经常被删除或更新的键值，以后几乎不再被使用

  3.更新管理
    可以看成是删除和插入的结合，将更新的旧值对应的索引条目设置为删除标记，同时将更新后的值按顺序插入合适的索引块。

4.B+树索引的使用
  1.什么时候使用
    1.访问表中很少一部分行时使用索引才是有意义的。当访问高选择性并取出很少行时，对于这个字段添加B+树索引是有必要的。
      对于某些字段的选择性很低，例如sex只有两种选择，对于查询sex='M'得到的结果可能是50%的表中数据，这样建立b+树索引是没有必要的，相反某个字段的取值范围很广，几乎没有重复，此时使用b+树索引是最合适的。
    2.如果访问字段是高选择性的但是取出的行占据表中大部分数据时，不会使用B+树索引。例如查询某个大范围的时间范围查询（优化器会事先预估得到的行数，一般如果多于20%，就会进行全表扫描，不会使用索引）但是优化器的估值是不准确的。

5.联合索引
  联合索引还是一棵b+树，但是键值数量大于等于2，
  遵循最左原则
  好处（可以对第二个键值进行排序，因为索引本身在叶节点中已经排序了，可以避免多一次的排序操作）




