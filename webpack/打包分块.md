### Bundle Splitting vs Code Splitting

1. 打包分离：bundle splitting:为了更好的缓存创建更多，更小的文件（但仍然以每一个文件一个请求的方式加载）

2. 代码分离：Code splitting: 动态加载代码，所以用户只需要下载当前他正在浏览站点的这部分代码

### Bundle VS Chunk VS Module

1. module

   它指的就是我们在编码过程中有意识的封装和组织起来的代码片段。狭义上我们首先联想到的是碎片化的 React 组件，或者是 CommonJS 模块又或者是 ES6 模块，但是对 Webpack 和 Loader 而言，广义上的模块还包括样式和图片，甚至说是不同类型的文件

2. bundle & chunk

   包”(bundle) 就是把相关代码都打包进入的单个文件。如果你不想把所有的代码都放入一个包中，你可以把它们划分为多个包，也就是“块”(chunk) 中。从这个角度上看，“块”等于“包”，它们都是对代码再一层的组织和封装。

   如果必须要给一个区分的话，通常我们在讨论时，bundle 指的是所有模块都打包进入的单个文件，而 chunk 指的是按照某种规则的模块集合，chunk 的体积大于单个模块，同时小于整个 bundle

### 打包分离 (Bundle splitting)

打包分离背后的思想非常简单。如果你有一个体积巨大的文件，并且只改了一行代码，用户仍然需要重新下载整个文件。但是如果你把它分为了两个文件，那么用户只需要下载那个被修改的文件，而浏览器则可以从缓存中加载另一个文件。

```javascript
const path = require("path");
module.exports = {
  entry: path.resolve(__dirname, "src/index.js"),
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "[name].[contenthash].js",
  },
};
```

上述配置意味着当应用代码发生更改时新的文件名会生成,，这样就能迫使浏览器下载新的文件,所以当每次我向站点发布新的变更时，包的 contenthash 就会发生更改。以至于每次用户访问我们站点时不得不下载一个全新的文件

#### 哈希（hash）与性能

1. 为什么带哈希串的文件名会对浏览器缓存产生影响

为了每次访问时不让浏览器都重新下载同一个文件，我们通常会把这个文件返回的 HTTP 头中的 Cache-Control 设置为 max-age=31536000（一年）。这样以来，在一年之内用户访问这个文件时，都不会再次向服务器发送请求而是直接从缓存中读取，直到或者手动清除了缓存。

如果我中途修改了文件内容必须让用户重新下载怎么办？修改文件名就好了，不同的文件（名）对应不同的缓存策略。而一个哈希字符串就是根据文件内容产生的“签名”，每当文件内容发生更改时，哈希串也就发生了更改，文件名也就随之更改。这样一来，旧版本文件的缓存策略就会失效，浏览器就会重新加载新版本的该文件。

2. 为什么文件名里的哈希后缀是 contenthash？如果把 contenthash 替换成 hash 或者 chunkhash 有什么影响？

```javascript
const CleanWebpackPlugin = require("clean-webpack-plugin");
const MiniCssExtractPlugin = require("mini-css-extract-plugin");

module.exports = {
  entry: {
    module_a: "./src/module_a.js",
    module_b: "./src/module_b.js",
  },
  output: {
    filename: "[name].[hash].js",
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: "[name].[contenthash].css",
    }),
  ],
};
```

##### hash

hash 针对的是每一次构建（build）而言，每一次构建之后生成的文件所带的哈希都是一致的。它关心的是整体项目的变化，**只要有任意文件内容发生了更改，那么构建之后其他文件的哈希也会发生更改。**

很显然这不是我们需要的，如果 module_a 文件内容发生了更改，module_a 的打包文件的哈希应该发生变化，但是 module_b 不应该。这会导致用户不得不重新下载没有发生变化的 module_b 打包文件

##### chunkhash

chunkhash 基于的是每一个 chunk 内容的改变，如果是该 chunk 所属的内容发生了变化，那么只有该 chunk 的输出文件的哈希会发生变化，其它的不会。这听上去符合我们的需求。

在之前我们对 chunk 进行过定义，即是小单位的代码聚合形式。在上面的例子中以 entry 入口体现，也就是说每一个入口对应的文件就是一个 chunk。

##### contenthash

该哈希根据的是文件的内容。从这个角度上说，它和 chunkhash 是能够相互代替的。所以在“性能基线”代码中作者使用了 contenthash

### 分离第三方类库 vendor 类库

让我们把打包文件划分为 main.js 和 vendor.js

很简单，类似于:

```javascript
const path = require("path");

module.exports = {
  entry: path.resolve(__dirname, "src/index.js"),
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "[name].[contenthash].js",
  },
  optimization: {
    splitChunks: {
      chunks: "all", //把所有node_modules里的东西都放到vendors~main.js的文件中去
    },
  },
};
```

### 分离每一个 npm 包

我们的 vendors.js 承受着和开始 main.js 文件同样的问题——部分的修改会意味着重新下载所有的文件,所以为什么不把每一个 npm 包都分割为单独的文件？

```javascript
const path = require("path");
const webpack = require("webpack");

module.exports = {
  entry: path.resolve(__dirname, "src/index.js"),
  plugins: [
    new webpack.HashedModuleIdsPlugin(), // so that file hashes don't change unexpectedly
  ],
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "[name].[contenthash].js",
  },
  optimization: {
    runtimeChunk: "single",
    splitChunks: {
      chunks: "all",
      maxInitialRequests: Infinity,
      minSize: 0,
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name(module) {
            // get the name. E.g. node_modules/packageName/not/this/part.js
            // or node_modules/packageName
            const packageName = module.context.match(
              /[\\/]node_modules[\\/](.*?)([\\/]|$)/
            )[1];

            // npm package names are URL-safe, but some servers don't like @ symbols
            return `npm.${packageName.replace("@", "")}`;
          },
        },
      },
    },
  },
};
```

1. webpack 默认当分离打包输出文件时只允许最多 3 个文件，并且最小文件的尺寸是 30kb(如果存在更小的文件则把它们拼接起来)，
2. cacheGroups 是我们用来制定规则告诉 Webpack 应该如何组织 chunks 到打包输出文件的地方。我在这里对所有加载自 node_modules 里的 module 制定了一条名为 "vendor" 的规则。通常情况下，你只需要为你的输出文件的 name 定义一个字符串。但是我把 name 定义为了一个函数（当文件被解析时会被调用）。在函数中我会根据 module 的路径返回包的名称。结果就是，对于每一个包我都会得到一个单独的文件，比如 npm.react-dom.899sadfhj4.js
3. 为了能够正常发布 npm 包的名称必须是合法的 URL，所以我们不需要 encodeURI 对包的名词进行转义处理。但是我遇到一个问题是.NET 服务器不会给名称中包含@的文件提供文件服务，所以我在代码片段中进行了替换
4. 整个步骤的配置设置之后就不需要维护了——我们不需要使用名称引用任何的类库

### splitChunks 配置

splitChunk 间接使用 SplitChunkPlugin 实现对块的拆分功能。SplitChunksPlugin 的功能只有一个，就是 split——把代码分离出来。分离是相对于把所有模块都打包成一个文件而言，把单个大文件分离为多个小文件。

```javascript
splitChunks: {
  chunks: 'all',
},
```

chunks 有三个选项：initial、async 和 all。它指示应该优先分离同步（initial）、异步（async）还是所有的代码模块。这里的异步指的是通过动态加载方式（import()）加载的模块。

这里的重点是优先二字。以 async 为例，假如你有两个模块 a 和 b，两者都引用了 jQuery，但是 a 模块还通过动态加载的方式引入了 lodash。那么在 async 模式下，插件在打包时会分离出 lodash~for~a.js 的 chunk 模块，而 a 和 b 的公共模块 jQuery 并不会被（优化）分离出来，所以它可能还同时存在于打包后的 a.bundle.js 和 b.bundle.js 文件中。因为 async 告诉插件优先考虑的是动态加载的模块

### 把应用代码进行分离

```javascript
module.exports = {
  entry: {
    main: path.resolve(__dirname, "src/index.js"),
    ProductList: path.resolve(__dirname, "src/ProductList/ProductList.js"),
    ProductPage: path.resolve(__dirname, "src/ProductPage/ProductPage.js"),
    Icon: path.resolve(__dirname, "src/Icon/Icon.js"),
  },
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "[name].[contenthash:8].js",
  },
  plugins: [
    new webpack.HashedModuleIdsPlugin(), // so that file hashes don't change unexpectedly
  ],
  optimization: {
    runtimeChunk: "single",
    splitChunks: {
      chunks: "all",
      maxInitialRequests: Infinity,
      minSize: 0,
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name(module) {
            // get the name. E.g. node_modules/packageName/not/this/part.js
            // or node_modules/packageName
            const packageName = module.context.match(
              /[\\/]node_modules[\\/](.*?)([\\/]|$)/
            )[1];

            // npm package names are URL-safe, but some servers don't like @ symbols
            return `npm.${packageName.replace("@", "")}`;
          },
        },
      },
    },
  },
};
```

### 稍等，那段 Webpack 配置代码究竟是怎么回事

此时你的疑惑可能是，optimization 选项里的配置怎么就把 vendor 代码分离出来了？

接下来的这一小节会针对 Webpack 的 Optimization 选项做讲解。我个人并非 Webpack 的专家，配置和对应的描述功能也并非一一经过验证，也并非全部都覆盖到，如果有纰漏的地方还请大家谅解。

optimization 配置如其名所示，是为优化代码而生。如果你再仔细观察，大部分配置又在 splitChunk 字段下，因为它间接使用 SplitChunkPlugin 实现对块的拆分功能（这些都是在 Webpack 4 中引入的新的机制。在 Webpack 3 中使用的是 CommonsChunkPlugin，在 4 中已经不再使用了。所以这里我们也主要关注的是 SplitChunkPlugin 的配置）从整体上看，SplitChunksPlugin 的功能只有一个，就是 split——把代码分离出来。**分离是相对于把所有模块都打包成一个文件而言，把单个大文件分离为多个小文件。**

在最初分离 vendor 代码时，我们只使用了一个配置

```js
splitChunks: {
  chunks: 'all',
},
```

chunks 有三个选项：initial、async 和 all。它指示应该优先分离同步（initial）、异步（async）还是所有的代码模块。这里的异步指的是通过动态加载方式（import()）加载的模块。

这里的重点是优先二字。以 async 为例，假如你有两个模块 a 和 b，两者都引用了 jQuery，但是 a 模块还通过动态加载的方式引入了 lodash。那么在 async 模式下，插件在打包时会分离出 lodash~for~a.js 的 chunk 模块，而 a 和 b 的公共模块 jQuery 并不会被（优化）分离出来，所以它可能还同时存在于打包后的 a.bundle.js 和 b.bundle.js 文件中。因为 async 告诉插件优先考虑的是动态加载的模块

接下来聚焦第二段分离每个 npm 包的 Webpack 配置中

maxInitialRequests 和 minSize 确实就是插件自作多情的杰作了。插件自带一些分离 chunk 的规则：如果即将分离的 chunk 文件体积小于 30KB 的话，那么就不会将该 chunk 分离出来；并且限制并行下载的 chunk 最大请求个数为 3 个。通过覆盖 minSize 和 maxInitialRequests 配置就能够重写这两个参数。注意这里的 maxInitialRequests 和 minSize 是在 splitChunks 根目录中的，我们暂且称它为全局配置

cacheGroups 配置才是最重要，它允许自定义规则分离 chunk。并且每条 cacheGroups 规则下都允许定义上面提到的 chunks 和 minSize 字段用于覆盖全局配置（又或者将 cacheGroups 规则中 enforce 参数设为 true 来忽略全局配置）

cacheGroups 里默认自带 vendors 配置来分离 node_modules 里的类库模块，它的默认配置如下：

```js
cacheGroups: {
  vendors: {
    test: /[\\/]node_modules[\\/]/,
    priority: -10
  },
```

如果你不想使用它的配置，你可以把它设为 false 又或者重写它。这里我选择重写，并且加入了额外的配置 name 和 enforce:

```js
vendors: {
  test: /[\\/]node_modules[\\/]/,
  name: 'vendors',
  enforce: true,
},
```

最后介绍以上并没有出现但是仍然常用的两个配置：priority 和 reuseExistingChunk

- reuseExistingChunk: 该选项只会出现在 cacheGroups 的分离规则中，意味重复利用现有的 chunk。例如 chunk 1 拥有模块 A、B、C；chunk 2 拥有模块 B、C。如果 reuseExistingChunk 为 false 的情况下，在打包时插件会为我们单独创建一个 chunk 名为 common~for~1~2，它包含公共模块 B 和 C。而如果该值为 true 的话，因为 chunk 2 中已经拥有公共模块 B 和 C，所以插件就不会再为我们创建新的模块

- priority: 很容易想象到我们会在 cacheGroups 中配置多个 chunk 分离规则。如果同一个模块同时匹配多个规则怎么办，priority 解决的这个问题。注意所有默认配置的 priority 都为负数，所以自定义的 priority 必须大于等于 0 才行

### 网络请求变多的时候是不是会变得更慢？

在 HTTP/1.1 的情况下确实会如此，但是在 HTTP/2 中不会

### 每一个 webpack 打包后的文件里会不会有多余的模板代码？

有的

但什么是“模板代码”？

想象一下如果整个项目只有文件 app.js，那么最终的输出的打包文件也只是 app.js 的文件内容而已。

但是如果 app.js 文件内容是空的话（一行代码都没有），那么最终的打包文件也是空的吗？

不是，Webpack 为了实现编译之后的模块化，它会将你的代码进行一次封装，这些用于封装的代码会占用一部分体积，是每个模块都必须存在的，所以成为模板代码

[原文链接](https://zhuanlan.zhihu.com/p/66212099)
