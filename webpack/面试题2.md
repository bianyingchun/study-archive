### webpack 中如何处理图片的？

在 webpack 中有两种处理图片的 loader：

- file-loader：解决 CSS 等中引入图片的路径问题；(解决通过 url,import/require()等引入图片的问题)
- url-loader：当图片小于设置的 limit 参数值时，url-loader 将图片进行 base64 编码(当项目中有很多图片，通过 url-loader 进行 base64 编码后会减少 http 请求数量，提高性能)，大于 limit 参数值，则使用 file-loader 拷贝图片并输出到编译目录中

### 8. webpack 几种 hash 的实现原理

- hash 是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的 hash 值都会更改，并且全部文件都共用相同的 hash 值。(粒度整个项目)
- chunkhash 是根据不同的入口进行依赖文件解析，构建对应的 chunk(模块)，生成对应的 hash 值。只有被修改的 chunk(模块)在重新构建之后才会生成新的 hash 值，不会影响其它的 chunk。(粒度 entry 的每个入口文件)
- contenthash 是跟每个生成的文件有关，每个文件都有一个唯一的 hash 值。当要构建的文件内容发生改变时，就会生成新的 hash 值，且该文件的改变并不会影响和它同一个模块下的其它文件。(粒度每个文件的内容)

## tree shaking 的原理是什么?

删除无用代码

1. ES6 Module 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块
2. 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码
   common.js 和 es6 中模块引入的区别

## 禁止 Babel 将 ES6 编译到 CommonJS

在很多应用中已经必不可少。不幸的是，它会让 tree shaking 变得困难。如果你使用，它会将你的 ES6 编译到可兼容性更好的 CommonJS。

问题在于对于 CommonJS，tree shaking 非常困难，而且 webpack 不知道哪些需要消除掉。不过呢，好在有一个很简单的解法：配置 babel-preset-env，让其保持 ES6 不动，不要翻译。具体的配置放在你配置 Babel 的地方(.babelrc 或则 package.json)：

```js
{
  "presets": [
    ["env", {
      "modules": false
    }]
  ]
}
```

简单地配置"modules":false 即可，webpack 会分析所有文件中模块的依赖关系，然后剔除那些没有使用的代码。并且，这个  处理不会有兼容问题，因为 webpack 最终会将代码转换到兼容的版本。

## babel 是什么，原理是？

1. babel 是一个 JavaScript 编译器。他把最新版的 javascript 编译成当下可以执行的版本，简言之，利用 babel 就可以让我们在当前的项目中随意的使用这些新最新的 es6，甚至 es7 的语法。

- 语法转换，一般是高级语言特性的降级；

- Polyfill（垫片/补丁）特性的实现和接入；

- 源码转换，比如 JSX 等。

2. Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）。

- 解析
  将代码解析成抽象语法树（AST），每个 js 引擎（比如 Chrome 浏览器中的 V8 引擎）都有自己的 AST 解析器，而 Babel 是通过 Babylon 实现的。在解析过程中有两个阶段：词法分析和语法分析，词法分析阶段把字符串形式的代码转换为令牌（tokens）流，令牌类似于 AST 中节点；而语法分析阶段则会把一个令牌流转换成 AST 的形式，同时这个阶段会把令牌中的信息转换成 AST 的表述结构。

- 转换
  在这个阶段，Babel 接受得到 AST 并通过 babel-traverse 对其进行深度优先遍历，在此过程中对节点进行添加、更新及移除操作。这部分也是 Babel 插件介入工作的部分。

- 生成
  将经过转换的 AST 通过 babel-generator 再转换成 js 代码，过程就是深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串

## webpack5 vs webpack4 // todo

https://www.cnblogs.com/Hsong/p/15894515.html

## webpack 如何实现持久化缓存

### 什么是持久化缓存

持久化缓存是 webpack5 所带来的非常强大的特性之一。一句话概括就是构建结果持久化缓存到本地的磁盘，二次构建(非 watch 模块)直接利用磁盘缓存的结果从而跳过构建过程当中的 resolve、build 等耗时的流程，从而大大提升编译构建的效率。

持久化缓存主要解决的就是优化编译流程，减少编译耗时的问题，通过全新的缓存系统的设计使得整个构建流程更加的高效和安全。在此之前官方或者社区也有不少解决编译耗时，提高编译效率的方案。

## webpack 插件如何实现

webpack 本质是一个事件流机制，核心模块：Tapable(Sync + Async) Hooks 构造出 === Compiler(编译) + compilation(创建 bundles)

**compiler 对象代表了完整的 webpack 环境配置**。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options、loader 和 plugin。当在 webpack 环境中应用一插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境
compiler 上暴露的一些常用的钩子：
1. run :编译器开始读取记录前
2. compile ：新的compilation 创建之前
3. compilation： 新的compilation 创建之后
4. make ：完成一次编译之前
5. emit ：生成文件到output之前
6. afterEmit :生成文件到output之后
7. assetEmitted：生成文件的时候执行
8. done ：一次编译后执行
**compilation 对象代表了一次资源版本构建**。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation,从而生成一个新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态的信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用

创建一个插件函数，在其 prototype 上定义 apply 方法，指定一个 webpack 自身的事件钩子,函数内部处理 webpack 内部实例的特定数据,处理完成后，调用 webpack 提供的回调函数

```javascript
// ./remove-comments-plugin.js

class RemoveCommentsPlugin {
  apply(compiler) {
    // 通过 compiler 对象的 hooks 属性访问到 emit 钩子，再通过 tap 方法注册一个钩子函数，这个方法接收两个参数：
    // 第一个是插件的名称，我们这里的插件名称是 RemoveCommentsPlugin；
    // 第二个是要挂载到这个钩子上的函数；
    compiler.hooks.emit.tap("RemoveCommentsPlugin", (compilation) => {
      // compilation => 可以理解为此次打包的上下文
      // compiler 和 compilation两者的区别在于，前者代表了整个 webpack 从启动到关闭的生命周期，而 compilation 只代表一次单独的编译。
      for (const name in compilation.assets) {
        if (name.endsWith(".js")) {
          const contents = compilation.assets[name].source();
          const noComments = contents.replace(/\/\*{2,}\/\s?/g, "");
          compilation.assets[name] = {
            source: () => noComments,
            size: () => noComments.length,
          };
        }
      }
    });
  }
}
```
### Compiler 和 Compilation 的区别

Compiler 代表了整个 Webpack 从启动到关闭的生命周期
Compilation 只是代表了一次新的编译，只要文件有改动，compilation 就会被重新创建。
### webpack 实现原理

https://segmentfault.com/a/1190000021494964
