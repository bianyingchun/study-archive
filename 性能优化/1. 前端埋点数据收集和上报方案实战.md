## 定义

对用户行为或业务过程进行捕获、处理、发送的相关技术和实施过程。一般用于推荐系统的反馈、用户行为的监控和分析、新功能或者运营活动效果的统计分析等

## 常见埋点属性

1. uid
   用户 id,未登录特殊标识 id
2. url
   当前事件触发页面的 url
3. eventTime
4. 触发埋点的时间戳
5. localTime
   触发埋点时的用户本地时间，使用标准 YYYY-MM-DD HH:mm:ss 格式表示，方便后期直接使用字符串查询
6. deviceType
   当前用户使用的设备类型，比如 apple、三星、chrome 等
7. deviceId
   当前用户使用的设备 id
8. osType
   当前用户使用的系统类型，比如 windows、macos、ios、android 等
9. osVersion
   当前用户使用的系统版本
10. appVersion
    当前应用版本
11. appId
    当前应用 id
12. extra
    自定义数据，一般是序列化的字符串，且数据结构应保持稳定

## 常见埋点事件

1. 页面停留

- 上报时机 ： 当前页面切换或者页面卸载时，
- 描述： 记录前一页浏览时间

2. pv
   - 上报时机：进入页面时, 页面访问次数，
   - 描述：uv 只需要根据 deviceId 过滤
3. 交互事件
   - 用户交互事件触发时
   - 比如点击、长按等
4. 逻辑事件
   1. 符合逻辑条件时
   2. 比如登陆、跳转页面等

## 性能指标

### 1. FP

### 2. FCP

### 3. FMP

### 4. TTI

## 错误数据采集方案

目前所能捕捉的错误有三种:

1. 资源加载错误，通过 addEventListener('error', callback, true)在捕获阶段捕捉资源加载失败错误。

2. js 执行错误，通过 window.onerror 捕捉 js 错误。

   - 跨域的脚本会给出 "Script Error." 提示，拿不到具体的错误信息和堆栈信息。此时需要在 script 标签增加 crossorigin="anonymous"属性，同时资源服务器需要增加 CORS 相关配置，比如 Access-Control-Allow-Origin: \*

   - promise 错误，通过 addEventListener('unhandledrejection', callback)捕捉 promise 错误，但是没有发生错误的行数，列数等信息，只能手动抛出相关错误信息。

```js
// 在捕获阶段，捕获资源加载失败错误
addEventListener(
  "error",
  (e) => {
    const target = e.target;
    if (target != window) {
      monitor.errors.push({
        type: target.localName,
        url: target.src || target.href,
        msg: (target.src || target.href) + " is load error",
        time: Date.now(),
      });
    }
  },
  true
);

// 监听 js 错误
window.onerror = function (msg, url, row, col, error) {
  monitor.errors.push({
    type: "javascript",
    row: row,
    col: col,
    msg: error && error.stack ? error.stack : msg,
    url: url,
    time: Date.now(),
  });
};

// 监听 promise 错误 缺点是获取不到行数数据
addEventListener("unhandledrejection", (e) => {
  monitor.errors.push({
    type: "promise",
    msg: (e.reason && e.reason.msg) || e.reason || "",
    time: Date.now(),
  });
});
```

## 数据上报方案

1. 如果数据上报接口与业务系统使用同一域名，浏览器对请求并发量有限制，所以存在网络资源竞争的可能性。
2. 浏览器通常在页面卸载时会忽略异步 ajax 请求，如果需要必须进行数据请求，一般在 unload 或者 beforeunload 事件中创建同步 ajax 请求，以此延迟页面卸载。从用户侧角度，就是页面跳转变慢。

### beacon

1. Beacon 请求使用 HTTP POST 方法，并且不需要有响应。

2. Beacon 请求能确保在页面触发 unload 之前完成初始化。

通俗的讲就是，Beacon 可将数据异步发送至服务端，且能够保证在页面卸载完成前发送请求（解决 ajax 页面卸载会终止请求的问题）。使用方法如下：

```js
navigator.sendBeacon(url, data);
```

1. 其中 data 参数是可选的，它的类型可以为 ArrayBufferView, Blob, DOMString 或者 FormData。

2. 如果浏览器成功地将 beacon 请求加入到待发送的队列里，这个方法将会返回 true ，否则将会返回 false 使用 Beacon 时需要后台需要使用 post 方法接收参数。

3. 考虑到跨域问题，后台还需要改造接口配置 CORS。同时请求头必须满足 CORS-safelisted request-header，其中 content-type 的类型必须为 application/x-www-form-urlencoded, multipart/form-data, 或者 text/plain。

```js
type ContentType =
  | "application/x-www-form-urlencoded" 
  | "multipart/form-data"
  | "text/plain";

const serilizeParams = (params: object) => {
  return window.btoa(JSON.stringify(params));
};

function sendBeacon(url: string, params: object) {
  const formData = new FormData();
  formData.append("params", serlizeParams(params));
  navigator.sendBeacon(url, formData);
}
```

### image

sendBeacon 的兼容性问题是不可避免的，不过可以充分利用大部分浏览器会在页面卸载前完成图片的加载的特性，通过在页面添加 img 的方式上报数据。

```js
function sendImage(url: string, params: object) {
  const img = new Image();

  img.style.display = "none";

  const removeImage = function () {
    img.parentNode.removeChild(img);
  };

  img.onload = removeImage;
  img.onerror = removeImage;

  img.src = `${url}?params=${serilizeParams(params)}`;

  document.body.appendChild(img);
}
```

由于 img 图片为 get 请求方式，不同服务器针对 uri 的长度有限制，长度超过限制时会出现 HTTP 414 错误，所以还要注意上报频率，减少一次性上传的属性过多。

### 兼容方案

优先使用 sendBeacon 的方式，Image 方式作为 fallback。

```js
function sendLog(url: string, params: object) {
    if（navigator.sendBeacon) {
        sendBeacon(url, params)
    } else {
        sendImage(url, params)
    }
}
```
