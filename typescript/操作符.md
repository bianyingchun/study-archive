# 运算符

## TypeScript 中 ?.、??、!、!.、\_、\*\* 等符号的含义？

- ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行。
  const a = obj?.xxx
- ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数。
  ```js
  const i = undefined;
  const k = i ?? 5;
  console.log(k); // 5
  ```
- ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined
  ```js
   function handler (arg: string | null | undefined) {
   let str: string = arg!;   // 没毛病
   str.split('');
   // ...
  ```
  }
- !. 在变量名后添加，可以断言排除 undefined 和 null 类型
- \_ 数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324。 => 编译后（1101324）
- \*\* 求幂

# 操作符

键值获取 keyof
keyof 可以获取一个类型所有键值，返回一个联合类型，如下：

```js
type Person = {
  name: string;
  age: number;
}
type PersonKey = keyof Person;  // PersonKey得到的类型为 'name' | 'age'
```

keyof 的一个典型用途是限制访问对象的 key 合法化，因为 any 做索引是不被接受的。

```js
function getValue (p: Person, k: keyof Person) {
  return p[k];  // 如果k不如此定义，则无法以p[k]的代码格式通过编译
}
```

总结起来 keyof 的语法格式如下
**类型 = keyof 类型**

# 实例类型获取 typeof

typeof 是获取一个对象/实例的类型，如下：

```js
const me: Person = { name: "gzx", age: 16 };
type P = typeof me; // { name: string, age: number | undefined }
const you: typeof me = { name: "mabaoguo", age: 69 }; // 可以通过编译
```

typeof 只能用在具体的对象上，这与 js 中的 typeof 是一致的，并且它会根据左侧值自动决定应该执行哪种行为。

```js
const typestr = typeof me; // typestr的值为"object"
```

typeof 可以和 keyof 一起使用(因为 typeof 是返回一个类型嘛)，如下：

```js
type PersonKey = keyof typeof me;   // 'name' | 'age'
```

总结起来 typeof 的语法格式如下：
**类型 = typeof 实例对象**

# 遍历属性 in

**in 只能用在类型的定义中，可以对枚举类型进行遍历**，如下：

```js
// 这个类型可以将任何类型的键值转化成number类型
type TypeToNumber<T> = {
  [key in keyof T]: number
}
```

keyof 返回泛型 T 的所有键枚举类型，key 是自定义的任何变量名，中间用 in 链接，外围用[]包裹起来(这个是固定搭配)，冒号右侧 number 将所有的 key 定义为 number 类型。
于是可以这样使用了：

```js
const obj: TypeToNumber<Person> = { name: 10, age: 10 };
```

总结起来 in 的语法格式如下：
**[ 自定义变量名 in 枚举类型 ]: 类型**
