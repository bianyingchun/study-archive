## 索引类型(keyof)

js 中的 Object.keys 大家肯定都用过, 获取对象的键值, ts 中的 keyof 和他类似, 可以用来获取对象类型的键值:

```js
type A = keyof {a:1,b:'123'} // 'a'|'b'
type B = keyof [1,2] // '0'|'1'|'push'... , 获取到内容的同时, 还得到了Array原型上的方法和属性(实战中暂时没遇到这种需求, 了解即可)
```

可以获得键值, 也可以获取对象类型的值的类型:

```js
type A = { a: 1, b: "123" };
type C = A["a"]; // 等于type C = 1;
let c: C = 2; // 错误, 值只能是1
```

## 映射类型(Readonly, Pick, Record 等...)

映射类型比较像修改类型的工具函数, 比如 Readonly 可以把每个属性都变成只读:

```js
type A = { a: number, b: string };
type A1 = Readonly<A>; // {readonly a: number;readonly b: string;}
```

打开 node_modules/typescript/lib 文件夹可以找到 lib.es5.d.ts, 在这我们能找到 Readonly 的定义:

```js
type Readonly<T> = {
readonly [P in keyof T]: T[P];
};
```

其实不是很复杂, 看了本节课前面前面的内容, 这个很好理解是吧:

- 定义一个支持泛型的类型别名, 传入类型参数 T.
- 通过 keyof 获取 T 上的键值集合.
- 用 in 表示循环 keyof 获取的键值.
- 添加 readonly 标记.

### Partial<T>, 让属性都变成可选的

```js
type A = { a: number, b: string };
type A1 = Partial<A>; // { a?: number; b?: string;}
```

### Required<T>, 让属性都变成必选

```js
type A = { a?: number, b?: string };
type A1 = Required<A>; // { a: number; b: string;}
```

### Pick<T,K>, 只保留自己选择的属性, K 代表要保留的属性键值

```js
type A = Pick<{ a: number, b: string, c: boolean }, "a" | "b">;
type A1 = Pick<A, "a" | "b">; // {a:number,b:string}
```

### Omit<T,K> 实现排除已选的属性

```js
type A = { a: number, b: string };
type A1 = Omit<A, "a">; // {b:string}
```

### Record<K,T>, 创建一个类型,K 代表键值的类型, T 代表值的类型

```js
type A1 = Record<string, string>; // 等价{[k:string]:string}
```

## Exclude & Extract

### Exclude： 从一个联合类型中排除掉属于另一个联合类型的子集

来看下，Exclude 使用形式是 Exclude<T, S>，如果 T 中的属性在 S 不存在那么就会返回。

```js
interface A {
    show: boolean,
    hidden: boolean,
    status: string
}

interface B {
    show: boolean,
    name: string
}

type outPut = Exclude<keyof A, keyof B>
```

### Extract：跟 Exclude 相反，从从一个联合类型中取出属于另一个联合类型的子集

举一反三，如果 Exclude 是取差集，那么 Extract 就是取交集。会返回两个联合类型中相同的部分。

```js
interface A {
    show: boolean,
    hidden: boolean,
    status: string
}

interface B {
    show: boolean,
    name: string
}

type outPut = Extract<keyof A, keyof B>
```

### NonNullable, 剔除 T 中的 undefined 和 null

```js
type A1 = NonNullable<number | string | null | undefined>; // number|string
```

### ReturnType, 获取 T 的返回值的类型

```js
type A1 = ReturnType<() => number>; // number
```

### InstanceType, 返回 T 的实例类型

ts 中类有 2 种类型, 静态部分的类型和实例的类型, 所以 T 如果是构造函数类型, 那么 InstanceType 可以返回他的实例类型:

```js
interface A {
  a: HTMLElement;
}

interface AConstructor {
  new(): A;
}

function create(AClass: AConstructor): InstanceType<AConstructor> {
  return new AClass();
}
```

### Parameters 获取函数参数类型

返回类型为元祖, 元素顺序同参数顺序.

```js
interface A {
  (a: number, b: string): string[];
}

type A1 = Parameters<A>; // [number, string]
```

### ConstructorParameters 获取构造函数的参数类型

和 Parameters 类似, 只是 T 这里是构造函数类型.

```js
interface AConstructor {
  new(a: number): string[];
}

type A1 = ConstructorParameters<AConstructor>; // [number]
```

### extends(条件类型)

```js
T extends U ? X : Y
```

用来表示类型是不确定的, 如果 U 的类型可以表示 T, 那么返回 X, 否则 Y. 举几个例子:

```js
type A = string extends '123' ? string :'123' // '123'
type B = '123' extends string ? string :123 // string
```

明显 string 的范围更大, '123'可以被 string 表示, 反之不可.

### infer(类型推断)

单词本身的意思是"推断", 实际表示在 extends 条件语句中声明待推断的类型变量. 我们上面介绍的映射类型中就有很多都是 ts 在 lib.d.ts 中实现的, 比如 Parameters:

```js
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;
```

上面声明一个 P 用来表示...args 可能的类型, 如果(...args: infer P)可以表示 T, 那么返回...args 对应的类型, 也就是函数的参数类型, 反之返回 never.
注意: 开始的 T extends (...args: any) => any 用来校验输入的 T 是否是函数, 如果不是 ts 会报错, 如果直接替换成 T 不会有报错, 会一直返回 never.
应用 infer
接下来我们利用 infer 来实现"删除元祖类型中第一个元素", 这常用于简化函数参数, 这有一个我之前的应用

```js
export type Tail<Tuple extends any[]> = ((...args: Tuple) => void) extends ((a: any, ...args: infer T) => void) ? T : never;
```


