## 基本使用

泛型可以用在普通类型定义，类定义、函数定义上，如下：

```js
// 普通类型定义
type Dog<T> = { name: string, type: T }
// 普通类型使用
const dog: Dog<number> = { name: 'ww', type: 20 }

// 类定义
class Cat<T> {
  private type: T;
  constructor(type: T) { this.type = type; }
}
// 类使用
const cat: Cat<number> = new Cat<number>(20); // 或简写 const cat = new Cat(20)

// 函数定义
function swipe<T, U>(value: [T, U]): [U, T] {
  return [value[1], value[0]];
}
// 函数使用
swipe<Cat<number>, Dog<number>>([cat, dog])  // 或简写 swipe([cat, dog])
```

### 泛型推导与默认值

### 泛型约束

**泛型名 extends 类型**
有时候，我们需要限定类型，这时候使用 extends 关键字即可。

```js
function sum<T extends number>(value: T[]): number {
  let count = 0;
  value.forEach(v => count += v);
  return count;
}
```

这样你就可以以 sum([1,2,3])这种方式调用求和函数，而像 sum(['1', '2'])这种是无法通过编译的。
泛型约束也可以用在多个泛型参数的情况。

```js
function pick<T, U extends keyof T>(){};
```

这里的意思是限制了 U 一定是 T 的 key 类型中的子集，这种用法常常出现在一些泛型工具库中。
extends 的语法格式简单总结如下，注意下面的类型既可以是一般意义上的类型也可以是泛型。
**泛型名 extends 类型**

### 泛型条件

上面提到 extends，其实也可以当做一个三元运算符，如下：
```js
T extends U? X: Y
```
这里便不限制 T 一定要是 U 的子类型，如果是 U 子类型，则将 T 定义为 X 类型，否则定义为 Y 类型。
注意，生成的结果是分配式的。
举个例子，如果我们把 X 换成 T，如此形式：T extends U? T: never。
此时返回的 T，是满足原来的 T 中包含 U 的部分，可以理解为 T 和 U 的交集。
所以，extends 的语法格式可以扩展为
泛型名 A extends 类型 B ? 类型 C: 类型 D

### 泛型推断

infer 的中文是“推断”的意思，一般是搭配上面的泛型条件语句使用的，所谓推断，就是你不用预先指定在泛型列表中，在运行时会自动判断，不过你得先预定义好整体的结构。举个例子

```js
type Foo<T> = T extends {t: infer Test} ? Test: string
```

首选看 extends 后面的内容，{t: infer Test}可以看成是一个包含 t 属性的类型定义，这个 t 属性的 value 类型通过 infer 进行推断后会赋值给 Test 类型，如果泛型实际参数符合{t: infer Test}的定义那么返回的就是 Test 类型，否则默认给缺省的 string 类型。
举个例子加深下理解：

```js
type One = Foo<number>; // string，因为number不是一个包含t的对象类型
type Two = Foo<{ t: boolean }>; // boolean，因为泛型参数匹配上了，使用了infer对应的type
type Three = Foo<{ a: number, t: () => void }>; // () => void，泛型定义是参数的子集，同样适配
```

**infer 用来对满足的泛型类型进行子类型的抽取**，有很多高级的泛型工具也巧妙的使用了这个方法。

# 泛型工具

## Partial<T> 让属性都变成可选的

```ts
type Partial<T> {
    [key in keyof T]? : T[key]
}
```

## Record<K,T>, 是将 K 中所有属性值转化为 T 类型，我们常用它来申明一个普通 object 对象。

```js
type Record<K extends keyof any,T> = {
  [key in K]: T
}
```

这里特别说明一下，keyof any 对应的类型为 number | string | symbol，也就是可以做对象键(专业说法叫索引 index)的类型集合。

```ts
const obj: Record<string, string> = { name: "zhang san", tag: "打工人" };
```

## Pick<T, K> 将 T 类型中的 K 键列表提取出来，生成新的子键值对类型。

```ts
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};
```

我们还是用上面的 Animal 定义，看一下 Pick 如何使用。

```js
const bird: Pick<Animal, "name" | "age"> = { name: "bird", age: 1 };
```

## Exclude<T, U> ,在 T 类型中，去除 T 类型和 U 类型的交集，返回剩余的部分。

```js
type Exclude<T, U> = T extends U ? never : T
```

注意这里的 extends 返回的 T 是原来的 T 中和 U 无交集的属性，而任何属性联合 never 都是自身，具体可在上文查阅。
举个例子

```js
type T1 = Exclude<"a" | "b" | "c", "a" | "b">; // "c"
type T2 = Exclude<string | number | (() => void), Function>; // string | number
```

## Omit<T, K>

此工具可认为是适用于键值对对象的 Exclude，它会去除类型 T 中包含 K 的键值对。

```js
type Omit = Pick<T, Exclude<keyof T, K>>
```

在定义中，第一步先从 T 的 key 中去掉与 K 重叠的 key，接着使用 Pick 把 T 类型和剩余的 key 组合起来即可。
还是用上面的 Animal 举个例子：

```js
const OmitAnimal: Omit<Animal, "name" | "age"> = {
  category: "lion",
  eat: () => {
    console.log("eat");
  },
};
```

可以发现，Omit 与 Pick 得到的结果完全相反，一个是取非结果，一个取交结果。

## ReturnType<T>

此工具就是获取 T 类型(函数)对应的返回值类型：

```js
type ReturnType<T extends (...args: any) => any>
  = T extends (...args: any) => infer R ? R : any;
```
看源码其实有点多，其实可以稍微简化成下面的样子：
```ts
type ReturnType<T extends func> = T extends () => infer R ? R: any;
```
通过使用 infer 推断返回值类型，然后返回此类型，如果你彻底理解了 infer 的含义，那这段就很好理解。
举个例子：
```js
function foo(x: string | number): string | number { /*..*/ }
type FooType = ReturnType<foo>;  // string | number
```
### Required<T>
此工具可以将类型 T 中所有的属性变为必选项。
```js
type Required<T> = {
  [P in keyof T]-?: T[P]
}
```
这里有一个很有意思的语法-?，你可以理解为就是 TS 中把?可选属性减去的意思。

