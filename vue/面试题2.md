### Vue 子组件和父组件的执行顺序

1. 加载渲染过程

- 父 beforeCreate
- 父 created
- 父 beforeMount
- 子 beforeCreate
- 子 created
- 子 beforeMount
- 子 mounted
- 父 mounted

2. 更新

- 父 beforeUpdate
- 子 beforeUpdate
- 子 updated
- 父 updated

### 简述 Vue 的基本原理

### 说一说你对 vue 响应式理解？

#### 答题思路：

啥是响应式？
为什么 vue 需要响应式？
它能给我们带来什么好处？
vue 的响应式是怎么实现的？有哪些优缺点？
vue3 中的响应式的新变化

#### 回答范例：

1. 所谓数据响应式就是能够使**数据变化可以被检测并对这种变化做出响应**的机制。
2. mvvm 框架中要解决的一个核心问题是连接数据层和视图层，通过数据驱动应用，数据变化，视图更新，要做到这点的就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理。
3. 以 vue 为例说明，通过数据响应式加上虚拟 DOM 和 patch 算法，可以使我们只需要操作数据，完全不用接触繁琐的 dom 操作，从而大大提升开发效率，降低开发难度。
4. vue2 中的数据响应式会根据数据类型来做不同处理，如果是对象则采用 Object.defineProperty()的方式定义数据拦截，当数据被访问或发生变化时，我们感知并作出响应；如果是数组则通过覆盖该数组原型的方法，扩展它的 7 个变更方法，使这些方法可以额外的做更新通知，从而作出响应。这种机制很好的解决了数据响应化的问题，但在实际使用中也存在一些缺点：比如初始化时的递归遍历会造成性能损失；新增或删除属性时需要用户使用 Vue.set/delete 这样特殊的 api 才能生效；对于 es6 中新产生的 Map、Set 这些数据结构不支持等问题。
   
5. 为了解决这些问题，vue3 重新编写了这一部分的实现：利用 ES6 的 Proxy 机制代理要响应化的数据，它有很多好处，编程体验是一致的，不需要使用特殊 api，初始化性能和内存消耗都得到了大幅改善；另外由于响应化的实现代码抽取为独立的 reactivity 包，使得我们可以更灵活的使用它，我们甚至不需要引入 vue 都可以体验。

### vue2 的响应式原理

#### 核心实现类:

- Observer : 它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新
- Dep : 用于收集当前响应式对象的依赖关系,每个响应式对象包括子对象都拥有一个 Dep 实例（里面 subs 是 Watcher 实例数组）,当数据有变更时,会通过 dep.notify()通知各个 watcher。
- Watcher : 观察者对象 , 实例分为渲染 watcher (render watcher),计算属性 watcher (computed watcher),侦听器 watcher（user watcher）三种。

Watcher 和 Dep 的关系
watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者, dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新。

#### 依赖收集

1. initState 时,对 computed 属性初始化时,触发 computed watcher 依赖收集
2. initState 时,对侦听属性初始化时,触发 user watcher 依赖收集
3. render()的过程,触发 render watcher 依赖收集
4. re-render 时,vm.render()再次执行,会移除所有 subs 中的 watcher 的订阅,重新赋值。

#### 派发更新

组件中对响应的数据进行了修改,触发 setter 的逻辑
调用 dep.notify()
遍历所有的 subs（Watcher 实例）,调用每一个 watcher 的 update 方法。

#### 原理

整体思路是数据劫持+观察者模式
对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)。

### Vue2 和 Vue3 中的响应式原理对比，分别的具体实现思路

##### 答题思路：

可以先说 vue2 响应式原理
然后说出它的问题
最后说出 vue3 是怎么解决的

##### 回答范例：

vue2 数据响应式实现根据对象类型做不同处理，如果是 object，则通过 Object.defineProperty(obj,key,descriptor)拦截对象属性访问

```javascript
function defineReactive(obj, key, val) {
  Object.defineProperty(obj, key, {
    get() {
      return val;
    },
    set(v) {
      val = v;
      notify();
    },
  });
}
```

如果是数组，则覆盖数组的 7 个变更方法实现变更通知

```javascript
const arrayProto = Array.prototype;
const arrayMethods = Object.create(arrayProto);

["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(
  function (method) {
    const original = arrayProto[method];
    def(arrayMethods, method, function mutator(...args) {
      const result = original.apply(this, args);
      notify();
      return result;
    });
  }
);
```

可以看到 vue2 中有几个问题：

1. 初始化时需要遍历对象所有 key，如果对象层级较深，性能不好
2. 通知更新过程需要维护大量 dep 实例和 watcher 实例，额外占用内存较多
3. 动态新增、删除对象属性无法拦截，只能用特定 set/delete api 代替
4. 不支持新的 Map、Set 等数据结构

vue3 中为了解决以上问题，使用原生的 Proxy 代替：

```javascript
function defineReactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key);
      return Reflect.get(target, key);
    },
    set(target, key, val) {
      Reflect.set(target, key, val);
      trigger(target, key);
    },
    deleteProperty(target, key) {
      Reflect.deleteProperty(target, key);
      trigger(target, key);
    },
  });
}
```

可以同时支持 object 和 array，
动态属性增、删都可以拦截，
新增数据结构均支持，
对象嵌套属性运行时递归，用到才代理，
也不需要维护特别多的依赖关系，性能取得很大进步。

### 发布订阅模式和观察者模式的区别

1. 从结构上分析

   1. 观察者模式里，只有两个角色：观察者 和 目标者（也可以叫被观察者）
   2. 发布订阅模式里，不仅仅只有发布者和订阅者，还有一个事件中心（也可以叫控制中心）

2. 从关系上分析

   1. 观察者和目标者，是松耦合的关系
   2. 发布者和订阅者，则完全不存在耦合

3. 从使用角度分析
   1. 观察者模式，多用于单个应用内部（上面说过 Vue 中响应式数据变化就是观察者模式）
   2. 发布订阅模式，则更多应用于跨应用的模式，比如我们常用的 消息中间件

### Vue 组件 data 为什么必须是函数 ?

因为**组件是可以复用的**,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。
所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在以上问题。

### vue 是如何对数组方法进行变异的

1. Vue 通过原型拦截的方式重写了数组的 7 个方法,
2. 首先获取到这个数组的 ob,也就是它的 Observer 对象
3. 如果有新的值,就调用 observeArray 对新的值进行监听
4. 然后手动调用 notify,通知 render watcher,执行 update

```js
const arrayProto = Array.prototype;
export const arrayMethods = Object.create(arrayProto);
const methodsToPatch = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse",
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method];
  def(arrayMethods, method, function mutator(...args) {
    const result = original.apply(this, args);
    const ob = this.__ob__;
    let inserted;
    switch (method) {
      case "push":
      case "unshift":
        inserted = args;
        break;
      case "splice":
        inserted = args.slice(2);
        break;
    }
    if (inserted) ob.observeArray(inserted); // notify change
    ob.dep.notify();
    return result;
  });
});

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};
```

### vue 的渲染过程

1. 调用 compile 函数,生成 render 函数字符串 ,编译过程如下:
1. Parse 分析模板，将其解析为模板 AST。
1. Transform 将模板 AST 转换为用于描述渲染函数的 JavaScript AST。 (标记不需要每次都更新的内容,diff 算法会直接跳过静态节点,从而减少比较的过程,优化了 patch 的性能)
1. Generate 根据 JavaScriptAST 生成渲染函数代码。
1. 调用 new Watcher 函数,监听数据的变化,当数据发生变化时，Render 函数执行生成 vnode 对象
1. 调用 patch 方法，对比新旧 vnode 对象，通过 DOM diff 算法,添加、修改、删除真正的 DOM 元素

### Vue 和 React 对比

https://blog.csdn.net/xgangzai/article/details/115301290

#### 1. 核心思想

1. vue 灵活易用的渐进式框架，进行数据拦截/代理，它对侦测数据的变化更敏感、更精确，支持双向绑定
2. React 推崇函数式编程（纯组件），数据不可变以及单向数据流,当然需要双向的地方也可以手动实现， 比如借助 onChange 和 setState 来实现。

#### 2. 组件写法差异

1. Vue 推荐的做法是 template 的单文件组件格式(简单易懂，从传统前端转过来易于理解),即 html,css,JS 写在同一个文件(vue 也支持 JSX 写法)

2. React 推荐的做法是 JSX + inline style, 也就是把 HTML 和 CSS 全都写进 JavaScript 中,即 all in js;

#### 3. diff 算法不同

Vue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。

相比 React 的 Diff 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

#### 4. 响应式原理不同

1. Vue 依赖收集，自动优化，数据可变。递归监听 data 的所有属性,直接修改。当数据改变时，自动找到引用组件重新渲染。
2. React 基于状态机，手动优化，数据不可变，需要 setState 驱动新的 state 替换老的 state。当数据改变时，以组件为根目录，默认全部重新渲染, 所以 React 中会需要 shouldComponentUpdate 这个生命周期函数方法来进行控制

### v-if 和 v-for 哪个优先级更高？

(补充：3.x 版本中 v-if 总是优先于 v-for 生效。)

##### 思路分析：总分总模式

先给出结论
为什么是这样的
它们能放一起吗
如果不能，那应该怎样
总结

##### 回答范例：

1. v-for 优先于 v-if 被解析

2. 我曾经做过实验，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件

3. 实践中也不应该把它们放一起，因为哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表。

4. 通常有两种情况下导致我们这样做：

   1. 为了过滤列表中的项目 (比如 v-for="user in users" v-if="user.isActive")。此时定义一个计算属性 (比如 activeUsers)，让其返回过滤后的列表即可。

   2. 为了避免渲染本应该被隐藏的列表 (比如 v-for="user in users" v-if="shouldShowUsers")。此时把 v-if 移动至容器元素上 (比如 ul、ol)即可。

### 能说说双向绑定以及它的实现原理吗？

https://segmentfault.com/a/1190000006599500

#### 什么是双向绑定

MVVM 业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来 ，这里的控制层的核心功能便是 “数据双向绑定”，理解 ViewModel
它的主要职责就是：

1. 数据变化后更新视图
2. 视图变化后更新数据

它的两个重要组成
3. 监听器（Observer）：对所有数据的属性进行监听
4. 解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数

#### 双向绑定的好处

使用 v-model 可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好，通常在表单项上使用 v-model

#### 双向绑定的原理

https://segmentfault.com/a/1190000006599500
流程：

1. new Vue()首先执行初始化，对 data 执行响应化处理，这个过程发生 Observe 中

2. 同时对模板执行编译，找到其中动态绑定的数据，从 data 中获取并初始化视图，这个过程发生在 Compile 中

3. 同时定义⼀个更新函数和 Watcher，将来对应数据变化时 Watcher 会调用更新函数

4. 由于 data 的某个 key 在⼀个视图中可能出现多次，所以每个 key 都需要⼀个管家 Dep 来管理多个 Watcher

5. 将来 data 中数据⼀旦发生变化，会首先找到对应的 Dep，通知所有 Watcher 执行更新函数

vue数据双向绑定是**通过数据劫持结合发布者-订阅者模式的方式来实现的。**


1. 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。

2. 实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。

3. 实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）

#### 可能的追问：

1. v-model 和 sync 修饰符有什么区别
2. 自定义组件使用 v-model 如果想要改变事件名或者属性名应该怎么做

### v-model 和 sync 修饰符有什么区别

1. 2.x
   1. 在组件上使用 v-model 相当于绑定 value prop 并触发 input 事件； v-model 是 <ChildComponent :value="pageTitle" @input="pageTitle = $event" />的简写;
   2. sync 对某一个 prop 进行“双向绑定”.sync 为 <ChildComponent :title="pageTitle" @update:title="pageTitle = $event"/>的简写
   
2. 3.x v-model 是<ChildComponent :modelValue="pageTitle" @update:modelValue="pageTitle = $event"/>的简写； 可以作为.sync 修饰符的替代

```js
<ChildComponent v-model:title="pageTitle" v-model:content="pageContent" />

<!-- 是以下的简写： -->

<ChildComponent
  :title="pageTitle"
  @update:title="pageTitle = $event"
  :content="pageContent"
  @update:content="pageContent = $event"
/>
```

### 自定义组件使用 v-model 如果想要改变事件名或者属性名应该怎么做

如果想要更改 prop 或事件名称，则需要在 ChildComponent 组件中添加 model 选项：

```js
model: {
    prop: 'title',
    event: 'change'
  },
```

#### 处理 v-model 修饰符

1. 添加到组件 v-model 的修饰符将通过 modelModifiers prop 提供给组件
2. 对于带参数的 v-model 绑定，生成的 prop 名称将为 arg + "Modifiers"：
   https://v3.cn.vuejs.org/guide/component-custom-events.html#%E5%A4%84%E7%90%86-v-model-%E4%BF%AE%E9%A5%B0%E7%AC%A6

```js
const app = Vue.createApp({
  data() {
    return {
      myText: "",
    };
  },
});

app.component("my-component", {
  props: {
    modelValue: String,
    modelModifiers: {
      default: () => ({}),
    },
  },
  emits: ["update:modelValue"],
  methods: {
    emitValue(e) {
      let value = e.target.value;
      if (this.modelModifiers.capitalize) {
        value = value.charAt(0).toUpperCase() + value.slice(1);
      }
      this.$emit("update:modelValue", value);
    },
  },
  template: `<input
    type="text"
    :value="modelValue"
    @input="emitValue">`,
});

app.mount("#app");
```

### 你了解 vue 中的 diff 算法吗

https://github.com/febobo/web-interview/issues/24
https://blog.csdn.net/weixin_43638968/article/details/112686317

##### 是什么

diff 算法是一种通过同层的树节点进行比较的高效算法

其有两个特点：

- 比较只会在同层级进行, 不会跨层级比较
- 在 diff 比较的过程中，循环从两边向中间比较

diff 算法的在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较

##### 比较过程

patch 过程遵循**深度优先、同层比较**的策略。

###### patch 函数

当数据发生改变时，set 方法会调用 Dep.notify 通知所有订阅者 Watcher，订阅者就会调用 patch 给真实的 DOM 打补丁，更新相应的视图

patch 函数前两个参数位为 oldVnode 和 Vnode ，分别代表新的节点和之前的旧节点，主要做了四个判断：

1. 没有新节点，直接触发旧节点的 destory 钩子
2. 没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm
3. 旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode 去处理这两个节点
4. 旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点

###### patchVnode 函数

patchVnode 主要做了几个判断：

1. 新节点是否是文本节点，如果是，则直接更新 dom 的文本内容为新节点的文本内容
2. 只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新 DOM，并且添加进父节点
3. 只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把 DOM 删除。
4. 新节点和旧节点如果都有子节点，则处理比较更新子节点 updateChildren

###### updateChildren 函数

updateChildren 主要做了以下操作：

- 设置新旧 VNode 的头尾指针
- 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用 patchVnode 进行 patch 重复流程、调用 createElem 创建一个新节点，从哈希表寻找 key 一致的 VNode 节点再分情况操作

oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有 4 种比较方式：newStartIndex 和 oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了 key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx > EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。

### 你知道 key 的作用吗？

vue 中 key 值的作用可以分为两种情况来考虑。

key 可以管理可复用的元素，减少不必要的元素的重新渲染,也要让必要的元素能够重新渲染。

1. 第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是**用来标识一个独立的元素。**

2. 第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了**高效的更新渲染虚拟 DOM**。

### vue 组件的通信方式

[vue 中 8 种组件通信方式, 值得收藏!](https://segmentfault.com/a/1190000020053344)

#### 思路分析：总分

总述知道的所有方式
按组件关系阐述使用场景

##### 回答范例：

父子组件

1. props
2. $emit/$on
3. $parent / $children
4. ref
5. $attrs / $listeners

兄弟组件

1.  $parent
2.  event
3.  vuex

跨层级关系

1. provide/inject
2. $root
3. eventbus
4. vuex

### 简单说一说你对 vuex 理解？

回答策略：3w1h

首先给 vuex 下一个定义
vuex 解决了哪些问题，解读理念
什么时候我们需要 vuex
你的具体用法
简述原理，提升层级
首先是官网定义：

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

回答范例：

1. vuex 是 vue 专用的状态管理库。它**以全局方式集中管理应用的状态，并且可以保证状态变更的可预测性**。
2. vuex 主要解决的问题是**多组件之间状态共享**的问题，利用各种组件通信方式，我们虽然能够做到状态共享，但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出现问题，也会使程序逻辑变得复杂。vuex 通过把组件的共享状态抽取出来，**以全局单例模式管理**，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简洁的单向数据流动，我们的代码将变得更结构化且易维护。
3. vuex 并非必须的，它帮我们管理共享状态，但却带来更多的概念和框架。如果我们不打算开发大型单页应用或者我们的应用并没有大量全局的状态需要维护，完全没有使用 vuex 的必要。一个简单的 store 模式就足够了。反之，Vuex 将会成为自然而然的选择。
4. 我在使用 vuex 过程中有如下理解：首先是对核心概念的理解和运用，将全局状态放入 state 对象中，它本身一棵状态树，组件中使用 store 实例的 state 访问这些状态；然后有配套的 mutation 方法修改这些状态，并且只能用 mutation 修改状态，在组件中调用 commit 方法提交 mutation；如果应用中有异步操作或者复杂逻辑组合，我们需要编写 action，执行结束如果有状态修改仍然需要提交 mutation，组件中调用这些 action 使用 dispatch 方法派发。最后是模块化，通过 modules 选项组织拆分出去的各个子模块，在访问状态时注意添加子模块的名称，如果子模块有设置 namespace，那么在提交 mutation 和派发 action 时还需要额外的命名空间前缀。
5. vuex 在实现单项数据流时需要做到数据的响应式，通过源码的学习发现是**借用了 vue 的数据响应化特性实现的，它会利用 Vue 将 state 作为 data 对其进行响应化处理，从而使得这些状态发生变化时，能够导致组件重新渲染**。

### 为什么要用 Vuex 或者 Redux

Redux/vuex 主要解决的问题是**多组件之间状态共享**的问题，利用各种组件通信方式，我们虽然能够做到状态共享，但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出现问题，也会使程序逻辑变得复杂,代码难以维护。vuex/redux 通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简洁的单向数据流动，我们的代码将变得更结构化且易维护。

### 说一下 Vuex 的原理以及自己的理解

https://www.jianshu.com/p/6e45e6814d1c
![vuex](./vuex.webp)
核心流程：

1. Vue Components 是我们的 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions；

2. 我们在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，我们不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中；

3. 然后 Mutations 就去改变（Mutate）State 中的数据；

4. 当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。

### Redux 和 Vuex 有什么区别，说一下他们的共同思想

#### Redux 和 Vuex 区别

##### 使用方式

1. 在 Vuex 中，$store  被直接注入到了组件实例中，因此可以比较灵活的使用：

   - 使用  dispatch  和  commit  提交更新
   - 通过  mapState  或者直接通过  this.$store  来读取数据

2. 在 Redux 中，我们每一个组件都需要显示的用  connect  把需要的  props  和  dispatch  连接起来。

另外 Vuex 更加灵活一些，组件中既可以  dispatch action 也可以  commit updates，而 Redux 中只能进行  dispatch，并不能直接调用 reducer 进行修改。

##### 从实现原理上来说，最大的区别是两点：

1. Redux 使用的是不可变数据，而 Vuex 的数据是可变的。Redux 每次都是用新的 state 替换旧的 state，而 Vuex 是直接修改

2. Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而 Vuex 其实和 Vue 的原理一样，是通过  getter/setter 来比较的（如果看 Vuex 源码会知道，其实他内部直接创建一个 Vue 实例用来跟踪数据变化）

而这两点的区别，其实也是因为 React 和 Vue 的设计理念上的区别。React 更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue 更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用 React，小型项目用 Vue 的感觉。

###### 共同思想

- 单一的数据源
- 变化可以预测
- 本质上:Redux 和 Vuex 都是对 MVVM 思想的服务，将数据从视图中抽离的一种方案
- 形式上:Vuex 借鉴了 Redux，将 store 作为全局的数据中心，进行数据管理
