### 前端路由实现原理(对比 react,vue)

### 单页面应用和传统服务端渲染的差异比较

### Vue.js 虚拟 DOM 的优缺点

1.  优点

- **保证性能下限**： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；

- **无需手动操作 DOM**： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
- **跨平台**： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

2. 缺点
   **无法进行极致优化**： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。比如 VScode 采用直接手动操作 DOM 的方式进行极端的性能优化

### SPA 的定义以及优缺点。

1. 仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

2. 优点
   - 用户体验好，快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染
   - 服务器压力小
   - 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；
3. 缺点
   - 首屏渲染等待时长： 必须得加载完毕，才能渲染出首屏
   - seo 不友好：爬虫只能拿到一个 div，认为页面是空的，不利于 seo
   - 前进、后退管理
     由于单页 Web 应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理

### keep-alive 的理解

1. keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染
2. 一般结合路由和动态组件一起使用，用于缓存组件；
3. 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 **exclude 的优先级较高** ；
4. 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。

### 实现真实 dom 转变成虚拟 dom

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style></style>
  </head>
  <body>
    <div id="root" class="tt">
      <div title="tt1">hello1</div>
      <div title="tt2">hello2</div>
      <div title="tt3">hello3</div>
      <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
      </ul>
    </div>

    <script>
      // 用内存去表述DOM
      // 将真实DOM转化为虚拟DOM
      // <div />  => {tag:'div'}   元素转化
      // 文本节点 => {tag:undefined,value:'文本节点'}   文本节点转化
      // <div title="1" class="c"  />  => { tag:'div',data:{ title:'1',class:"c" } }   多属性转化
      // <div><div /></div> => {tag:'div',children:[{ tag:'div' }]}

      // 用构造函数来 进行以上转换
      // 这一次我们用class语法

      class VNode {
        // 构造函数
        constructor(tag, data, value, type) {
          // tag:用来表述 标签  data：用来描述属性  value：用来描述文本 type：用来描述类型
          this.tag = tag && tag.toLowerCase(); //文本节点时 tagName是undefined
          this.data = data;
          this.value = value;
          this.type = type;
          this.children = [];
        }
        appendChild(vnode) {
          this.children.push(vnode);
        }
      }
      /**
    利用递归 来遍历DOM元素 生成虚拟DOM
    Vue中的源码使用 栈结构  ，使用栈存储 父元素来实现递归生成
    */
      function getVNode(node) {
        let nodeType = node.nodeType;
        let _vnode = null;

        if (nodeType === 1) {
          // 元素
          let nodeName = node.nodeName; //元素名 什么标签？
          let attrs = node.attributes; //属性  伪数组 元素上的属性
          let _attrObj = {};

          for (let i = 0; i < attrs.length; i++) {
            //attrs[ i ] 属性节点（nodeType == 2) 是对象
            _attrObj[attrs[i].nodeName] = attrs[i].nodeValue; //attrs[ i ].nodeName:属性名 attrs[ i ].nodeValue：属性值
          }
          _vnode = new VNode(nodeName, _attrObj, undefined, nodeType); //标签名（DIV UI LI...）、所有属性对象、value值（只有文本标签有）、type类型(是元素还是文本)
          // 考虑node的子元素
          let childNodes = node.childNodes;
          for (let i = 0; i < childNodes.length; i++) {
            _vnode.appendChild(getVNode(childNodes[i])); //递归
          }
        } else if (nodeType === 3) {
          // 文本节点
          _vnode = new VNode(undefined, undefined, node.nodeValue, nodeType); //无标签名、无属性、有value、有type
        }
        return _vnode;
      }

      let root = document.querySelector("#root");

      let vroot = getVNode(root); //虚拟DOM
      console.log(vroot);
      // 将vNode转化为真正的DOM
      function parseNode(vnode) {
        // 在真正的vue中 也是使用递归+栈 数据类型
        // 创建真实的DOM
        let type = vnode.type; //拿到虚拟DOM的type,元素？文本？
        let _node = null; //用来放创建出来的元素  真实node
        if (type === 3) {
          // 文本节点
          return document.createTextNode(vnode.value); //直接创建文本节点
        } else if (type === 1) {
          // 元素节点
          _node = document.createElement(vnode.tag); //用tag名创建对应的标签

          // 属性
          let data = vnode.data; //键值对类型  真正的vue中药比这复杂的多（事件、指令等）
          Object.keys(data).forEach((key) => {
            let attrName = key; //属性名
            let attrValue = data[key]; //属性值
            _node.setAttribute(attrName, attrValue); //社会元素的属性
          });
          // 子元素
          let children = vnode.children;
          children.forEach((subvnode) => {
            _node.appendChild(parseNode(subvnode)); //将子元素放进去  递归转换子元素
          });
          return _node;
        }
      }

      let dom2 = parseNode(vroot); //虚拟dom转换成真实dom
      console.log(dom2); //打印出来的DOM和真实dom是一样的
    </script>
  </body>
</html>
```
