# 第四章 响应式系统的设计

1. 响应系统的根本实现原理
   在本章中，我们首先介绍了副作用函数的关系。**一个响应式数据最基本的实现依赖于对“读取”和“设置”操作的拦截，从而在副作用函数与响应式数据之间建立联系。当“读取”操作发生时，我们将当前执行的副作用函数存储到“桶”中;当“设置”操作发生时，再将副作用函数从“桶”里取出并执行。**这就是响应系统的根本实现原理。

接着，我们实现了一个相对完善的响应系统。

```js
const bucket = new WeakMap();
const toProxy = new WeakMap(); //缓存代理过后的响应式数据 target ->observed，原始数据 -> 可响应数据
const toRaw = new WeakMap(); //缓存被代理过的原始数据 observed -> target，可响应数据 -> 原始数据
//存储effct
const targetMap = new WeakMap();
const handler = {
  get(target, key, receiver) {
    const res = Reflect.get(target, key, receiver);
    // effect 收集
    track(target, key);
    return isObject(res) ? reactive(res) : res;
  },
  set(target, key, value, receiver) {
    const type = Object.prototype.hasOwnProperty.call(target, key)
      ? "set"
      : "add";
    const result = Reflect.set(target, key, value, receiver);
    trigger(target, key, type);
    return result;
  },
  deleteProperty(target, key) {
    const hadKey = Object.prototype.hasOwnProperty.call(target, key);
    const res = Reflect.deleteProperty(target, key);
    if (res && hadKey) trigger(target, key, "delete");
  },
};
// reactive
function reactive(target) {
  let observed = toProxy.get(target);
  if (observed) {
    //缓存代理过了
    return observed;
  }
  if (toRaw.has(target)) {
    //已经是响应式数据
    return target;
  }
  observed = new Proxy(target, handlers);
  toProxy.set(target, observed); //缓存observed
  toRaw.set(observed, target); //缓存target
  return observed;
}
// 2. 使用副作用函数栈，防止函数嵌套导致内存副作用函数执行会覆盖activeEffect的值，外层的响应式数据收集到的依赖还是内层函数。
let effectStack = [];
let activeEffect = null;

function effect(fn, options = {}) {
  const effectFn = () => {
    //清理依赖
    cleanup(effectFn);
    activeEffect = effectFn;
    effectStack.push(effectFn);
    const res = fn();
    effectStack.pop();
    activeEffect = effectStack[effectStack.length - 1]; //新增
    return res;
  };
  effect.options = options;
  //用来存储与该副作用函数相关联的依赖集合
  effectFn.deps = [];
  //   立即执行
  if (!options.lazy) {
    effectFn();
  }
  return effectFn;
}
const ITERATE_KEY = Symbol();
// 依赖收集，跟踪订阅effect，追踪变化
function track(target, key) {
  if (!activeEffect) return;
  let depsMap = bucket.get(target);
  if (!depsMap) bucket.set(target, (depsMap = new Map()));
  let deps = depsMap.get(key);
  if (!deps) depsMap.set(key, (deps = new Set()));
  deps.add(activeEffect);
  //  activeEffect.deps 为与当前副作用函数相关联的依赖集合
  activeEffect.deps.push(deps);
}

//  触发更新，触发副作用函数重新执行
function trigger(target, key, type) {
  //拿到所有target的订阅
  const depsMap = targetMap.get(target);
  if (!depsMap) return; //没有订阅
  const effects = depsMap.get(key);
  const effectsToRun = new Set();

  effects.forEach((effectFn) => {
    if (effectFn !== activeEffect) {
      effectsToRun.add(effectFn);
    }
  });
  if (type === "add" || type === "delete") {
    const iterateEffects = depsMap.get(ITERATE_KEY);
    iterateEffects &&
      erateEffects.forEach((effectFn) => {
        if (effectFn != activeEffect) {
          effectsToRun.add(effectFn);
        }
      });
  }
  effectsToRun.forEach((effectFn) => {
    if (effectFn.options.scheduler) {
      // 调度器执行
      effectFn.options.scheduler(effectFn);
    } else {
      effectFn();
    }
  });
}
/**
 * 2. 避免无限循环：如果trigger触发的副作用函数与当前正在执行的副作用函数相同，则不触发执行。
 * obj.foo = obj.foo + 1;
 */

// 1.分支切换
/**
 * effect(()=>{
 * document.body.innerText = obj.ok ? obj.text ? 'not'，
 * })
 * 当obj.ok 为true时，副作用函数被obj.text收集的依赖收集。当obj.ok改为false时，触发副作用函数执行。由于obj.text不会被读取，所以理想情况是副作用函数不应该被obj.text收集依赖。
 * 解决思路：每次副作用函数执行时，先把他从所有与之关联的依赖集合中删除，执行完毕后，会重新建立新的联系。
 */
function cleanup(effectFn) {
  for (let i = 0; i < effectFn.deps.length; i++) {
    const deps = effectFn.deps[i];
    //从依赖集合中移除
    deps.delete(effectFn);
  }
  effectFn.deps.length = 0;
}
```

#### 1. 使用 weakMap 配合 Map 构建了新的“桶”结构，从而能够在响应式数据与副作用函数之间建立更加精确的联系。

我们也介绍了 WeakMap 与 Map 这两个数据结构之间的区别。**WeakMap 是弱引用的，它不影响垃圾回收器的工作**。当用户对一个对象没有引用关系时，WeakMap 不会阻止垃圾回收器回收该对象。

#### 2. 分支切换导致的冗余副作用:

1.  这个问题会导致副作用函数进行**不必要的更新**
2.  为了解决这个问题，**我们需要在每次副作用函数重新执行之前，清除上一次建立的响应联系，而当副作用函数重新执行后，会再次建立新的响应联系**，新的响应联系中不存在冗余副作用问题，从而解决了问题。
3.  但在此过程中，我们还遇到了遍历 Set 数据结构导致无限循环的新问题在调用 forEach 遍历 Set 集合时，如果一个值已经被访问过了，但这个值被删除并重新添加到集合，如果此时 forEach 遍历没有结束，那么这个值会重新被访问。**解决方案是建立一个新的 Set 数据结构用来遍历。**

#### 3. 使用副作用函数栈， 解决嵌套的副作用函数的问题。

1.  在实际场景中，嵌套的副作用函数发生在组件嵌套的场景中，即父子组件关系。这时为了避免在响应式数据与副作用函数之间建立的响应联系发生错乱，我们需要使用副作用函数栈来存储不同的副作用函数。
2.  当一个副作用函数执行完毕后，将其从栈中弹出。当读取响应式数据的时候，被读取的响应式数据只会与当前栈顶的副作用函数建立响应联系，从而解决问题。

##### 对响应式数据的读取和设置操作发生在同一个副作用数内。副作用函数无限递归地调用自身，导致溢出的问题，

解决办法很简单， 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行

#### 4. 响应系统的可调度性 scheduler。

1.  所谓可调度，**指的是当 trigger 动作触发作用函数重新执行时，有能力决定副作用函数执行的时机、次数以及方式**。
2.  为了实现调度能力，我们为 effect 函数增加了第二个选项参数，可以通过 scheduler 选项指定调用器，这样用户可以通过满度器自行完成任务的调度。
3.  我们还讲解了如何通过调度器实现任务去重，即通过一个微任务队列对任务进行缓存，从而实现去重。

#### 5. 计算属性 computed

1. 计算属性实际上是一个**懒执行的副作用函数**，我们通过 lazy 选项使得副作用函数可以执行。
2. 被标记为懒执行的副作用函数可以通过手动方式让其执行。利用这个特点，我们设计了计算属性，**当读取计算属性的值时，只需要手动执行副作用函数即可。**
3. **当计算属性依赖的响应式数据发生变化时，会通过 scheduler 将 dirty 标记设置 true，代表“脏”。这样，下次读取计算属性的值时，我们会重新计算真正的值。**

```js
// computed
// 惰性求值，缓存
function computed(getter) {
  let value;
  let dirty = true;
  const effectFn = effect(getter, {
    lazy: true,
    scheduler() {
      if (!dirty) {
        dirty = true;
        //当计算属性依赖的响应式数据变化时，派发通知，通知运行访问该计算属性的 activeEffect
        trigger(obj, "value");
      }
    },
  });
  const obj = {
    get value() {
      if (dirty) {
        // 只有数据为脏的时候才会重新计算
        value = effectFn();
        dirty = false;
      }
      //依赖收集，收集运行访问该计算属性的 activeEffect
      track(obj, "value");
      return value;
    },
  };
  return obj;
}
```

#### watch 的实现原理。

1.  它本质上利用了副作用函数重新执行时的可调度性。一个 watch 会创建一 effect，当这个 effect 依赖的响应式数据发生变化时，会执行该 effect 的调度器函数，即 scheduler。这里的 scheduler 可以理解为“回调”，所以我们需要 scheduler 中执行用户通过 watch 注册的回调函数即可。
2.  立即执行回调的 watch，新的 immediate 选项来实现，
3.  控制回调函数的执行时机，通过 flush 选项来指定回调函数具体的执行时机，本质上是利用了调用器和异步的微任务队列。
4.  onInvalidate。它是一个函数，用来注册过期回调。
    过期的副作用函数,它会导致竞态问题，为了解决这个问题，Vue.js 为 watch 的回调函数设计了第三个参数，即 onInvalidate。它是一个函数，用来注册过期回调。每当 watch 的回调函数执行之前，会优先执行用户通过 onInvalidate 注册的过期回调。这样，用户就有机会在过期回调中将上一次的副作用标记为“过期”，从而解决竞态问题。

```js
// source可以为响应式对象或getter函数,如果是函数类型，说明直接传递了getter函数，这时直接使getter 函数;如果不是函数类型，那么调用 traverse函数递归地读取。
/**
 * source:()=>{} | object
dValue, newValue, onInvalidate :Function)// 在watch内部每次检测到变更后，在副作用函数执行之前，先调用onInvalidate函数。
 * options:{
 * immeditate:true, //立即执行回调
 * flush:'post'|'pre' // 1. post:异步执行，pre:同步执行
 * }
 * cb(ol
 */
function watch(source, cb, options = {}) {
  let getter;
  if (typeof source === "function") getter = source;
  else getter = () => traverse(source);
  let oldValue, newValue;
  let cleanup;
  function onInvalidate(fn) {
    cleanup = fn;
  }

  const job = () => {
    newValue = effectFn();
    // 调用cb之前，先调用过期函数
    if (cleanup) cleanup();
    cb(oldValue, newValue, onInvalidate);
    oldValue = newValue;
  };
  const effectFn = effect(() => getter(), {
    lazy: true,
    scheduler() {
      // 放到微任务队列，从而实现异步延迟执行
      if (options.flush === "post") {
        Promise.resolve().then(job);
      } else {
        job();
      }
    },
  });
  if (options.immediate) {
    //立即执行回调
    job();
  } else {
    oldValue = effectFn();
  }
}
// 进行递归的读取操作，代替硬编码的方式，这样就能读取一个对象上的任意属性，从而当任意属性发生变化时都能够触发回调函数执行。
function traverse(value, seen = new Set()) {
  if (typeof value !== "object" || value === null || seen.has(value)) {
    return;
  }
  // 避免循环引用造成的死循环
  seen.add(value);
  for (const k in value) {
    traverse(value[k], seen);
  }
  return value;
}
```

# 第五章：非原始值 和 原始值的 响应式方案

## 原始值响应式方案

用非原始值去包裹原始值

```js
// 原始值
function ref(val) {
  const wrapper = {
    value: val,
  };
  Object.defineProperty(wrapper, "__v_isRef", { value: true });
  return reactive(wrapper);
}
// 解决响应丢失， 本质上是做了一层响应代理
function toRef(obj, key) {
  const wrapper = {
    get value() {
      return obj[key];
    },
    // 允许设置值
    set value(val) {
      obj[key] = val;
    },
  };
  Object.defineProperty(wrapper, "_v_isRef", { value: true }); //由于“包裹对象”本质上与普通对象没有任何区别，因此为了区分ref与普通响应式对象，我们还为“包裹对象”定义了一个值为 true 的属性，即_v_isRef，用它作为 ref的标识
  return wrapper;
}

// const obj = reactive({foo:1, bar:2})
// const refFoo = toRef(obj, "foo");
// 自动脱ref,为了减轻用户的心智负担，我们自动对暴露到模板中的响应式数据进行脱ref处理。这样，用户在模板中使用响应式数据时，就无须关心一个值是不是ref了。
function proxyRefs(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      const value = Reflect.get(target, key, receiver);
      return value._v_isRef ? value.value : value;
    },
    set(target, key, newValue, receiver) {
      // 通过 target 读取真实值 const value =target[key]
      //如果值是Ref，则设置其对应的value属性值
      if (value._v_isRef) {
        value.value = newValue;
        return true;
      }
      return Reflect.set(target, key, newValue, receiver);
    },
  });
}
```

## 非原始值

### 代理 Object

#### 拦截删除属性

拦截 deleteProperty

#### 拦截 for ... in 循环

1.  ownKeys 函数 拦截 Reflect.ownKeys 操作(获取对象自身所拥有的键值)
2.  **将 ITERATE_KEY 作为追踪的 key**
    而 ownKeys 用来获取一个对象的所有属于自己的键值，这个操作不与任何具体的 key 进行绑定，因此我们只能够构造唯一的 key 作为标识，即 ITERATE KEY。
3.  添加、修改、删除属性对 for...in 操作的影响。其中添加和删除属性都会影响 for...in 循环的执行次数，所以当这些操作发生时，需要触发与**ITERATE_KEY**相关联的作用数重新执行。而改属性值则不影响 for in 循环的执行次数，因此无须处理。

#### 合理触发副作用函数执行

1. 新值和旧值不全等的情况下，都不是 NaN 才触发响应（NaN !== NaN）。oldVal !== newVal && (oldVal === oldVal || newVal === newVal)
2. 访问原型链上的属性导致触发两次。

#### 深响应和浅响应 shallowReactive,深只读与浅只读。

这里的深和浅指的是对象的层级

1. 浅响应(或只读)代表仅代理一个对象的第一层属性，即只有对象的第一层属性值是响应(或读)的。
2. 深响应(或只读)则恰恰相反，为了实现深响应(或只读)，我们需要在返回属性值之前，对值做一层包装，将其包装为响应式(或只读)数据后再返回。

### 代理数组

1. 通过索引为数组设置新的元素，可能会隐式地改变数组 length 属性的值。
2. 对应地，修改数组 length 属性的值，也可能会间接影响数组中的已有元素。所以在触发响应的时候需要额外注意。
3. 我们还讨论了如何拦截 for...in 和 for...of 对数组的遍历操作。
   1. 使用 for...in 循环遍历数组与遍历普通对象区别不大，唯一需要注意的是，当追踪 for...in 操作时，应该使用数组的 length 作为追踪的 key。
   2. for...of 基于迭代协议工作，数组迭代器执行时，会读取数组的 length 属性或数组的索引。因此，我们不需要做其他额外的处理，就能够实现对 for..of 迭代的响应式支持。
4. 数组的查找方法。如 includes、indexOf 以及 lastIndexOf 等。
   对于数组元素的查找，需要注意的一点是，用户既可能使用代理对象进行查找，也可能使用原始对象进行查找为了支持这两种形式，我们需要重写数组的查找方法。原理很简单，当用户使用这些方法查找元素时，我们可以**先去代理对象中查找，如果找不到，再去原始数组中查找**。
5. 会隐式修改数组长度的原型方法，即 push、pop、shift、unshift 以及 splice 等方法。调用这些方法会间接地读取和设置数组的 length 属性.
   因此，在不同的副作用函数内同一个数组执行上述方法，会导致多个副作用函数之间循环调用，最终导致调用栈溢出。为了决这个问题，**我们使用一个标记变量 shouldTrack 许进行追踪，然后重写上述方法**，目的是，当这些方法间接读取 length 属性值时，我们会先将 shouldTrack 的值设置为 false，即禁止追踪。这样就可以断开 length 属性与作用数之间的响应联系，从而避免循环调用导致的调用栈溢出
