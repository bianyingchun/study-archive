## 编译器工作流程

#### 1. Parse 分析模板，将其解析为模板 AST。

parser 用有限状态自动机构造一个词法分析器。词法分析的过程就是状态机在不同状态之间迁移的过程。在此过程中，状态机会产生一个个 Token，形成一个 Token 列表。我们将使用该 Token 列表来构造用于描述模板的 AST。具体做法是，扫描 Token 列表并维护一个开始标签栈。每当扫描到一个开始标签节点，就将其压入栈顶。栈顶的节点始终作为下一个扫描的节点的父节点。这样，当所有 Token 扫描完毕后，即可构建出一棵树型 AST。在解析模板构建 AST 的过程中，parseChildren 函数是核心。每次调用 parseChildren 函数就意味着新状态机的开启。

#### 2. Transform 将模板 AST 转换为用于描述渲染函数的 JavaScript AST。

1. AST 是树型数据结构，为了访问 AST 中的节点，我们**采用深度优先的方式对 AST 进行遍历**。
在遍历过程中，我们可以对 AST 节点进行各种操作，从而实现对 AST 的转换，为了解耦节点的访问和操作，设计了插化架构将

2. 节点的操作封装到独立的转换函数中。这些转换函数可以通过 context.nodeTransforms 来注册。这里的context为上下文。下文对象中通常会维护程序的当前状态，例如当前访问节点的父节点、当前访问的节点的位置索引等信息。**有了上下文对象及其包含的而信息后，我们即可轻松地实现节点的替换、删除等能力**。
3. 但有时，当前访问节点的转换工作依赖其子节点的转换结果，所为优先完成子节点的转换，我们将整个转换过程分为“**进入与退出阶段**”。每个转数分两个阶段执行，这样就可以实现更加细粒度的转换控制。
4. 之后，我们讨论了如何将模板 AST 转换为用于描述渲染函数的 JavaScriptAST。模板 AST 用来描述模板，类似地，JavaScript AST 用于描述 JavaScript 代码。只有把模板 AST 转换为 JavaScript AST 后，我们才能据此生成最终的渲染函数代码。

#### 3. Generate 根据 JavaScriptAST 生成渲染函数代码。

代码生成是模板编译器的最后一步工作，生成的代码将作为组件的渲染函数。
**代码生成的过程就是字符串拼接的过程。我们需要为不同的 AST 节点编写对应的代码生成函数**。为了让生成的代码具有更强的可读性，我们还讨论了如何对生成的代码进行缩进和换行。
我们将用于缩进和换行的代码封装为工具函数，并且定义到代码生成过程中的上下文对象中。

## 编译优化

编译优化指的是通过编译的手段提取关键信息，并以此指导生成最优代码的过程。
具体来说，Vue.js3 的编译器会充分分析模板，**提取关键信息并将其附着到对应的虚拟节点上。在运行时阶段，渲染器通过这些关键信息执行“快捷路径”，从而提升性能。**

1. 静态标记 patchFlag 区分动态节点与静态节点。Vue.js3 会为动态节点打上补丁标志，即 patchFlag。
2. Vue.js 3 还提出了 Block 的概念
   一个 Block 本质上也是一个虚拟节点，但与普通虚拟节点相比，会多出一个 **dynamicChildren 数组。该数组用来收集所有动态子代节点**，这利用了 createVNode 函数和 createBlock 函数的层层嵌套调用的特点，即以“由内向外”的方式执行。再配合一个用来临时存储动态节点的节点栈，即可完成动态子代节点的收集。
   由于 Block 会收集所有动态子代节点，所以对动态节点的比对操作是忽略 DOM 层级结构的这会带来额外的问题，即 v-if、v-for 等结构化指令会影响 DOM 层级结构，使之不稳定。这会间接导致基于 Block 树的比对算法失效。而解决方式很简单，只需要让带有 v-if、v-for 等指令的节点也作为 Block 角色即可。

3. 静态提升:能够减少更新时创建虚拟 DOM 带来的性能开销和内存占用。
4. 预字符串化:在静态提升的基础上，对静态节点进行字符串化。这样做能够减少创建虚拟节点产生的性能开销以及内存占用。
<div><p></p><p></p><p></p><p></p></div>  => createStaticVnode('<p></p><p></p><p></p><p></p>')
5. 缓存内联事件处理函数:避免造成不必要的组件更新。
6. v-once 指令:缓存全部或部分虚拟节点，能够避免组件更新时重新创建虚拟 DOM 带来的性能开销，也可以避免无用的 Diff 操作。
