你可以把依赖注入看作一部分“大范围有效的 prop”，而且它的规则更加宽松：**祖先组件不需要知道哪些后代组件在使用它提供的数据，后代组件也不需要知道注入的数据来自哪里。**

那么，依赖注入的背后实现原理是怎样的呢？接下来我们就一起分析吧。

## provide API

```js
function provide(key, value) {
  let provides = currentInstance.provides;
  const parentProvides =
    currentInstance.parent && currentInstance.parent.provides;
  if (parentProvides === provides) {
    provides = currentInstance.provides = Object.create(parentProvides);
  }
  provides[key] = value;
}
```

在创建组件实例的时候，组件实例的 provides 对象指向父组件实例的 provides 对象：

```js
const instance = {
  // 依赖注入相关
  provides: parent ? parent.provides : Object.create(appContext.provides),
  // 其它属性
  // ...
};
```

**在默认情况下，组件实例的 provides 继承它的父组件，但是当组件实例需要提供自己的值的时候，它使用父级提供的对象创建自己的 provides 的对象原型。通过这种方式，在 inject 阶段，我们可以非常容易通过原型链查找来自直接父级提供的数据。**

另外，如果组件实例提供和父级 provides 中有相同 key 的数据，是可以覆盖父级提供的数据。

## inject API

```js
function inject(key, defaultValue) {
  const instance = currentInstance || currentRenderingInstance;

  if (instance) {
    const provides = instance.provides;

    if (key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return defaultValue;
    } else if (process.env.NODE_ENV !== "production") {
      warn(`injection "${String(key)}" not found.`);
    }
  }
}
```

inject 支持两个参数，第一个参数是 key，我们可以访问组件实例中的 provides 对象对应的 key，层层查找父级提供的数据。第二个参数是默认值，如果查找不到数据，则直接返回默认值。

如果既查找不到数据且也没有传入默认值，则在非生产环境下报警告，提示用户找不到这个注入的数据。

到这里我们就掌握了 provide 和 inject 的实现原理。但是，我曾经看到过一个问题：“ Vue.js 3 跨组件共享数据，为何要用 provide/inject ？直接 export/import 数据行吗？“

接下来我们就来探讨依赖注入和模块化共享数据的差异。

## 对比模块化共享数据的方式

我们先来看提问者给出的一个模块化共享数据的示例，即首先在根组件创建一个共享的数据 sharedData：

```js
// Root.js
export const sharedData = ref('')
export default {
  name: 'Root',
  setup() {
    // ...
  },
  // ...
}
// 然后在子组件中使用 sharedData：
import { sharedData } from './Root.js'
export default {
  name: 'Root',
  setup() {
    // 这里直接使用 sharedData 即可
  }
}
```

当然，从这个示例上来看，模块化的方式是可以共享数据，但是 provide 和 inject 与模块化方式有如下几点不同。

- #### 作用域不同

  - 对于依赖注入，它的作用域是局部范围，所以你只能把数据注入以这个节点为根的后代组件中，不是这棵子树上的组件是不能访问到该数据的；

  - 而对于模块化的方式，它的作用域是全局范围的，你可以在任何地方引用它导出的数据。

- #### 数据来源不同

  - 对于依赖注入，后代组件是不需要知道注入的数据来自哪里，只管注入并使用即可；

  - 而对于模块化的方式提供的数据，用户必须明确知道这个数据是在哪个模块定义的，从而引入它。

- #### 上下文不同

  - 对于依赖注入，提供数据的组件的上下文就是组件实例，而且同一个组件定义是可以有多个组件实例的，我们可以根据不同的组件上下文提供不同的数据给后代组件；

  - 而对于模块化提供的数据，它是没有任何上下文的，仅仅是这个模块定义的数据，如果想要根据不同的情况提供不同数据，那么从 API 层面设计就需要做更改。
