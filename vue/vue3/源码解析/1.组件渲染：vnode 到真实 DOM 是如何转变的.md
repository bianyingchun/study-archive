Vue.js 内部，一个组件想要真正的渲染生成 DOM，还需要经历“创建 vnode - 渲染 vnode - 生成 DOM” 这几个步骤

## 初始化应用

```js
import { createApp } from "vue";
import App from "./App.vue";
const app = createApp(App); // 创建应用
app.mount("#app"); // 挂载根组件
```

### 入口函数 createApp

```js
const createApp = (...args) => {
  // 创建 app 对象，ensureRenderer() 用来创建一个渲染器对象
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  // 重写 mount 方法
  app.mount = (containerOrSelector) => {
    // ...
  };
  return app;
};
```

#### 1. ensureRenderer().createApp(..args)创建 app 对象

```js
// 渲染相关的一些配置，比如更新属性的方法，操作 DOM 的方法
const rendererOptions = {
  patchProp,
  ...nodeOps,
};
let renderer;
// 延时创建渲染器
// 是当用户只依赖响应式包的时候，就不会创建渲染器，因此可以通过 tree-shaking 的方式移除核心渲染逻辑相关的代码。
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}

function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options) {
  function render(vnode, container) {
    // 组件渲染的核心逻辑
  }

  return {
    render,
    createApp: createAppAPI(render),
  };
}

function createAppAPI(render) {
  // createApp createApp 方法接受的两个参数：根组件的对象和 prop
  return function createApp(rootComponent, rootProps = null) {
    const app = {
      _component: rootComponent,
      _props: rootProps,
      mount(rootContainer) {
        // 创建根组件的 vnode
        const vnode = createVNode(rootComponent, rootProps);
        // 利用渲染器渲染 vnode
        render(vnode, rootContainer);
        app._container = rootContainer;
        return vnode.component.proxy;
      },
    };

    return app;
  };
}
```

1. 内部通过 createRenderer 创建一个渲染器对象，包含 render 和 createApp 方法
2. createApp 方法，它是执行 createAppAPI 方法返回的函数，参数为根组件对象和 props: rootComponent , rootProps
3. 当我们在外部执行 createApp(App) 方法时，会把 App 组件对象作为根组件传递给 rootComponent。这样，createApp 内部就创建了一个 app 对象，它会提供 mount 方法，这个方法是用来挂载组件的
4. mount 方法内部会创建根组件的 vnode，利用 render()渲染 vnode.
5. render 组件渲染的核心方法

#### 2. 重写 app.mount 方法

为什么要重写这个方法，而不把相关逻辑放在 app 对象的 mount 方法内部来实现呢？

这是因为 Vue.js 不仅仅是为 Web 平台服务，它的目标是支持**跨平台渲染**，而 createApp 函数内部的 app.mount 方法是一个标准的可跨平台的组件渲染流程：与平台无关，因此我们需要在**外部重写这个方法，来完善 Web 平台下的渲染逻辑**。

app.mount 重写都做了哪些事情

```js
app.mount = (containerOrSelector) => {
  // 标准化容器
  // 这里可以传字符串选择器或者 DOM 对象，但如果是字符串选择器，就需要把它转成 DOM 对象，作为最终挂载的容器
  const container = normalizeContainer(containerOrSelector);
  if (!container) return;
  const component = app._component;
  // 如组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容
  if (!isFunction(component) && !component.render && !component.template) {
    component.template = container.innerHTML;
  }
  // 挂载前清空容器内容
  container.innerHTML = "";
  // 真正的挂载
  return mount(container);
};
```

从 app.mount 开始，才算真正进入组件渲染流程，那么接下来，我们就重点看一下核心渲染流程做的两件事情：创建 vnode 和渲染 vnode。

## 核心渲染流程：创建 vnode 和渲染 vnode

```js
mount(rootContainer) {
    // 创建根组件的 vnode
    const vnode = createVNode(rootComponent, rootProps);
    // 利用渲染器渲染 vnode
    render(vnode, rootContainer);
    app._container = rootContainer;
    return vnode.component.proxy;
},
```

### 1. 创建 vnode

vnode 本质上是用来描述 DOM 的 JavaScript 对象，它在 Vue.js 中可以描述不同类型的节点，比如普通元素节点、组件节点，纯文本 vnode、注释 vnode 等等

1. 普通元素节点

```js
<button class="btn" style="width:100px;height:50px">
  click me
</button>;
// 我们可以用 vnode 这样表示<button>标签：
const vnode = {
  type: "button",
  props: {
    class: "btn",
    style: {
      width: "100px",
      height: "50px",
    },
  },
  children: "click me",
};
```

2. 组件节点

```js
<custom-component msg="test"></custom-component>;
const CustomComponent = {
  // 在这里定义组件对象
};
const vnode = {
  type: CustomComponent,
  props: {
    msg: "test",
  },
};
```

##### shapeFlag 类型编码

Vue.js 3.0 内部还针对 vnode 的 type，做了更详尽的分类，包括 Suspense、Teleport 等，且把 vnode 的类型信息做了编码，以便在后面的 patch 阶段，可以根据不同的类型执行相应的处理逻辑

```js
const shapeFlag = isString(type)
  ? 1 /* ELEMENT */
  : isSuspense(type)
  ? 128 /* SUSPENSE */
  : isTeleport(type)
  ? 64 /* TELEPORT */
  : isObject(type)
  ? 4 /* STATEFUL_COMPONENT */
  : isFunction(type)
  ? 2 /* FUNCTIONAL_COMPONENT */
  : 0;
```

##### vnode

1. 首先是抽象，引入 vnode，可以把渲染过程抽象化，从而使得组件的抽象能力也得到提升。

2. 其次是跨平台，因为 patch vnode 的过程不同平台可以有自己的实现，基于 vnode 再做服务端渲染、Weex 平台、小程序平台的渲染都变得容易了很多。

#### 内部通过 createVNode 函数创建根组件的 vnode

```js
function createVNode(type, props = null, children = null) {
  if (props) {
    // 处理 props 相关逻辑，标准化 class 和 style
  }
  // 对 vnode 类型信息编码
  const shapeFlag = isString(type)
    ? 1 /* ELEMENT */
    : isSuspense(type)
    ? 128 /* SUSPENSE */
    : isTeleport(type)
    ? 64 /* TELEPORT */
    : isObject(type)
    ? 4 /* STATEFUL_COMPONENT */
    : isFunction(type)
    ? 2 /* FUNCTIONAL_COMPONENT */
    : 0;

  const vnode = {
    type,
    props,
    shapeFlag,
    // 一些其他属性
  };

  // 标准化子节点，把不同数据类型的 children 转成数组或者文本类型
  normalizeChildren(vnode, children);
  return vnode;
}
```

1. 对 props 做标准化处理、
2. 对 vnode 的类型信息编码
3. 创建 vnode 对象
4. 标准化子节点 children 。

### 3. 渲染 vnode

```js
render(vnode, rootContainer);
const render = (vnode, container) => {
  if (vnode == null) {
    // 销毁组件
    if (container._vnode) {
      unmount(container._vnode, null, null, true);
    }
  } else {
    // 创建或者更新组件
    patch(container._vnode || null, vnode, container);
  }
  // 缓存 vnode 节点，表示已经渲染
  container._vnode = vnode;
};
```

1. 当 vnode 为空，则执行销毁组件的逻辑，
2. 否则执行 patch 创建或者更新组件的逻辑。
3. container.\_vnode = vnode 缓存 vnode 节点，表示已经渲染

##### patch 函数创建或更新组件

```js
const patch = (
  n1, // n1 表示旧的 vnode，当 n1 为 null 的时候，表示是一次挂载的过程
  n2, // n2 表示新的 vnode 节点，后续会根据这个 vnode 类型执行不同的处理逻辑；
  container, //container 表示 DOM 容器，也就是 vnode 渲染生成 DOM 后，会挂载到 container 下面。
  anchor = null,
  parentComponent = null,
  parentSuspense = null,
  isSVG = false,
  optimized = false
) => {
  // 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点

  if (n1 && !isSameVNodeType(n1, n2)) {
    anchor = getNextHostNode(n1);
    unmount(n1, parentComponent, parentSuspense, true);
    n1 = null;
  }
  const { type, shapeFlag } = n2;
  switch (type) {
    case Text:
      // 处理文本节点
      break;
    case Comment:
      // 处理注释节点
      break;
    case Static:
      // 处理静态节点
      break;

    case Fragment:
      // 处理 Fragment 元素
      break;

    default:
      if (shapeFlag & 1 /* ELEMENT */) {
        // 处理普通 DOM 元素
        processElement(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      } else if (shapeFlag & 6 /* COMPONENT */) {
        // 处理组件

        processComponent(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      } else if (shapeFlag & 64 /* TELEPORT */) {
        // 处理 TELEPORT
      } else if (shapeFlag & 128 /* SUSPENSE */) {
        // 处理 SUSPENSE
      }
  }
};
```

#### processComponent 组件处理

由于初始化渲染的是 App 组件，它是一个组件 vnode，所以我们来看一下组件的处理逻辑是怎样的。首先是用来处理组件的 processComponent 函数的实现

```js
const processComponent = (
  n1,
  n2,
  container,
  anchor,
  parentComponent,
  parentSuspense,
  isSVG,
  optimized
) => {
  if (n1 == null) {
    // 挂载组件
    mountComponent(
      n2,
      container,
      anchor,
      parentComponent,
      parentSuspense,
      isSVG,
      optimized
    );
  } else {
    // 更新组件
    updateComponent(n1, n2, parentComponent, optimized);
  }
};
```

##### mountComponent 挂载组件

```js
const mountComponent = (
  initialVNode,
  container,
  anchor,
  parentComponent,
  parentSuspense,
  isSVG,
  optimized
) => {
  // 创建组件实例
  const instance = (initialVNode.component = createComponentInstance(
    initialVNode,
    parentComponent,
    parentSuspense
  ));
  // 设置组件实例
  setupComponent(instance);
  // 设置并运行带副作用的渲染函数
  setupRenderEffect(
    instance,
    initialVNode,
    container,
    anchor,
    parentSuspense,
    isSVG,
    optimized
  );
};
```

1. 创建组件实例
2. 设置组件实例
3. 设置并运行带副作用的渲染函数 setupRenderEffect

##### 渲染函数 setupRenderEffect

```javascript
const setupRenderEffect = (
  instance,
  initialVNode,
  container,
  anchor,
  parentSuspense,
  isSVG,
  optimized
) => {
  // 创建响应式的副作用渲染函数
  // 利用响应式库的 effect 函数创建了一个副作用渲染函数 componentEffect。副作用，这里你可以简单地理解为，当组件的数据发生变化时，effect 函数包裹的内部渲染函数 componentEffect 会重新执行一遍，从而达到重新渲染组件的目的。
  instance.update = effect(function componentEffect() {
    if (!instance.isMounted) {
      //初始渲染
      // 渲染组件生成子树 vnode
      const subTree = (instance.subTree = renderComponentRoot(instance));
      // 把子树 vnode 挂载到 container 中
      patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
      // 保留渲染生成的子树根 DOM 节点
      initialVNode.el = subTree.el;
      instance.isMounted = true;
    } else {
      // 更新组件
    }
  }, prodEffectOptions);
};
```

##### 初始渲染

1. 渲染组件生成 subTree
   每个组件都会有对应的 render 函数，即使你写 template，也会编译成 render 函数，而 renderComponentRoot 函数就是去执行 render 函数创建整个组件树内部的 vnode，把这个 vnode 再经过内部一层标准化后返回

2. 把 subTree 挂载到 container 中
   **subTree，它也是一个 vnode 对象。注意 initialVNode 是组件 vnode, 组件内部整个 DOM 节点对应的 vnode 就是执行 renderComponentRoot 渲染生成对应的 subTree，我们可以把它称作“子树 vnode”**

3. 渲染生成子树 vnode 后，接下来就是继续调用 patch 函数把子树 vnode 挂载到 container 中了。

   那么我们又再次回到了 patch 函数，会继续对这个子树 vnode 类型进行判断，对于上述例子，App 组件的根节点是 <div> 标签，那么对应的子树 vnode 也是一个普通元素 vnode，那么我们接下来看对普通 DOM 元素的处理流程。

#### processElement 处理普通 DOM 元素

```js
const processElement = (
  n1,
  n2,
  container,
  anchor,
  parentComponent,
  parentSuspense,
  isSVG,
  optimized
) => {
  isSVG = isSVG || n2.type === "svg";
  if (n1 == null) {
    //挂载元素节点
    mountElement(
      n2,
      container,
      anchor,
      parentComponent,
      parentSuspense,
      isSVG,
      optimized
    );
  } else {
    //更新元素节点
    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);
  }
};
```

##### mountElement 挂载元素

```js
const mountElement = (
  vnode,
  container,
  anchor,
  parentComponent,
  parentSuspense,
  isSVG,
  optimized
) => {
  let el;

  const { type, props, shapeFlag } = vnode;

  // 创建 DOM 元素节点

  el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is);
  if (props) {
    // 处理 props，比如 class、style、event 等属性
    for (const key in props) {
      if (!isReservedProp(key)) {
        hostPatchProp(el, key, null, props[key], isSVG);
      }
    }
  }
  if (shapeFlag & 8 /* TEXT_CHILDREN */) {
    // 处理子节点是纯文本的情况
    hostSetElementText(el, vnode.children);
  } else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
    // 处理子节点是数组的情况
    mountChildren(
      vnode.children,
      el, // 子节点的父元素
      null,
      parentComponent,
      parentSuspense,
      isSVG && type !== "foreignObject",
      optimized || !!vnode.dynamicChildren
    );
  }

  // 把创建的 DOM 元素节点挂载到 container 上
  hostInsert(el, container, anchor);
};
```

1. 创建 Dom 元素
   hostCreateElement,调用了底层的 DOM API document.createElement 创建元素

2. 处理 props
   判断如果有 props 的话，给这个 DOM 节点添加相关的 class、style、event 等属性，并做相关的处理，这些逻辑都是在 hostPatchProp 函数内部做的
3. 处理 children

   1. 如果子节点是纯文本，则执行 hostSetElementText 方法，它在 Web 环境下通过设置 DOM 元素的 textContent 属性设置文本
   2. 如果子节点是数组，则执行 mountChildren 方法：遍历每个子节点，递归挂载

   ```js
   const mountChildren = (
     children,
     container,
     anchor,
     parentComponent,
     parentSuspense,
     isSVG,
     optimized,
     start = 0
   ) => {
     for (let i = start; i < children.length; i++) {
       // 预处理 child
       const child = (children[i] = optimized
         ? cloneIfMounted(children[i])
         : normalizeVNode(children[i]));

       // 递归 patch 挂载 child

       patch(
         null,
         child,
         container,
         anchor,
         parentComponent,
         parentSuspense,
         isSVG,
         optimized
       );
     }
   };
   ```

   子节点的挂载逻辑同样很简单，遍历 children 获取到每一个 child，然后递归执行 patch 方法挂载每一个 child 。注意，这里有对 child 做预处理的情况（后面编译优化的章节会详细分析）。

可以看到，mountChildren 函数的第二个参数是 container，而我们调用 mountChildren 方法传入的第二个参数是在 mountElement 时创建的 DOM 节点，这就很好地建立了父子关系。

另外，通过递归 patch 这种深度优先遍历树的方式，我们就可以构造完整的 DOM 树，完成组件的渲染。

4. Dom 元素挂载到 container

处理完所有子节点后，最后通过 hostInsert 方法把创建的 DOM 元素节点挂载到 container 上，它在 Web 环境下这样定义：

```js
function insert(child, parent, anchor) {
  if (anchor) {
    parent.insertBefore(child, anchor);
  } else {
    parent.appendChild(child);
  }
}
```

这里会做一个 if 判断，如果有参考元素 anchor，就执行 parent.insertBefore ，否则执行 parent.appendChild 来把 child 添加到 parent 下，完成节点的挂载。

因为 insert 的执行是在处理子节点后，所以挂载的顺序是先子节点，后父节点，最终挂载到最外层的容器上。
