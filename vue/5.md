### 怎么解决 vue 打包后静态资源图片失效的问题？

vue-cli 2.x 在 config 文件夹下的 index.js 中修改 assetsPublicPath: './'
vue.config.js
vue-cli 3.x 版本 baseUrl: '/'
vue-cli 4.x 版本 publicPath: './'

### 怎么给 vue 定义全局的方法？

1. 挂载到 Vue 的 prototype 上
2. 全局 mixin
   Vue.mixin()

### new Vue 做了什么

core/instance/index.js

```javascript
initLifecycle(vm);
initEvents(vm);
initRender(vm);
callHook(vm, "beforeCreate");
initInjections(vm); // resolve injections before data/props
initState(vm);
initProvide(vm); // resolve provide after data/props
callHook(vm, "created");

/* istanbul ignore if */
if (process.env.NODE_ENV !== "production" && config.performance && mark) {
  vm._name = formatComponentName(vm, false);
  mark(endTag);
  measure(`vue ${vm._name} init`, startTag, endTag);
}

if (vm.$options.el) {
  vm.$mount(vm.$options.el);
}
```

1. 合并配置
2. 初始化生命周期
3. 初始化事件中心
4. 初始化渲染
5. 调用 beforeCreate 钩子函数
6. 初始化 init injections and reactivity（这个阶段属性都已注入绑定，而且被 $watch 变成 reactivity，但是 $el 还是没有生成，也就是 DOM 没有生成）
7. 初始化 state 状态（初始化了 data、props、computed、watcher）
8. 调用 created 钩子函数。
9. 在初始化的最后，检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM

### 单向数据流

parent props child

### computed 和 watch 的区别和运用的场景？

computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；
watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

### Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题

### 28.你有对 Vue 项目进行哪些优化？

1. 代码层面的优化

v-if 和 v-show 区分使用场景
computed 和 watch 区分使用场景
v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
长列表性能优化
事件的销毁
图片资源懒加载
路由懒加载
第三方插件的按需引入
虚拟滚动 优化无限列表性能
服务端渲染 SSR or 预渲染
keep-alive 缓存
防抖节流

2. Webpack 层面的优化

   1. 压缩代码 压缩 js terser-webpack-plugin,CSSMinimizerWebpackPlugin
   2. tree shaking
   3. external cdn
   4. Scope Hoisting 即作用域提升
   5. split chunk

3. 用户体验
   骨架屏
   PWA
   缓存
   nginx gzip 压缩

使用 Chrome Performance 查找性能瓶颈

### 27. Vue 中的 key 有什么作用？

1. v-if 这个时候 key 的作用是用来标识一个独立的元素
2. key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。

Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有 4 种比较方式：newStartIndex 和 oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了 key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx > EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。
