### computed 和 methods 的差异

1. computed 是响应式的，methods 不是
2. 调用方式不同，computed 像属性一样访问，methods 是函数调用
3. computed 具有缓存性，只有当依赖变化后才重新求值，methods 每次调用都会执行
4. computed 可以定义成函数形式，也可写成 set,get 变成可读写属性，而 methods 做不到
5. computed 不支持异步

### computed 和 watch 的差异

1. computed：计算属性

- 调用属性时不需要加括号 （最后面解释了为什么不加括号！！）

- 根据依赖会自动缓存，如果依赖不变就不会重新计算

- 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化

- 如果一个属性是由其他属性计算出来的，这个属性依赖其他属性，是多对一或一对一，一般用 computed

- 如果 computed 的属性值是函数，那么默认会走 get 方法，函数的返回值就是属性的属性值，在 computed,属性都有 get,set 方法，当数据变化，就会调用 set 方法。
- 原理:
  1. 计算属性实际上是一个**懒执行的副作用函数**，我们通过 lazy 选项使得副作用函数可以执行。
  2. 被标记为懒执行的副作用函数可以通过手动方式让其执行。利用这个特点，我们设计了计算属性，**当读取计算属性的值时，只需要手动执行副作用函数即可。**
  3. **当计算属性依赖的响应式数据发生变化时，会通过 scheduler 将 dirty 标记设置 true，代表“脏”。这样，下次读取计算属性的值时，我们会重新计算真正的值。**

1. watch：监听

   - 不支持缓存，数据变化，直接会触发相应的操作

   - watch 支持异步

   - 监听的函数接收里两个参数，第一个参数是最新的值，第二个参数是输入之前的值

   - 当一个属性变化时，需要执行对应的操作：一对多

   - 监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，可以选择是否触发其他操作，有两个参数：

- vue3 侦听器数据源可以是返回值的 getter 函数，也可以直接是 ref，也可以同时监听多个数据源
  immediate：组件加载立即触发回调函数执行（决定函数是否初始化就执行,执行为 true,相反为 false）

deep：深度监听（看监听对象里面的属性是否变化）为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。

- 原理：
  它本质上利用了副作用函数重新执行时的可调度性。一个 watch 会创建一 effect，当这个 effect 依赖的响应式数据发生变化时，会执行该 effect 的调度器函数，即 scheduler。这里的 scheduler 可以理解为“回调”，所以我们需要 scheduler 中执行用户通过 watch 注册的回调函数即可。

### computed 原理

https://juejin.cn/post/6844903678533451783

#### v2

computed 本质是一个惰性求值的观察者。
computed 内部实现了一个惰性的 watcher,也就是 computed watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。
其内部通过 this.dirty 属性标记计算属性是否需要重新求值。
当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,
computed watcher 通过 this.dep.subs.length 判断有没有订阅者,
有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。)
没有的话,仅仅把 this.dirty = true。 (当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。)

#### vue3

```js
function computed(getterOrOptions) {
  let getter, setter;
  if (isFunction(getterOrOptions)) {
    getter = getterOrOptions;
    setter =
      process.env.NODE_ENV !== "production"
        ? () => {
            console.warn("Write operation failed: computed value is readonly");
          }
        : NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  // 数据是否脏的
  let dirty = true;
  // 计算结果
  let value;
  let computed;
  // 创建副作用函数
  const runner = effect(getter, {
    // 延时执行
    lazy: true,
    // 标记这是一个 computed effect 用于在 trigger 阶段的优先级排序
    computed: true,
    // 调度执行的实现
    scheduler: () => {
      if (!dirty) {
        dirty = true;
        // 派发通知，通知运行访问该计算属性的 activeEffect
        trigger(computed, "set" /* SET */, "value");
      }
    },
  });
  // 创建 computed 对象
  computed = {
    __v_isRef: true,
    // 暴露 effect 对象以便计算属性可以停止计算
    effect: runner,
    get value() {
      // 计算属性的 getter
      if (dirty) {
        // 只有数据为脏的时候才会重新计算
        value = runner();
        dirty = false;
      }
      // 依赖收集，收集运行访问该计算属性的 activeEffect
      track(computed, "get" /* GET */, "value");
      return value;
    },
    set value(newValue) {
      // 计算属性的 setter
      setter(newValue);
    },
  };
  return computed;
}
```

计算属性本质上是一个懒执行的副作用函数，通过 lazy 选项使其懒执行，当读取计算属性时，手动执行副作用函数，当计算属性依赖的响应式数据发生变化时，会通过 scheduler 将 dirty 设置为 true,代表脏，下次读取计算属性的值时，会重新计算真正的值

### vue 项目如何部署？有遇到布署服务器后刷新 404 问题吗？

https://github.com/febobo/web-interview/issues/31

前后端分离开发模式下，前后端是独立布署的，前端只需要将最后的构建物上传至目标服务器的 web 容器指定的静态目录下即可

我们知道 vue 项目在构建后，是生成一系列的静态文件

```javascript
server {
  listen  80;
  server_name  www.xxx.com;

  location / {
    index  /data/dist/index.html;
  }
}
```

##### 为什么 history 模式下有问题

Vue 是属于单页应用（single-page application）

而 SPA 是一种网络应用程序或网站的模型，所有用户交互是通过动态重写当前页面，前面我们也看到了，不管我们应用有多少页面，构建物都只会产出一个 index.html

现在，我们回头来看一下我们的 nginx 配置

```javascript
server {
  listen  80;
  server_name  www.xxx.com;

  location / {
    index  /data/dist/index.html;
  }
}
```

可以根据 nginx 配置得出，当我们在地址栏输入 www.xxx.com 时，这时会打开我们 dist 目录下的 index.html 文件，然后我们在跳转路由进入到 www.xxx.com/login

关键在这里，当我们在 website.com/login 页执行刷新操作，nginx location 是没有相关配置的，所以就会出现 404 的情况

##### 什么 hash 模式下没有问题

hash 模式的特点在于：仅 hash 符号之前的内容会被包含在请求中，hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 hash 不会重新加载页面

##### 解决方案

产生问题的本质是因为我们的路由是通过 JS 来执行视图切换的，

当我们进入到子路由时刷新页面，web 容器没有相对应的页面此时会出现 404

所以我们只需要配置**将任意页面都重定向到 index.html，把路由交由前端处理**

对 nginx 配置文件.conf 修改，添加 try_files $uri $uri/ /index.html;

```sh
server {
  listen 80;
  server_name www.xxx.com;

  location / {
  index /data/dist/index.html;
  try_files $uri $uri/ /index.html;
  }
}
```

### 说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？

1. 文件夹和文件夹内部文件的语义一致性
2. 单一入口/出口
3. 就近原则，紧耦合的文件应该放到一起，且应以相对路径引用
4. 公共的文件应该以绝对路径的方式从根目录引用
5. /src 外的文件不应该被引入

### 如何处理 vue 项目中的错误

##### 后端接口错误

通过 axios 的 interceptor 实现网络请求的 response 先进行一层拦截

```javascript
instance.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    if (error.response.status == 401) {
      router.push({ name: "Login" });
    } else {
      message.error("出错了");
      return Promise.reject(error);
    }
  }
);
```

##### 代码逻辑错误

1. 全局设置错误处理
   设置全局错误处理函数

```javascript
Vue.config.errorHandler = function (err, vm, info) {
  // handle error
  // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子
  // 只在 2.2.0+ 可用
};
```

errorHandler 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例

2. 生命周期钩子
   errorCaptured 是 2.5.0 新增的一个生命钩子函数，当捕获到一个来自子孙组件的错误时被调用

   ```javascript
   errCaputured(err: Error, vm: Component, info: string) => ?boolean
   ```

3. 错误传播规则

- **默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报**
- 如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。

- 如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler。

- 一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler

### Vuex 和 localstorage 的区别

1. 存储

- vuex 存储在内存
- localstorage 则以文件的形式存储在本地磁盘中

2. 性能

- localstorage 只能存储字符串类型的数据，存储对象需要 JSON.parse 和 JSON.stringify 进行处理，读取内存速度比读取硬盘快

3. 持久化

- 刷新页面 vuex 存储的值会丢失，localstorage 不会

4. 应用场景

- Vuex 可以做到响应式，localstorage 不可以
- Vuex 用于组件之间的通信，localstorage 用于跨页面传递数据。

### 路由钩子在 Vue 生命周期的体现

1. 导航被触发。
2. 在失活的组件里调用 beforeRouteLeave 守卫。
3. 调用全局的 beforeEach 守卫。
4. 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
5. 在路由配置里调用 beforeEnter。
6. 解析异步路由组件。
7. 在被激活的组件里调用 beforeRouteEnter。
8. 调用全局的 beforeResolve 守卫 (2.5+)。
9. 导航被确认。
10. 调用全局的 afterEach 钩子。
11. 非重用组件，开始组件实例的生命周期
    - beforeCreate & created
    - beforeMount & mounted
12. 触发 DOM 更新。
13. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

### Vue 中所有带$的方法

1. 实例方法 / 数据

- vm.$watch
- vm.$set
- vm.$delete

2. 实例方法 / 事件

- vm.$on
- vm.$once
- vm.$off
- vm.$emit

3. 实例方法 / 生命周期

- vm.$mount
- vm.$forceUpdate
- vm.$nextTick
- vm.$destroy

### 介绍 Vue template 到 render 的过程

1. parse template 编译
2. transform
3. generate

#### 优点

- 响应式编程
- 组件化。
  组件化优点
  1. 提高开发效率
  2. 方便重复使用
  3. 简化调试步骤
  4. 提升整个项目的可维护性
  5. 便于协同开发
- 轻量级框架(压索之后 20KB 大小)、简单易学
- 双向数据绑定
- MVVM 数据和结构的分离
- 虚拟 DOM、运行速度快。
- vue 是单页面应用，使页面局部刷新，不用每次跳转页面都要请求所有数据和 dom，这样大大加快了访问速度和提升用户体验。而且他的第三方 ui 库很多节省开发时间。
-

#### 缺点

- VUE 不支持 IE8
- 不利于 seo。vue 直接的框架不可以做 seo，如果要做的话需要预渲染或服务器端渲染。
- 不利于首屏加载

##