1.解法1：借助 快速排序 partition 操作定位到最终排定以后索引为 len - k 的那个元素（特别注意：随机化切分元素）
```javascript

function findKthLargest(nums,k) {
    const len = nums.length;
    let left = 0;
    let right = len - 1;
    // 转换一下，第 k 大元素的索引是 len - k
    const target = len - k;
    while (true) {
      const index = partition(nums, left, right);
      if (index == target) {
        return nums[index];
      } else if (index < target) {
        left = index + 1;
      } else {
        right = index - 1;
      }
    }
}
function partition(list, low, high) {
  const pivotkey = list[low];
  while (low < high) {
    while (low < high && list[high] >= pivotkey) high--;
    list[low] = list[high];
    while (low < high && list[low] <= pivotkey) low++;
    list[high] = list[low];
  }
  list[low] = pivotkey;
  return low;
}
```

2. 解法2 堆排序, 把所有元素建立初始大根堆，然后从len-1 到 len-k调整堆结构，交换堆顶元素与末尾元素,此时的arr[len-k]就是第K大的数
```javascript
function adjustHeap (arr, parent, length) { 
  const temp = arr[parent]; // temp保存当前父节点
  for (let child = parent * 2 + 1; child < length; child = child * 2 + 1) { 
     // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点
    if (child + 1 < length && arr[child] < arr[child + 1]) {
      child++;
    }
    if(arr[child] <= temp) { // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点
     break 
    } 
     // 把孩子结点的值赋给父结点
    arr[parent] = arr[child];
     // 选取孩子结点的左孩子结点,继续向下筛选
     parent = child;
  }
  arr[parent] = temp;
}

function swap(arr, a , b){
  const temp=arr[a];
  arr[a] = arr[b];
  arr[b] = temp;
}
function findKthLargest (nums, k) {
  const len = nums.length
    for(let i = Math.floor(len / 2) - 1; i >=0; i--) {
      adjustHeap(nums, i, nums.length)
    }
    for(let j =nums.length -1 ; j >= nums.length - k; j--) {
      swap(nums,0,j);//将堆顶元素与末尾元素进行交换
      adjustHeap(nums,0,j);//重新对堆进行调整
    }
    return nums[len-k];
}


console.log(findKthLargest([4, 5, 3, 2, 1, 6],1))
```