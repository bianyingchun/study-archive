## 设计一个主题切换工程架构

如何高效的实现主题切换呢？这里的高效就是指工程化、自动化方案，不需要开发中 hard coding。在介绍具体方案前，我们先来了解一个必备概念和工程化神器——PostCSS

### PostCss

先简要介绍⼀下 PostCss
的原理：PostCss ⾃⾝只包括了：CSS 分析器，**CSS 节点树 API，source map ⽣成器，CSS 节点拼接器**
，⽽基于 PostCss 的插件都是使⽤了 **Css 节点树 API** 来实现

```css
element {
  prop1: rule1 rule2...;
  prop2: rule1 rule2...;
  prop2: rule1 rule2...;
  ...;
}
```

也就是⼀条⼀条的样式规则组成，每⼀条样式规则包含⼀个或多个属性跟值。所以 PostCss 的执⾏过程⼤致如下：

1.  Parser 利⽤ **CSS 分析器**读取 CSS 字符内容，得到⼀个完整的**AST 节点树**
2.  Plugin 对上⾯拿到的**节点树**利用 **CSS 节点树 API**进⾏⼀系列的转换操作
3.  Plugin 利⽤ **CSS 节点拼接器**将上⾯转换之后的节点树重新组成 CSS 字符
4.  Stringifier 在上⾯转换期间可利⽤ **source map ⽣成器**，表明转换前后字符的对应关系

###架构思路
社区上实现主题切换的方案往往是 css 变量(var(--))实现，这无疑是一个很好的思路，但是作为架构来说，使用 CSS 自定义属性——只是其中一个环节。站在更高、更中台化的视觉思考，我们还需要如下考量：

1.  who,how **维护不同颜色值**
2.  研发和设计之间，如何保持不同主题色值的同步沟通；
3.  如何**最小化前端工程师的开发量**，不需要 hardcoding 两份颜色数值；
4.  如何做到一键切换时的**性能**最优；
5.  如何配合 JavaScript**状态管理**，同步主题切换的信号。

基于以上考虑，以一个超链接样式为例，我们希望做到在开发时，编写：

```css
a {
  color: cc(GBK05A);
}
```

这样的代码，就能一劳永逸——直接支持两套（light/dark）主题模式。也就是说，在应用编译时，上述代码预期被编译为下面这样的代码：

```css
a {
  color: #646464;
}

html[data-theme="dark"] a {
  color: #808080;
}
```

我们来看看在编译时，构建环节发生了什么：

1. cc(GBK05A)这样的声明，被编译为#646464；

2. 也就是说，cc 是一个 CSS function，而 GBK05A 是一组色值，分别包含了 light 和 dark 两种主题的颜色；

3. 同时在 HTML 根节点上，添加属性选择器 data-theme='dark'，并添加 a 标签 color 色值样式为#808080。

我们设想，用户点击“切换主题”按钮时，首先通过 JavaScript 将 HTML 根节点标签添加 data-theme 为 dark 的属性值，这时 CSS 选择器 html[data-theme='dark'] a 将起作用，实现了样式的切换。

回到我们的架构设计中，如何在构建时完成 CSS 的样式编译转换呢？答案指向了 PostCSS。我们来盘点一下具体架构步骤。

2. 维护一个色值，结合上例（这里以 YML 格式为例）就是：

```yml
GBK05A: [BK05, BK06]
BK05: "#808080"
BK06: "#999999"
```

1.  首先编写一个名为 postcss-theme-colors 的 PostCSS 插件，实现上述编译过程。
    postcss-theme-colors 需要做的：

    1. 识别 cc()方法；
    2. 读取色值；

    3. 通过色值，对 cc()方法求值，得到两种颜色，分别对应 dark 和 light 模式；

    4. 原地编译 CSS 中的颜色为 light 模式色值；

    5. 同时 dark 模式色值写到 HTML 节点上

整体架构设计，总结为下图：
![PostCSS 架构转换设计](../../asset/postCss%E6%9E%B6%E6%9E%84%E8%BD%AC%E6%8D%A2%E8%AE%BE%E8%AE%A1.png)

### 架构实现

有了架构，这部分我们就来实现架构环节中的重点环节。首先，我们需要了解 PostCSS 插件体系。

#### PostCSS 插件体系

插件要做的就是拿到节点树上的 CSS 属性声明，通过转换拼接为新的 CSS 字符串；这⾥我们需要的功能的编写⽅式如下，可以参考

```js
var postcss = require("postcss");
module.exports = postcss.plugin("pluginname", function (opts) {
  opts = opts || {};
  // Work with options here
  return function (css, result) {
    // Transform the CSS AST
  };
});
```

上面代码是一个典型的 PostCSS 插件编写模版。一个 PostCSS 就是一个 Node.js 模块，开发者调用 postcss.plugin（源码链接定义在 [postcss.plugin](https://github.com/postcss/postcss/blob/main/lib/postcss.js#L28) 中 ）工厂方法返回一个插件实体，形如：

```js
return {
    postcssPlugin: 'PLUGIN_NAME',
    /*
    Root (root, postcss) {
      // Transform CSS AST here
    }
    */
    /*
    Declaration (decl, postcss) {
      // The faster way to find Declaration node
    }
    */
    /*
    Declaration: {
      color: (decl, postcss) {
        // The fastest way find Declaration node if you know property name
      }
    }
    */
  }
}
```

在编写 PostCSS 插件时，我们可以直接使用 postcss.plugin 方法完成实际开发。接下来，我们就开始动手实现 postcss-theme-colors。

#### 动手实现 postcss-theme-colors

上述内容，在 PostCSS 插件设计中，我们看到了清晰的 AST 设计痕迹，经过之前小节的学习，我们应该对于 AST 不再陌生。根据插件代码骨架，我们加入具体实现逻辑，代码如下：

```js
const postcss = require("postcss");
const defaults = {
  function: "cc", // ⾃定义CSS⽅法名
  groups: {}, // 存储⾊值分组
  colors: {}, // 存储所有⾊值
  useCustomProperties: false, // 是否使⽤⾃定义属性
  darkThemeSelector: 'html[data-theme="dark"]', // 夜间模式选择器
  nestingPlugin: null, // 添加选择器的插件
};
/**
 * 计算最终⾊值
 * @param options
 * @param theme
 * @param group
 * @param defaultValue
 * @returns {string|*}
 */
const resolveColor = (options, theme, group, defaultValue) => {
  const [lightColor, darkColor] = options.groups[group] || [];
  const color = theme === "dark" ? darkColor : lightColor;
  if (!color) {
    return defaultValue;
  }
  if (options.useCustomProperties) {
    return color.startsWith("--") ? `var(${color})` : `var(--${color})`;
  }
  return options.colors[color] || defaultValue;
};
// 导出插件
module.exports = postcss.plugin("postcss-theme-colors", (options) => {
  options = Object.assign({}, defaults, options);
  // 获取色值函数（默认为 cc()）
  const reGroup = new RegExp(`\\b${options.function}\\(([^)]+)\\)`, "g");
  return (style, result) => {
    // 判断 PostCSS 工作流程中，是否使用了某些 plugins
    const hasPlugin = (name) =>
      name.replace(/^postcss-/, "") === options.nestingPlugin ||
      result.processor.plugins.some((p) => p.postcssPlugin === name);
    // 获取最终 CSS 值
    const getValue = (value, theme) => {
      return value.replace(reGroup, (match, group) => {
        return resolveColor(options, theme, group, match);
      });
    };
    // 遍历 CSS 声明
    style.walkDecls((decl) => {
      const value = decl.value;
      // 如果不含有色值函数调用，则提前退出
      if (!value || !reGroup.test(value)) {
        return;
      }
      const lightValue = getValue(value, "light");
      const darkValue = getValue(value, "dark");
      const darkDecl = decl.clone({ value: darkValue });
      let darkRule;
      // 使用插件，生成 dark 样式
      if (hasPlugin("postcss-nesting")) {
        darkRule = postcss.atRule({
          name: "nest",
          params: `${options.darkThemeSelector} &`,
        });
      } else if (hasPlugin("postcss-nested")) {
        darkRule = postcss.rule({
          selector: `${options.darkThemeSelector} &`,
        });
      } else {
        decl.warn(
          result,
          `Plugin(postcss-nesting or postcss-nested) not found`
        );
      }
      // 添加 dark 样式到目标 HTML 节点中
      if (darkRule) {
        darkRule.append(darkDecl);
        decl.after(darkRule);
      }
      const lightDecl = decl.clone({ value: lightValue });
      decl.replaceWith(lightDecl);
    });
  };
});
```

上面代码我加入了相关注释，整体逻辑并不难理解。理解了这部分源码，使用方式也就呼之欲出了：

```js
const colors = {
  C01: "#eee",
  C02: "#111",
};
const groups = {
  G01: ["C01", "C02"],
};
postcss([require("postcss-theme-colors")({ colors, groups })]).process(css);
```

通过上述操作，我们实现了 postcss-theme-colors 插件，整体架构也就完成了大半。接下来，我们将继续完善，最终打造出一个更符合基础建设要求的方案。

### 架构平台化——色组 & 色值平台设计

上面的使用示例中，我们采用了 hard coding 的方式，如下代码：

```js
const colors = {
  C01: "#eee",
  C02: "#111",
};
const groups = {
  G01: ["C01", "C02"],
};
```

声明了 colors 和 groups 两个常量，并传递给 postcss-theme-colors 插件。其中 groups 变量声明了色组的概念，比如 group1 命名为 G01，它对应了 C01（日间色），C02（夜间色）两个色值。这样的好处显而易见。

- 我们将 postcss-theme-colors 插件和色值声明解耦， postcss-theme-colors 插件并不关系颜色，而是接受 colors 和 groups 变量。

- 色值和色组解耦：

  - colors 维护具体色值；

  - groups 维护具体色组。

这样一来，如前文一个超链接样式声明：

```css
a {
  color: cc(GBK05A);
}
```

如上代码，我们在业务开发中，直接声明了“使用 GBK05A 这个色组”。**业务开发者不需要关心这个色组在 light/dark 模式下分别对应哪些色值。而设计团队可以专门维护色组和色值，最终只提供给开发者色组即可**。

在此基础上，我们完全可以抽象出一个色组 & 色值平台，方便设计团队更新内容。这个平台可以以 JSON 或者 YML 任何形式存储色值色组对应关系，方便各个团队协作。

在前文提到的主题切换设计架构图的基础上，我们扩充其为平台化的解决方案：

![前端样式基础建设方案](../../asset/%E5%89%8D%E7%AB%AF%E6%A0%B7%E5%BC%8F%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%A1%88.png)
