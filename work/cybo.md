//

//同时绑定touchstart touchend touchmove tap事件，触碰立即弹起会先执行start->end->tap;为了区分touch和tap事件，可以在end时判断是否有move标志。
### cybo
#### 技术栈
微信小程序
redux
immutable

### 介绍
每周cybo 报告。管理员可编辑发布cybo,查看切换监听的公众号，搜索公众号，文章，将公众号里的文章发布到cybo, 用户卡查看cybo 列表， 访问文章。
#### 页面
1. cybo-list
 所有期的cybo列表， 1. 编辑，删除，添加，查找

1. 标签系统
  管理员对标签增删改查，为cybo, 公号，文章添加标签。在非编辑模式下可查看该标签下的所有文章

3. 公号列表
  1. 监听公号
  2. 编辑公号
  3. 添加公号
  3. 搜索公号列表结果
  4. 查看公号文章
 
5. 用户登录退出

6. cybo-detail
  赛博详情，cybo 文章列表

### 核心组件vbar-box， 
所有列表页以及文章页都使用到了这个组件
**布局组件**，类似于通讯录，主体部分是列表页或者文章，右侧是导航条vbar，
**定制化**，不同的页面导航项显示内容，样式有细微不一致，可以传入setting需要定制化，
**同步更新**，页面滚动或者列表项更新，vbar也是要同步更新当前导航项的位置， 滑动vbar， 页面也要滚动到对应位置。
**重排序** ,可倒序或正序，

核心: 监听list的变化，nextTick 主体和导航条都重新计算位置，同步更新位置。

#### 遇到的坑
1. redux
  + 引入redux
    微信小程序文档中没有介绍如何引入第三方的包,需要自己修改，第三方库的代码使用这种形式的export : module.exports = function(){}，可以自己打包一个Redux包，让它可以兼容微信小城的加载方式，或者直接使用修改好的库 https://github.com/charleyw/wechat-weapp-redux

  + 调试redux :wechat-weapp-redux-todos

  + 使用redux时onLoad生命周期被重写，
   自定义after_onload()函数,在redux的onload方法最后执行




1. 二进制协议
   在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是 二进制。HTTP/2 则是一个**彻底的二进制协议**，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。

2. 多路复用
   HTTP/2 **仍然复用 TCP 连接**，但是在一个连接里， 客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送， 这样就避免了"队头堵塞"的问题。

3. 数据流
   HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。**HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流**。

4. 首部压缩
   HTTP/2 实现了头信息压缩，\*\*由于 HTTP 1.1 协议不带有状态，每次请求都必须 附上所有信息。所以，请求的很多字段都是重复的，这会浪费很多带宽，也影响速度。
   HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面， 客户端和服务器同时维护一张头信息 表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。
   
5. 服务器推送
   **HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。**使用服务器推送，提前给客户端推送必要的资源 ，这样就可以相对减少一些延迟 时间。这里需要注意的是 http2 下服务器主动推送的是**静态资源**，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。