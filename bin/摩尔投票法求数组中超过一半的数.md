作者：喝七喜
链接：https://www.zhihu.com/question/49973163/answer/235921864

为了理解一个代码量很短的算法，先通过更复杂的数据结构和空间复杂度了解会更为具体，然后去掉冗余就得到了简短的算法。重点：首先请考虑最基本的摩尔投票问题，找出一组数字序列中出现次数大于总数1/2的数字（并且假设这个数字一定存在）。显然这个数字只可能有一个。
摩尔投票算法是基于这个事实：每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。请首先认同这个事实，这里不证明了~如果你已经了解摩尔投票法的代码，只是无法理解其中变量的实际意义是什么，你可以根据以上这个事实自己再理一遍。所以我们的目标就是：删除，删除，删除。删到不能删除为止。实现的算法从第一个数开始扫描整个数组，有两个变量(参考第一答题者的变量名)major和count。其实这两个变量想表达的是一个“隐形的数组”array，array存储的是“当前暂时无法删除的数字”，我们先不要管major和count，只考虑这个array，同时再维护一个结果数组result，result里面存储的是每次删除一对元素之后的当前结果。为了方便理解举一个示例
输入：{1,2,1,3,1,1,2,1,5}
  1. 从第一个数字1开始，我们想要把它和一个不是1的数字一起从数组里抵消掉，但是目前我们只扫描了一个1，所以暂时无法抵消它，把它加入到array，array变成了{1}，result由于没有抵消任何元素所以还是原数组{1,2,1,3,1,1,2,1,5}。
  2. 然后继续扫描第二个数，是2，我们可以把它和一个不是2的数字抵消掉了，因为我们之前扫描到一个1，所以array变成了{},result变成了{1,3,1,1,2,1,5}
  3. 继续扫描第三个数1，无法抵消，于是array变成了{1},result还是{1,3,1,1,2,1,5};
  4. 接下来扫描到3,可以将3和array数组里面的1抵消,于是array变成了{},result变成了{1,1,2,1,5}
  5. 接下来扫描到1，此时array为空，所以无法抵消这个1，array变成了{1},result还是{1,1,2,1,5}
  6. 接下来扫描到1，此时虽然array不为空，但是array里也是1，所以还是无法抵消，把它也加入这个array,于是array变成了{1,1}（其实到这我们可以发现，array里面只可能同时存在一种数，因为只有array为空或当前扫描到的数和array里的数字相同时才把这个数字放入array）,result还是{1,1,2,1,5}。
  7. 接下来扫描到2，把它和一个1抵消掉，至于抵消哪一个1，无所谓，array变成了{1},result是{1,1,5}接下来扫描到1，不能抵消，array变成了{1,1}，result{1,1,5}
  8. 接下来扫描到5，可以将5和一个1抵消，array变成了{1},result变成了{1}至此扫描完成了数组里的所有数，result里剩了1，所以1就是大于一半的数组。再回顾一下这个过程，其实就是删除（抵消）了（1，2），（1，3），（1，5）剩下了一个1。
除去冗余关系：实际代码中没有array，也没有result，因为我们不需要。由于前面提到array里只可能同时存储一种数字，所以我们用major来表示当前array里存储的数，count表示array的长度,即目前暂时无法删除的元素个数，最后扫描完所有的数字，array和result变成一样了，都表示“最后还是无法删除的数字”。
```javascript
var majorityElement = function(nums) {
  let major = nums[0]
  let count = 1;
  for(let i = 1; i < nums.length; i++) {
    if(count === 0) {
      major = nums[i]
    }
    if(nums[i] === major) {
      count++
    } else {
      count--
    }
  }
  return major
};
```