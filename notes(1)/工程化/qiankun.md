### 友好的微前端方案

1. 技术栈无关

   1. 不限制技术栈，接入范围广
   2. 向后兼容，兼容年久的旧应用
   3. 向前兼容，架构稳定，面向未来

2. 接入简单

### qiankun 的技术实现和选择

#### 微前端框架面临的两大共性问题

1. 应用的加载与切换。

   1. 包括路由的处理
   2. 应用加载的处理
   3. 应用入口的选择。

2. 应用的隔离与通信。
   这是应用已经加载之后面临的问题，
   1. JS 的隔离（也就是副作用的隔离）
   2. 样式的隔离
   3. 也包括父子应用和子子应用之间的通信问题。

#### 应用路由与 Future State

1. 主应用 : /a/\*
   1. 应用 A
      /a/home
      /a/user
   2. 应用 B
      /b/home
      /b/list
2. single-spa 劫持路由，加载，路由切换

#### 应用接入：协议接入

子应用实现并导出三个生命周期钩子函数 bootstrap, mount, unmount

1. 当子应用第一次挂载的时候，我们会执行 bootstrap 做一些初始化，
2. 然后执行 mount 将它挂载。如果你是一个 React 技术栈的子应用，你可能就在 mount 里面写 ReactDOM.render ，把你的 ReactNode 挂载到真实的节点上，把应用渲染出来。
3. 当你应用切换走的时候，我们会执行 unmount 把应用卸载掉，当它再次回来的时候（典型场景：你从应用 A 跳到应用 B，过了一会儿又跳回了应用 A），这个时候我们是不需要重新执行一次所有的生命周期钩子的，我们不需要从 bootstrap 开始，我们会直接从 mount 阶段继续，这就也做到了应用的缓存。

#### App Entry 抉择

##### 1. 组合的时机：运行时

1. 构建时
   1. 说明：子应用与主应用一起打包发布
   2. 优点：构建时容易做公共依赖提取
   3. 缺点：主子应用构建方案，工具耦合，
2. 运行时
   1. 说明： 子应用独立构建运行时动态加载
   2. 优点：主子应用完全解耦，技术栈无关
   3. 缺点： 有运行时损耗

##### 2. 子应用入口选择：HTML Entry

qiankun 的第一选择其实是 HTML 入口，就是提供一份 HTML 文件。因为这份 HTML 中其实包含了子应用的所有信息。它包含网页的结构，包含了一些元信息。大家可以看到在这份 HTML 里我们有 CSS、JS 链接、有应用要挂载的根路由 root 的 DOM。这些信息是非常全面的，比单纯你拿 JS 和 CSS 组成一份资源列表作为入口，要清晰和完整得多。同时 HTML Entry 这样的设计，也使得我们在接入一些老旧应用的时候，更加简单。

1. html
1. 解耦更彻底，子应用不依赖主应用 Dom，子应用独立开发，能独立部署
1. 多了一次对 html 的请求，解析有性能损耗，无法做构建时优化
1. js
   1. 便于做构建时优化
   2. 依赖主应用提供挂载节点，打包产物体积膨胀，资源无法并行加载

### 应用隔离： JS 沙箱

再 qiankun 沙箱的实现里，我们会有两个环境：一个代表的是外部的部分，就是我们的全局环境 Global Env，指的是你框架应用所运行的全局环境。而子应用加载的时候，实际上是应该跑在一个内部的沙箱环境里面 Render Env

#### 快照沙箱

应用沙箱挂载和卸载的时候记录快照，
在应用切换的时候依据快照恢复环境，

当我子应用加载、启动了之后，此时的环境其实就是 Render Environment，是内部沙箱环境里，这个时候我记录一下当时的快照状态。而在我最后子应用 unmount 的时候，我把当前的环境和记录的快照进行一个对比，把它恢复回原来的全局状态。这就是说当我应用挂载了又卸载了，这个过程走了一遍之后，我当前整个 Windows 运行环境恢复成原来的样子，应用内部所做的修改，在它卸载的时候就会被恢复，这是快照沙箱思路。

举个例子，假如我们在 A 应用运行时，追加了一个全局变量，我们说 window.a = 123 ，这个时候 window.a 就变成了 123 ，但是在应用 A 卸载之后，快照还原， window.a 会被重新删除，你在全局环境中并不会继续看到 a 变量

一种是直接用 **windows diff**。把当前的环境和原来的环境做一个比较，我们跑两个循环，把两个环境作一次比较，然后去全量地恢复回原来的环境。

另一种思路其实是借助 ES6 的 **proxy**就是代理。通过劫持 window ，我们可以劫持到子应用对全局环境的一些修改。当子应用往 window 上挂东西、修改东西和删除东西的时候，我们可以把这个操作记录下来。当我们恢复回外面的全局环境的时候，我们只需要反向执行之前的操作即可。比如我们在沙箱内部设了一个新的变量 window.a = 123 。那在离开的时候，我们只需要把 a 变量删了即可。

快照沙箱这个思路也正是 qiankun1.0 所使用的思路，它相对完善，但是缺点在于无法支持多个实例，也就是说我两个沙箱不可能同时激活，我不能同时挂载两个应用，不然的话这两个沙箱之间会打架，导致错误。

#### 让子应用里面的环境和外面的环境完全隔离

A 应用就活在 A 应用的沙箱里面，B 应用就活在 B 应用的沙箱里面，两者之间要不发生干扰，这个沙箱的实现思路其实也是通过 ES6 的 proxy，也通过代理特性实现的。

### 应用隔离：样式隔离

1. 主子应用样式冲突
2. 子应用之间样式冲突

#### 样式隔离 Dynamic Stylesheet

动态样式表 当切换应用时，动态删除前一个应用的样式，加载新的应用的样式

#### 样式隔离 工程化手段

1. Bem
   不同项目用不同的前缀/命名规则避开冲突
   简单
   依赖约定，这也是耦合的一种，容易出纰漏

2. css modules
   通过编译生成不冲突的选择器名
   可靠易用，避免人工约束
   只能在构建时期使用，雨来预处理器和打包工具

3. css-in-js
   css 和 js 编码在一起，最终生成不冲突的选择器，
   基本彻底避免冲突
   运行时开销略确实完整 css 能力

#### 样式隔离方案 严格样式隔离 Shadow Dom

### 应用通信

#### 基于 url

#### 发布订阅模式

事件总线，应用之间不直接交互，统一在事件总线上注册，监听事件。

天然的时间总线：window.customEvent,在 window 上监听一个自定义事件，在任意地方派发一个自定义事件，我们可以天然的通过自定义事件来做到应用之间相互通信。

#### 基于 props

主应用是可以传递一些 props 给子用的。我们把 state 和 onGlobalStateChange （就是监听函数），还有我们的 onChange （就是 setGlobalState ）三个都传给子应用。我们基于 props 也就可以实现一个简单的主子应用之间通信。
