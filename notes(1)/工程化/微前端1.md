## bff

BFF 是一个服务于不同前端的后台服务，所有的前端（比如 iOS， Android 和 Web） 都依赖它。而且**BFF 是一个整合服务，它负责把前端的请求统一分发到各个具体的微服务上，对数据进行：裁剪、格式化、聚合等,然后把返回数据整合在一起统一返回给前端。**

有了 BFF，我们的 App 就不再需要往多个微服务发送请求，也不再需要处理复杂的并发请求，这样就有效减低了复杂度，避免竞态条件等非预期情况发生。

### BFF 的优势

主要有以下几点优势：

1. **可以降低沟通成本**：后端同学追求解耦，希望客户端应用和内部微服务不耦合，通过引入 BFF 这中间层，使得两边可以独立变化

2. **多端应用适配**：展示不同的（或更少量的）数据，比如 PC 端页面设计的 API 需要支持移动端，发现现有接口从设计到实现都与桌面 UI 展示需求强相关，无法简单适应移动端的展示需求 ，就好比 PC 端一个新闻推荐接口，接口字段 PC 端都需要，而移动端呢 H5 不需要，这个时候根据不同终端在 BFF 层做调整，同时也可以进行不同的（或更少的）API 调用（聚合）来减少 http 请求

当你在设计 API 时，会因为不同终端存在不同的区分，它们对服务端提供的 API 访问也各有其特点，需要做一些区别处理。这个时候如果考虑在原有的接口上进行修改，会因为修改导致耦合，破坏其单一的职责。

### BFF 的痛点

1. 重复开发：每个设备开发一个 BFF 应用，也会面临一些重复开发的问题展示，增加开发成本

2. 维护问题：需要维护各种 BFF 应用。以往前端也不需要关心并发，现在并发压力却集中到了 BFF 上

3. 链路复杂：流程变得繁琐，BFF 引入后，要同时走前端、服务端的研发流程，多端发布、互相依赖，导致流程繁琐

4. 浪费资源: BFF 层多了，资源占用就成了问题，会浪费资源，除非有弹性伸缩扩容

### 7、有什么方案可以解决传统 BFF 痛点

包括解决前端需要关心应用的**负载均衡、备份冗灾、监控报警**等一些列运维部署的操作

如何统一管理和运维，提高发布速度、降低运维成本

答案是：**Serverless**
少服务器的，亦或是无服务器的，弱化后端和运维概念
Serverless = Faas (Function as a service) + Baas (Backend as a service)

1. 云函数（Faas）
   FaaS（Function-as-a-Service）是服务商提供一个平台、提供给用户开发、运行管理这些函数的功能，而无需搭建和维护基础框架，是一种事件驱动由消息触发的函数服务
2. 后端即服务（ BaaS）
   BaaS（Backend-as-a-Service）后端即服务，包含了后端服务组件，它是基于 API 的第三方服务，用于实现应用程序中的核心功能，包含常用的数据库、对象存储、消息队列、日志服务等等。

比如腾讯云云开发中下面的这些服务：

1. 微信小程序的云调用 wx-server-sdk

2. 云开发数据库 wx.cloud.database

## 微前端入门

[原文链接](https://juejin.cn/post/6844903953734336525)

### 定义

将前端整体分解，每一块可以独立开发，测试和部署，同时对用户而言又是一个整体

### 优点

#### 1.增量升级

对于许多团队而言，这是开始微前端之旅的首要原因。技术债阻碍了项目的发展，只能重写。为了避免完全重写的风险，我们更希望 **逐个替换旧的模块**。

#### 2.简单、解耦的代码库

**代码少，耦合度低，容易维护**
每个单独的微型前端应用的源代码都将比单个整体前端应用的源代码少得多。这些较小的代码库对于开发人员来说更容易维护。尤其是我们避免了组件间耦合所导致的复杂性。

#### 3.独立部署

就像微服务一样，微前端的独立部署能力是关键。**部署范围的减小，带来了风险的降低。**每个微前端应用都应具有自己的持续交付途径，不停地构建、测试、部署。

### 集成

1. 后端模板的集成
2. package 集成
3. 通过 iframe 集成
   本质上来说，iframe 里的页面是完全独立的，可以轻松构建。而且 iframe 还提供了很多的隔离机制。
   在一个 web 应用中可以独立的运行另一个 web 应用

这个概念已经和微前端不谋而合，相对于目前配置复杂、高适配成本的微前端方案来说，采用 iframe 方案具有一些显著的优点：

非常简单，使用没有任何心智负担

  1. 隔离完美，无论是 js、css、dom 都完全隔离开来

  2. 多应用激活，页面上可以摆放多个 iframe 来组合业务

但是开发者又厌恶使用 iframe，因为缺点也非常明显：

  1. 路由状态丢失，刷新一下，iframe 的 url 状态就丢失了

  1. dom 割裂严重，弹窗只能在 iframe 内部展示，无法覆盖全局

  2. 通信非常困难，只能通过 postmessage 传递序列化的消息

  3. 白屏时间太长，对于 SPA 应用应用来说无法接受

1. 通过 JS 集成
   每个微前端都对应一个 <script> 标签，并且在加载时导出一个全局变量。然后，容器应用程序确定应该安装哪些微应用，并调用相关函数以告知微应用何时以及在何处进行渲染。

2. 通过 Web Component 集成

### 样式

### 共享组件库

### 跨应用通信

### 后端通信

推荐的模式是 Backends For Frontends 模式，其中每个前端应用程序都有一个相应的后端，后端的目的仅仅是为了满足该前端的需求。BFF 模式起初的粒度可能是每个前端平台（PC 页面、手机页面等）对应一个后端应用，但最终会变为每个微应用对应一个后端应用。
这里要说明一下，一个后端应用可能有独立业务逻辑和数据库的，也可能只是下游服务的聚合器。 如果微前端应用只有一个与之通信的 API，并且该 API 相当稳定，那么为它单独构建一个后台可能根本没有太大价值。指导原则是：构建微前端应用的团队不必等待其他团队为其构建什么事物。
因此，如果一个微前端用到的新功能需要后端接口的变更，那么这一前一后两个地方就应该交给一个团队来开发。

1. 应用的加载与切换。

   1. 包括路由的处理
   2. 应用加载的处理
   3. 应用入口的选择。

2. 应用的隔离与通信。
   这是应用已经加载之后面临的问题，
   1. JS 的隔离（也就是副作用的隔离）
   2. 样式的隔离
   3. 也包括父子应用和子子应用之间的通信问题。

## qiankun 微前端实战 （一）入门篇

[原文链接](https://juejin.cn/post/6844904158085021704)

### qiankun 接入 Vue 微应用

qiankun 内部通过 import-entry-html 加载微应用，要求微应用需要导出生命周期钩子函数

#### 注册

```javascript
const apps = [
  /**
   * name: 微应用名称 - 具有唯一性
   * entry: 微应用入口 - 通过该地址加载微应用
   * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上
   * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用
   */
  {
    name: "VueMicroApp",
    entry: "//localhost:10200",
    container: "#frame",
    activeRule: "/vue",
  },
];
```

#### 配置

1. 在 Vue 的入口文件 main.js 中，导出 qiankun 主应用所需要的三个生命周期钩子函数

```javascript
// micro-app-vue/src/public-path.js
if (window.__POWERED_BY_QIANKUN__) {
  // 动态设置 webpack publicPath，防止资源加载出错
  // eslint-disable-next-line no-undef
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}

// micro-app-vue/src/main.js
import Vue from "vue";
import VueRouter from "vue-router";
import Antd from "ant-design-vue";
import "ant-design-vue/dist/antd.css";

import "./public-path";
import App from "./App.vue";
import routes from "./routes";

Vue.use(VueRouter);
Vue.use(Antd);
Vue.config.productionTip = false;

let instance = null;
let router = null;

/**
 * 渲染函数
 * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行
 */
function render() {
  // 在 render 中创建 VueRouter，可以保证在卸载微应用时，移除 location 事件监听，防止事件污染
  router = new VueRouter({
    // 运行在主应用中时，添加路由命名空间 /vue
    base: window.__POWERED_BY_QIANKUN__ ? "/vue" : "/",
    mode: "history",
    routes,
  });

  // 挂载应用
  instance = new Vue({
    router,
    render: (h) => h(App),
  }).$mount("#app");
}

// 独立运行时，直接挂载应用
if (!window.__POWERED_BY_QIANKUN__) {
  render();
}

/**
 * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
 * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
 */
export async function bootstrap() {
  console.log("VueMicroApp bootstraped");
}

/**
 * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
 */
export async function mount(props) {
  console.log("VueMicroApp mount", props);
  render(props);
}

/**
 * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
 */
export async function unmount() {
  console.log("VueMicroApp unmount");
  instance.$destroy();
  instance = null;
  router = null;
}
```

2. 在配置好了入口文件 main.js 后，我们还需要配置 webpack(vue.config.js)，使 main.js 导出的生命周期钩子函数可以被 qiankun 识别获取。

```javascript
const path = require("path");
module.exports = {
  devServer: {
    // 监听端口
    port: 10200,
    // 关闭主机检查，使微应用可以被 fetch
    disableHostCheck: true,
    // 配置跨域请求头，解决开发环境的跨域问题
    headers: {
      "Access-Control-Allow-Origin": "*",
    },
  },
  configureWebpack: {
    resolve: {
      alias: {
        "@": path.resolve(__dirname, "src"),
      },
    },
    output: {
      // 微应用的包名，这里与主应用中注册的微应用名称一致
      library: "VueMicroApp",
      // 将你的 library 暴露为所有的模块定义下都可运行的方式,
      // 主应用就可以获取到微应用的生命周期钩子函数了。
      libraryTarget: "umd",
      // 按需加载相关，设置为 webpackJsonp_VueMicroApp 即可
      jsonpFunction: `webpackJsonp_VueMicroApp`,
    },
  },
};
```

### qiankun 接入 React 微应用

1.
2.

#### 注册

```javascript
const apps = [
  /**
   * name: 微应用名称 - 具有唯一性
   * entry: 微应用入口 - 通过该地址加载微应用
   * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上
   * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用
   */
  {
    name: "ReactMicroApp",
    entry: "//localhost:10100",
    container: "#frame",
    activeRule: "/react",
  },
];
export default apps;
```

#### 配置

1. 在 React 的入口文件 index.js 中，导出 qiankun 主应用所需要的三个生命周期钩子函数

```javascript
// micro-app-react/src/public-path.js
if (window.__POWERED_BY_QIANKUN__) {
  // 动态设置 webpack publicPath，防止资源加载出错
  // eslint-disable-next-line no-undef
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}

// micro-app-react/src/index.js
import React from "react";
import ReactDOM from "react-dom";
import "antd/dist/antd.css";

import "./public-path";
import App from "./App.jsx";

/**
 * 渲染函数
 * 两种情况：主应用生命周期钩子中运行 / 微应用单独启动时运行
 */
function render() {
  ReactDOM.render(<App />, document.getElementById("root"));
}

// 独立运行时，直接挂载应用
if (!window.__POWERED_BY_QIANKUN__) {
  render();
}

/**
 * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
 * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
 */
export async function bootstrap() {
  console.log("ReactMicroApp bootstraped");
}

/**
 * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
 */
export async function mount(props) {
  console.log("ReactMicroApp mount", props);
  render(props);
}

/**
 * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
 */
export async function unmount() {
  console.log("ReactMicroApp unmount");
  ReactDOM.unmountComponentAtNode(document.getElementById("root"));
}
```

2. 配置路由空间，以确保主应用可以正确加载微应用

```javascript
// micro-app-react/src/App.jsx
const BASE_NAME = window.__POWERED_BY_QIANKUN__ ? "/react" : "";
const App = () => {
  //...

  return (
    // 设置路由命名空间
    <Router basename={BASE_NAME}>{/* ... */}</Router>
  );
};
```

3. 配置 webpack

```javascript
// npm install react-app-rewired
// 修改 package.json
"scripts": {
  "start": "react-app-rewired start",
  "build": "react-app-rewired build",
  "test": "react-app-rewired test",
  "eject": "react-app-rewired eject"
}
// 新建config-overrides.js
const path = require("path");

module.exports = {
  webpack: (config) => {
    // 微应用的包名，这里与主应用中注册的微应用名称一致
    config.output.library = `ReactMicroApp`;
    // 将你的 library 暴露为所有的模块定义下都可运行的方式
    config.output.libraryTarget = "umd";
    // 按需加载相关，设置为 webpackJsonp_VueMicroApp 即可
    config.output.jsonpFunction = `webpackJsonp_ReactMicroApp`;

    config.resolve.alias = {
      ...config.resolve.alias,
      "@": path.resolve(__dirname, "src"),
    };
    return config;
  },

  devServer: function (configFunction) {
    return function (proxy, allowedHost) {
      const config = configFunction(proxy, allowedHost);
      // 关闭主机检查，使微应用可以被 fetch
      config.disableHostCheck = true;
      // 配置跨域请求头，解决开发环境的跨域问题
      config.headers = {
        "Access-Control-Allow-Origin": "*",
      };
      // 配置 history 模式
      config.historyApiFallback = true;

      return config;
    };
  },
};
```

## qiankun 微前端实战 （二）应用间通信篇

### Actions 通信

### redux 通信

<!-- ------------------ 分割线--------------------->
