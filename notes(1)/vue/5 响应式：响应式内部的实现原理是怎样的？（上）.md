### vue2.x 的响应式原理：

通过 Object.defineProperty 劫持数据的变化，在数据访问时收集依赖，修改数据时通知依赖更新

在 Vue.js 2.x 中，Watcher 就是依赖，有专门针对组件渲染的 render watcher。注意这里有两个流程：

1. 首先是依赖收集流程，组件在 render 的时候会访问模板中的数据，触发 getter 把 render watcher 作为依赖收集，并和数据建立联系；
2. 然后是派发通知流程，当我对这些数据修改的时候，会触发 setter，通知 render watcher 更新，进而触发了组件的重新渲染。

#### Object.defineProperty API 的不足

1. 不能监听对象属性新增和删除；
2. 初始化阶段递归执行 Object.defineProperty 带来的性能负担。

### reactive API

```js
function reactive(target) {
  // 如果尝试把一个 readonly proxy 变成响应式，直接返回这个 readonly proxy

  if (target && target.__v_isReadonly) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers
  );
}

function createReactiveObject(
  target,
  isReadonly,
  baseHandlers,
  collectionHandlers
) {
  if (!isObject(target)) {
    // 目标必须是对象或数组类型
    if (process.env.NODE_ENV !== "production") {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target.__v_raw && !(isReadonly && target.__v_isReactive)) {
    // target 已经是 Proxy 对象，直接返回
    // 有个例外，如果是 readonly 作用于一个响应式对象，则继续
    return target;
  }
  if (
    hasOwn(
      target,
      isReadonly ? "__v_readonly" /* readonly */ : "__v_reactive" /* reactive */
    )
  ) {
    // target 已经有对应的 Proxy 了
    return isReadonly ? target.__v_readonly : target.__v_reactive;
  }
  // 只有在白名单里的数据类型才能变成响应式
  if (!canObserve(target)) {
    return target;
  }
  // 利用 Proxy 创建响应式
  const observed = new Proxy(
    target,
    collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers
  );
  // 给原始数据打个标识，说明它已经变成响应式，并且有对应的 Proxy 了
  def(
    target,
    isReadonly ? "__v_readonly" /* readonly */ : "__v_reactive" /* reactive */,
    observed
  );

  return observed;
}
```

1. 函数首先判断 target 是不是数组或者对象类型，如果不是则直接返回。所以原始数据 target 必须是对象或者数组。

2. 如果对一个已经是响应式的对象再次执行 reactive，还应该返回这个响应式对象

```js
import { reactive } from "vue";
const original = { foo: 1 };
const observed = reactive(original);
const observed2 = reactive(observed);
observed === observed2;
```

因为这里 reactive 函数会通过 **target.\_\_v_raw** 属性来判断 target 是否已经是一个响应式对象（因为响应式对象的 **\_\_v_raw** 属性会指向它自身，后面会提到），如果是的话则直接返回响应式对象。

3. 如果对同一个原始数据多次执行 reactive ，那么会返回相同的响应式对象

```javascript
import { reactive } from "vue";
const original = { foo: 1 };
const observed = reactive(original);
const observed2 = reactive(original);
observed === observed2;
```

reactive 函数会通过 **target.\_\_v_reactive** 判断 target 是否已经有对应的响应式对象（因为创建完响应式对象后，会给原始对象打上 **\_\_v_reactive** 标识，后面会提到），如果有则返回这个响应式对象。

4. 使用 canObserve 函数对 target 对象做一进步限制：比如，带有 \_\_v_skip 属性的对象、被冻结的对象，以及不在白名单内的对象如 Date 类型的对象实例是不能变成响应式的。

```js
const canObserve = (value) => {
  return (
    !value.__v_skip &&
    isObservableType(toRawType(value)) &&
    !Object.isFrozen(value)
  );
};
const isObservableType = /*#__PURE__*/ makeMap(
  "Object,Array,Map,Set,WeakMap,WeakSet"
);
```

5. 通过 Proxy API 劫持 target 对象，把它变成响应式。我们把 Proxy 函数返回的结果称作响应式对象，这里 Proxy 对应的处理器对象会根据数据类型的不同而不同，我们稍后会重点分析基本数据类型的 Proxy 处理器对象，reactive 函数传入的 baseHandlers 值是 mutableHandlers。

6. 给原始数据打个标识，如下：

```js
target.__v_reactive = observed;
```

这就是前面“对同一个原始数据多次执行 reactive ，那么会返回相同的响应式对象”逻辑的判断依据。

### Proxy 处理器对象 mutableHandlers 的实现

```js
const mutableHandlers = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys,
};
```

它其实就是劫持了我们对 observed 对象的一些操作，比如：

1. 访问对象属性会触发 get 函数；
2. 设置对象属性会触发 set 函数；
3. 删除对象属性会触发 deleteProperty 函数；
4. in 操作符会触发 has 函数；
5. 通过 Object.getOwnPropertyNames 访问对象属性名会触发 ownKeys 函数。

因为无论命中哪个处理器函数，它都会做依赖收集和派发通知这两件事其中的一个，所以这里我只要分析常用的 get 和 set 函数就可以了。

### 依赖收集 get 函数

来看一下 get 函数的实现，其实它是执行 createGetter 函数的返回值，为了分析主要流程，这里省略了 get 函数中的一些分支逻辑，isReadonly 也默认为 false：

```js
function createGetter(isReadonly = false) {
  return function get(target, key, receiver) {
    if (key === "__v_isReactive" /* isReactive */) {
      // 代理 observed.__v_isReactive
      return !isReadonly;
    } else if (key === "__v_isReadonly" /* isReadonly */) {
      // 代理 observed.__v_isReadonly
      return isReadonly;
    } else if (key === "__v_raw" /* raw */) {
      // 代理 observed.__v_raw
      return target;
    }
    const targetIsArray = isArray(target);
    // arrayInstrumentations 包含对数组一些方法修改的函数
    if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    // 求值
    const res = Reflect.get(target, key, receiver);
    // 内置 Symbol key 不需要依赖收集
    if ((isSymbol(key) && builtInSymbols.has(key)) || key === "__proto__") {
      return res;
    }
    // 依赖收集
    !isReadonly && track(target, "get" /* GET */, key);
    return isObject(res)
      ? isReadonly
        ? readonly(res)
        : // 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式
          reactive(res)
      : res;
  };
}
```

1. 首先对特殊的 key 做了代理，这就是为什么我们在 createReactiveObject 函数中判断响应式对象是否存在 \_\_v_raw 属性，如果存在就返回这个响应式对象本身。
2. 接着通过 Reflect.get 方法求值，如果 target 是数组且 key 命中了 arrayInstrumentations，则执行对应的函数，我们可以大概看一下 arrayInstrumentations 的实现：

```javascript
const arrayInstrumentations = {}[
  ("includes", "indexOf", "lastIndexOf")
].forEach((key) => {
  arrayInstrumentations[key] = function (...args) {
    // toRaw 可以把响应式对象转成原始数据
    const arr = toRaw(this);
    for (let i = 0, l = this.length; i < l; i++) {
      // 依赖收集
      track(arr, "get" /* GET */, i + "");
    }
    // 先尝试用参数本身，可能是响应式数据
    const res = arr[key](...args);
    if (res === -1 || res === false) {
      // 如果失败，再尝试把参数转成原始数据
      return arr[key](...args.map(toRaw));
    } else {
      return res;
    }
  };
});
```

3. 通过 Reflect.get 求值，然后会执行 track 函数收集依赖

4. 函数最后会对计算的值 res 进行判断，如果它也是数组或对象，则递归执行 reactive 把 res 变成响应式对象。这么做是因为 Proxy 劫持的是对象本身，并不能劫持子对象的变化，这点和 Object.defineProperty API 一致。但是 Object.defineProperty 是在初始化阶段，即定义劫持对象的时候就已经递归执行了，而 Proxy 是在对象属性被访问的时候才递归执行下一步 reactive，这其实是一种**延时定义子对象响应式**的实现，在性能上会有较大的提升。

#### 执行 track 函数收集依赖

```js
// 是否应该收集依赖
let shouldTrack = true;
// 当前激活的 effect
let activeEffect;
// 原始数据对象 map
const targetMap = new WeakMap();
function track(target, type, key) {
  if (!shouldTrack || activeEffect === undefined) {
    return;
  }
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    // 每个 target 对应一个 depsMap
    targetMap.set(target, (depsMap = new Map()));
  }

  let dep = depsMap.get(key);
  if (!dep) {
    // 每个 key 对应一个 dep 集合
    depsMap.set(key, (dep = new Set()));
  }
  if (!dep.has(activeEffect)) {
    // 收集当前激活的 effect 作为依赖
    dep.add(activeEffect);
    // 当前激活的 effect 收集 dep 集合作为依赖
    activeEffect.deps.push(dep);
  }
}
```

每次 track ，就是把当前激活的副作用函数 activeEffect 作为依赖，然后收集到 target 相关的 depsMap 对应 key 下的依赖集合 dep 中。
