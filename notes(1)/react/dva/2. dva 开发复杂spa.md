[使用 Dva 开发复杂 SPA](https://dvajs.com/guide/develop-complex-spa.html#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDmodel)

# 动态加载 model

有不少业务场景下，我们可能会定义出很多个 model，但并不需要在应用启动的时候就全部加载，比较典型的是各类管理控制台。如果每个功能页面是通过路由切换，互相之间没有关系的话，通常会使用**webpack 的 require.ensure**来做代码模块的懒加载。

我们也可以利用这个特性来做 model 的动态加载。

```js
function RouterConfig({ history, app }) {
  const routes = [
    {
      path: "/",
      name: "IndexPage",
      getComponent(nextState, cb) {
        require.ensure([], (require) => {
          registerModel(app, require("./models/dashboard"));
          cb(null, require("./routes/IndexPage"));
        });
      },
    },
    {
      path: "/users",
      name: "UsersPage",
      getComponent(nextState, cb) {
        require.ensure([], (require) => {
          registerModel(app, require("./models/users"));
          cb(null, require("./routes/Users"));
        });
      },
    },
  ];

  return <Router history={history} routes={routes} />;
}
```

> require.ensure() 是 webpack 特有的，已被 import() 取代。

```js
require.ensure(
  dependencies: String[],
  callback: function(require),
  errorCallback: function(error),
  chunkName: String
)
```

> dependencies：字符串数组，声明 callback 回调函数中所需要的所有模块。
> callback：当依赖项加载完成后，webpack 将会执行此函数，require 函数的实现，作为参数传入此函数中。当程序运行需要依赖时，可以使用 require() 来加载依赖。函数体可以使用此参数，来进一步执行 require() 模块。
> errorCallback：当 webpack 加载依赖失败时会执行此函数。
> chunkName：由 require.ensure 创建的 chunk 的名称。通过将相同 chunkName 传递给不同的 require.ensure 调用，我们可以将其代码合并到一个单独的 chunk 中，从而只产生一个浏览器必须加载的 bundle
> [require.ensure]https://webpack.docschina.org/api/module-methods/#requireensure

这样，在视图切换到这个路由的时候，对应的 model 就会被加载。同理，也可以做 model 的动态移除，不过，一般情况下是不需要移除的。

# 动态扩展 model

```js
function createModel(options) {
  const { namespace, param } = options;
  return {
    namespace: `demo${namespace}`,
    states: {},
    reducers: {},
    effects: {
      *foo() {
        // 这里可以根据param来确定下面这个call的参数
        yield call();
      },
    },
  };
}

const modelA = createModel({ namespace: "A", param: { type: "A" } });
const modelB = createModel({ namespace: "A", param: { type: "B" } });
```

### 使用 take 操作进行事件监听

在 redux-saga 中，提供了 take 和 takeLatest 这两个操作，dva 是 redux-saga 的封装，也是可以使用这种操作的。

要理解 take 操作的语义，可以参见这两种示例的对比：

假设我们有一个事件处理的代码：

```js
someSource.on("click", (event) => doSomething(event));
// 这段代码转成用generator来表达，就是下面这个形式：

function* saga() {
  while (true) {
    const event = yield take("click");
    doSomething(event);
  }
}
```

所以，我们也可以在 dva 中使用 take 操作来监听 action。

### 多任务调度

```js
const [result1, result2]  = yield all([
  call(service1, param1),
  call(service2, param2)
])
```

### 任务的竞争

如果多个任务之间存在竞争关系，可以通过下面这种方式：

```js
const { data, timeout } = yield race({
  data: call(service, 'some data'),
  timeout: call(delay, 1000)
});

if (data)
  put({type: 'DATA_RECEIVED', data});
else
  put({type: 'TIMEOUT_ERROR'});
```

这个例子比较巧妙地用一个延时一秒的空操作来跟一个网络请求竞争，如果到了一秒，请求还没结束，就让它超时。

这个类似于 Promise.race 的作用。
