# state 是同步更新还是异步更新

## 为什么 State 是异步的”，这个问题得到了官方团队的回复，原因有 2 个。

- 保持内部一致性。如果改为同步更新的方式，尽管 setState 变成了同步，但是 props 不是。

- 为后续的架构升级启用并发更新。为了完成异步渲染，React 会在 setState 时，根据它们的数据来源分配不同的优先级，这些数据来源有：事件回调句柄、动画效果等，再根据优先级并发处理，提升渲染性能。

## 同步场景

setState 并不是真正的异步函数，它实际上是通过队列延迟执行操作实现的，通过 **isBatchingUpdates 来判断 setState 是先存进 state 队列还是直接更新**。值为 true 则执行异步操作，false 则直接同步更新。

1.  this.setState(newState)
2.  newState 存入 pending
3.  是否处于 batch update, 是转 4， 否转 5
4.  存组件于 dirtyComponents
5.  遍历所的 dirtyComponents , 调用 updateComponent 更新 pending state /props

## 回答

setState 并非真异步，只是看上去像异步。在源码中，通过 isBatchingUpdates 来判断
setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。

### 那么什么情况下 isBatchingUpdates 会为 true 呢？

- **在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。**

- 但在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。

一般认为，做异步设计是为了**性能优化、减少渲染次数**，React 团队还补充了两点。

- 保持内部一致性。如果将 state 改为同步更新，那尽管 state 的更新是同步的，但是 props 不是。

- 启用并发更新，完成异步渲染。

**注意 : 在 React 17 中，用 lanes 替代了 isBatchingUpdates。**

# 组件通信

1. 跨层级通信
   1. 单层
   - props 传递回调函数
   - ref 获取子组件实例，调用实例的实例函数 [不推荐]
   2. 多层
   - Context API
   - 全局变量、事件
     全局变量通过在 Windows 上挂载新对象的方式实现，这种方式一般用于临时存储值，这种值用于计算或者上报，缺点是渲染显示时容易引发错误。
     全局事件就是使用 document 的自定义事件，因为绑定事件的操作一般会放在组件的 componentDidMount 中，所以一般要求两个组件都已经在页面中加载显示，这就导致了一定的时序依赖。如果加载时机存在差异，那么很有可能导致两者都没能对应响应事件。
2. 状态管理框架

- Flux
- Redux
- Mobx

# 虚拟 DOM

## 实现

虚拟 DOM 在实现上通常是 Plain Object，以 React 为例，在 render 函数中写的 JSX 会在 Babel 插件的作用下，编译为 React.createElement 执行 JSX 中的属性参数。

React.createElement 执行后会返回一个 Plain Object，它会描述自己的 tag 类型、props 属性以及 children 情况等。这些 Plain Object 通过树形结构组成一棵虚拟 DOM 树。当状态发生变更时，将变更前后的虚拟 DOM 树进行差异比较，这个过程称为 diff，生成的结果称为 patch(这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；)。计算之后，会渲染 Patch 完成对真实 DOM 的操作。

## 优点

- 改善大规模 DOM 操作的性能
  首先，DOM 的渲染和浏览器的架构是有关系的，在 webkit 的浏览器架构中 DOM 模块和 js 的模块是互相独立且分割的，因此每次操作 DOM 的开销要比单纯的操作一次 js 开销要大。在整个前端项目中，浏览器的重绘和重排非常耗费性能，减少重绘和重排也是我们前端需要做的优化。
- 规避 XSS 风险、
- 能以较低的成本实现跨平台开发。

## 缺点

- 内存占用较高，因为需要模拟整个网页的真实 DOM。

- 高性能应用场景存在难以优化的情况，类似像 Google Earth 一类的高性能前端应用在技术选型上往往不会选择 React。

# Diff 算法

diff 算法是指生成更新补丁的方式，主要应用于虚拟 DOM 树变化后，更新真实 DOM。所以 diff 算法一定存在这样一个过程：触发更新 → 生成补丁 → 应用补丁。

## 更新时机

更新时机就是触发更新、进行差异对比的时机。根据前面的章节内容可以知道，更新发生在 setState、Hooks 调用等操作以后。此时，树的结点发生变化，开始进行比对。
那这里涉及一个问题，即两株树如何对比差异?

这里就需要使用遍历算法。

## 遍历算法

遍历算法是指沿着某条搜索路线，依次对树的每个节点做访问。通常分为两种：深度优先遍历和广度优先遍历。
react 采用了**深度优先遍历**算法。因为广度优先遍历可能会导致组件的生命周期时序错乱，而深度优先遍历算法就可以解决这个问题。

## 优化策略

1. 树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。

2. 组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。

3. 元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。

## Fiber 给 diff 算法带来的影响

Fiber 机制下节点与树分别采用 FiberNode 与 FiberTree 进行重构。FiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点，使得整个更新过程可以随时暂停恢复。FiberTree 则是通过 FiberNode 构成的树。

Fiber 机制下，整个更新过程由 current 与 workInProgress 两株树双缓冲完成。当 workInProgress 更新完成后，通过修改 current 相关指针指向的节点，直接抛弃老树，虽然非常简单粗暴，却非常合理。

# 渲染流程


## 挂载

1. reactDom.render 透传参数给 ReactMount.render(), 完成初始化 React 组件的整个过程
2. 初始化第一步就是通过 React.creatElement 创建 React Element。不同的组件类型会被构建为不同的 Element：完成实例化
3. 处理状态变更，ReactUpdates 负责处理变更收集再批量处理的过程，批量处理的前后操作，由 React 通过建立事务来处理
4. React 事务都是基于 Transaction 类继承拓展。每个 Transaction 实例都是一个封闭空间，保持不可变的任务常量，并提供对应的事务处理接口
### 事务
+ 原子性: 事务作为一个整体被执行，要么全部被执行，要么都不执行。

+ 隔离性: 多个事务并发执行时，一个事务的执行不应影响其他事务的执行。

+ 一致性: 相同的输入，确定能得到同样的执行结果。
## 更新

1. setState => this.updater.enqueueSetState(this, partialState)
2. 会调用 ReactCompositeComponent 实例中的_pendingStateQueue，将新的状态变更加入实例的等待更新状态队列中，再调用ReactUpdates 模块中的 enqueueUpdate 函数执行更新。 检查更新是否已经在进行中：

+ 如果是，则把组件加入 dirtyComponents 中；

+ 如果不是，先初始化更新事务，然后把组件加入 dirtyComponents 列表。

## 卸载
对于自定义组件，也就是对 ReactCompositeComponent 而言，卸载过程需要递归地调用生命周期函数
```js
class CompositeComponent{
  unmount(){
    var publicInstance = this.publicInstance
    if(publicInstance){
      if(publicInstance.componentWillUnmount){
        publicInstance.componentWillUnmount()
      }
    }
    var renderedComponent = this.renderedComponent
    renderedComponent.unmount()
  }
}
```
而对于 ReactDOMComponent 而言，卸载子元素需要清除事件监听器并清理一些缓存。
```js
class DOMComponent{
  unmount(){
    var renderedChildren = this.renderedChildren
    renderedChildren.forEach(child => child.unmount())
  }

}
```
## fiber Reconciler
+ 在 React Element 的基础上，通过 createFiberFromElement 函数创建 Fiber 对象。Fiber 不仅包含 React Element，还包含了指向父、子、兄弟节点的属性，保证 Fiber 构成的虚拟 DOM 树成为一个双向链表。

+ effect 是指在协调过程中必须执行计算的活动。
### Render
在新的架构下，整个生命周期被划分为 Render 和 Commit 两个阶段。Render 阶段的执行特点是可中断、可停止、无副作用

Render 阶段主要是通过构造 workInProgress 树计算出 diff。以 current 树为基础，将每个 Fiber 作为一个基本单位，自下而上逐个节点检查并构造 workInProgress 树。这个过程不再是递归，而是基于循环来完成。

在执行上通过 requestIdleCallback 来调度执行每组任务，每组中的每个计算任务被称为 work，每个 work 完成后确认是否有优先级更高的 work 需要插入，如果有就让位，没有就继续。优先级通常标记为动画或者 high 的会先处理。每完成一组后，将调度权交回主线程，直到下一次 requestIdleCallback 调用，再继续构建 workInProgress 树。

### Commit

在 Commit 阶段处理 effect 列表，这里的 effect 列表包含了根据 diff 更新 DOM 树、回调生命周期、响应 ref 等。

但一定要注意，这个阶段是同步执行的，不可中断暂停，所以不要在 componentDidMount、componentDidUpdate、componentWiilUnmount 中执行重度消耗算力的任务。

# 渲染异常

# 性能
## 指标
+ FCP（First Contentful Paint），
首次绘制内容的耗时。首屏统计的方式一直在变，起初是通过记录 window.performance.timing 中的 domComplete 与 domLoading 的时间差来完成，但这并不具备交互意义，现在通常是记录初次加载并绘制内容的时间。

+ TTI（Time to Interact）
是页面可交互的时间。通常通过记录 window.performance.timing 中的 domInteractive 与 fetchStart 的时间差来完成。

+ Page Load
页面完全加载时间。通常通过记录 window.performance.timing 中的 loadEventStart 与 fetchStart 的时间差来完成。

+ FPS
前端页面帧率。通常是在主线程打点完成记录。其原理是 requestAnimationFrame 会在页面重绘前被调用，而 FPS 就是计算两次之间的时间差。
```js
let lastTime = performance.now()
let frame = 0
let lastFameTime = performance.now()
const loop = (time) => {
    const now = performance.now()
    lastFameTime = now
    frame++
    if (now > 1000 + lastTime) {
        let fps = Math.round(frame / (( now - lastTime ) / 1000))
        frame = 0
        lastTime = now
        console.log(fps)
    }
    window.requestAnimationFrame(loop) 
}
```
+ 静态资源及API 请求成功率。
通常是通过 window.performance.getEntries( ) 来获取相关信息。



以上就是衡量的理论基础、指标体系与采集方式，那么接下来看一下如何优化。

在性能监控中有一个概念叫TP（Top Percentile），比如 TP50、TP90、TP99 和 TP999 等指标，指高于 50%、90%、99% 等百分线的情况。如 TP50 就意味着，50% 的用户打开页面绘制内容的时间不超过 6 秒，90%的用户不超过 8 秒。如果要提升 FCP，那么就需要提升 TP 50、TP90、TP999 下的数据，这才是有正确方向的目标。

这样对于优化大致就有一个落脚点了，接下来就可以探讨如何做实施工作了。

实施
这部分拿 FCP、TTI、Page Load、FPS、静态资源及 API 请求成功率这六个指标来进行讲解。

### FCP

+ loading
+ 骨架屏幕
+ ssr

### TTI

TTI 在实现上，可以优先加载让用户关注的内容，让用户先用起来。策略上主要是**将异步加载与懒加载相结合**。比如：

+ 核心内容在 React 中同步加载；

+ 非核心内容采取异步加载的方式延迟加载

内容中的图片采用懒加载的方式避免占用网络资源。

### Page Load

页面完整加载时间同样可以通过异步加载的方式完成。异步加载主要由 Webpack 打包 common chunk 与异步组件的方式完成。

### FPS

FPS 主要代表了卡顿的情况，在 React 中引起卡顿的主要原因有长列表与重渲染。长列表的解决方案很成熟，直接使用 react-virtualized 或者 react-window 就可以，相关的原理你可以自行学习；重渲染的问题比较复杂，下一讲我会详细讲解。

### 静态资源及 API 请求成功率

静态资源及 API 请求成功率的统计是非常有意义的。两者都有可能出现在用户的机器上失败，但在自己的电脑上毫无问题的情况。导致这个问题的原因千奇百怪。

你是直接从前端服务器拉取 JS 与 CSS 资源，还是从 CDN 拉取的？

解析 CDN 与 API 域名存在失败的情况。

运营商对静态资源及 API 请求做了篡改，导致请求失败。

那怎么解决这些问题呢？

对于静态资源而言，能用 CDN 就用 CDN，可以大幅提升静态资源的成功率。

如果域名解析失败，就可以采取静态资源域名自动切换的方案；还有一个简单的方案是直接寻求 SRE 的协助。

如果有运营商对内容做了篡改，我推荐使用 HTTPS。

收益
技术必须服务于业务，否则就只是技术团队的自嗨。

所以从技术角度讲收益，需要从业务实际效益出发。就像开篇所说的：“如果一个移动端页面加载时长超过 3 秒，用户就会放弃而离开。”那么将 TP999 从 5 秒优化到 3 秒以内，就可以得出具体的用户转化率数据。这样的技术优化才是对公司有帮助的。


# 重渲染
## 定位问题
1. chrome 自带的Performance 分析，主要用于查询 JavaScript 执行栈中的耗时，确认函数卡顿点
2. React Developer Tools 中的 Profiler 分析组件渲染次数、开始时间及耗时 
常见的坑
在 React Profiler 的运行结果中，我们可以看出，避免重复渲染并不是不让它去渲染。

+ 如果页面有显示信息变化的需求，那就要重新渲染；

+ 但如果仅仅是更新单个组件，却触发了大量无关组件更新，那就有问题了。

所以我们**避免的是无效的重复渲染**，毕竟协调成本很昂贵。

## 解决
通常的解决方案是加 PureComponent 或者使用 React.memo 等组件缓存 API，减少重新渲染。但错误的使用方式会使其完全无效，比如在 JSX 的属性中使用箭头函数，或者每次都生成新的对象，那基本就破防了。
通过浅比较的方式对比变化前后的 props 与 state
```js
 if (type.prototype && type.prototype.isPureReactComponent) {

      return (

        !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)

      );

    }

```


针对这样的情况有三个解决方案：

+ 缓存，通常使用 reselect 缓存函数执行结果，来避免产生新的对象；

+ 不可变数据，使用数据 ImmutableJS 或者 immerjs 转换数据结构；

+ 手动控制，自己实现 shouldComponentUpdate 函数，但这类方案一般不推荐，因为容易带来意想不到的 Bug，可以作为保底手段使用。

通过以上的手段就可以避免无效渲染带来的性能问题了。

# react hook的使用限制
React Hooks 的限制主要有两条：

+ 不要在循环、条件或嵌套函数中调用 Hook；

+ 在 React 的函数组件中调用 Hook。

那为什么会有这样的限制呢？就得从 Hooks 的设计说起。Hooks 的设计初衷是为了改进 React 组件的开发模式。在旧有的开发模式下遇到了三个问题。

1. 组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、render props 及状态管理框架。

2. 复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。

3. 人和机器都很容易混淆类。常见的有 this 的问题，但在 React 团队中还有类难以优化的问题，他们希望在编译优化层面做出一些改进。

这三个问题在一定程度上阻碍了 React 的后续发展，所以为了解决这三个问题，Hooks 基于函数组件开始设计。然而第三个问题决定了 Hooks 只支持函数组件。

那为什么不要在循环、条件或嵌套函数中调用 Hook 呢？因为 Hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，实质上 React 的源码里不是数组，是链表。

这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为了避免这样的情况，可以引入 ESLint 的 Hooks 检查插件进行预防。

# useEffect 与 useLayoutEffect 区别在哪里？

LayoutEffect 与普通的 Effect 都是 effect，但标记并不一样，所以在调用时，就会有些许不同。标记为 HookLayout 的 effect 会在所有的 DOM 变更之后同步调用，所以可以使用它来读取 DOM 布局并同步触发重渲染。

useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景，
而 LayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 LayoutEffect 做计算量较大的耗时任务从而造成阻塞。

# 谈谈 React Hook 的设计模式

首先用 Hooks 开发需要抛弃生命周期的思考模式，以 effects 的角度重新思考。过去类组件的开发模式中，在 componentDidMount 中放置一个监听事件，还需要考虑在 componentWillUnmount 中取消监听，甚至可能由于部分值变化，还需要在其他生命周期函数中对监听事件做特殊处理。在 Hooks 的设计思路中，可以将这一系列监听与取消监听放置在一个 useEffect 中，useEffect 可以不关心组件的生命周期，只需要关心外部依赖的变化即可，对于开发心智而言是极大的减负。这是 Hooks 的设计根本。

在这样一个认知基础上，我总结了一些在团队内部开发实践的心得，做成了开发规范进行推广。

第一点就是 React.useMemo 取代 React.memo，因为 React.memo 并不能控制组件内部共享状态的变化，而 React.useMemo 更适合于 Hooks 的场景。

第二点就是常量，在类组件中，我们很习惯将常量写在类中，但在组件函数中，这意味着每次渲染都会重新声明常量，这是完全无意义的操作。其次就是组件内的函数每次会被重新创建，如果这个函数需要使用函数组件内部的变量，那么可以用 useCallback 包裹下这个函数。

第三点就是 useEffect 的第二个参数容易被错误使用。很多同学习惯在第二个参数放置引用类型的变量，通常的情况下，引用类型的变量很容易被篡改，难以判断开发者的真实意图，所以更推荐使用值类型的变量。当然有个小技巧是 JSON 序列化引用类型的变量，也就是通过 JSON.stringify 将引用类型变量转换为字符串来解决。但不推荐这个操作方式，比较消耗性能。

这是开发实践上的一些操作。那么就设计模式而言，还需要顾及 Hooks 的组合问题。在这里，我的实践经验是采用外观模式，将业务逻辑封装到各自的自定义 Hook 中。比如用户信息等操作，就把获取用户、增加用户、删除用户等操作封装到一个 Hook 中。而组件内部是抽空的，不放任何具体的业务逻辑，它只需要去调用单个自定义 Hook 暴露的接口就行了，这样也非常利于测试关键路径下的业务逻辑。

以上就是我在设计上的一些思考。

