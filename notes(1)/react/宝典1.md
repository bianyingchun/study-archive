## 如何解释 React 是什么？/谈一谈你对 React 的理解。

解题思路

1. 讲概念：用简洁的话说清楚该技术是什么。最好能用一句话描述。

2. 说用途：描述该技术的用途。能够具体结合适合场景，拓展性的描述。

3. 理思路：梳理该技术的核心思路或运作流程。这个地方可深可浅，如果对其有足够深入的了解，建议详细地展开说明。

4. 优缺点，列一遍：对该技术栈的优缺点进行列举。列举优缺点肯定有与其他技术方案横向对比的过程，那么在这个过程中，切忌刻意地踩一捧一，容易引发面试官的反感。

### 1. 概念

React 是通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。

### 2. 用途

React 的用途当然是**构建视图**啦。由于 React 虚拟 DOM 的关系，在适用场景上远比传统框架更为广泛：

1. 首先无论是 PC 网页还是移动端网页，都是完全支持的
2. 其次由于 React Native，也可以用于开发 iOS 与 Android 应用
3. 还有 React 360 可以开发 VR 应用
4. 冷门儿的如 ink，也可以使用 React 开发命令行应用。

React 的生态极大地丰富了其使用场景。

### 3. 核心思路

它的核心设计思路有三点，分别是声明式、组件化与 通用性。

1. 声明式的优势在于 **直观与组合**。
2. 组件化的优势在于**视图的拆分与模块复用，可以更容易做到高内聚低耦合**。
3. 通用性在于一次学习，随处编写。比如 React Native，React 360 等， 这里主要靠**虚拟 DOM** 来保证实现。

### 4.优缺点

虚拟 dom 使得 React 的适用范围变得足够广，无论是 Web、Native、VR，甚至 Shell 应用都可以进行开发。这也是 React 的优势。
但作为一个视图层的框架，React 的劣势也十分明显。它并没有提供完整的一揽子解决方 案，在开发大型前端应用时，需要向社区寻找并整合解决方案。虽然一定程度上促进了社区的繁荣，但也为开发者在技术选型和学习适用上造成了一定的成本。

## 为什么 React 要用 JSX

解题思路：

1. 一句话解释 JSX。首先能一句话说清楚 JSX 到底是什么。
2. 核心概念。JSX 用于解决什么问题？如何使用？
3. 方案对比。与其他的方案对比，说明 React 选用 JSX 的必要性。

### 一句话解释 JSX

按照 React 官方的解释，**JSX 是一个 JavaScript 的语法扩展**，或者说是一个类似于 XML 的 ECMAScript 语法扩展。

### 核心概念

JSX 主要用于**声明 React 元素**，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 **React.createElement 的一种语法糖**。

所以从这里可以看出，React 团队并不想引入 JavaScript 本身以外的开发体系。而是希望通过合理的**关注点分离**保持组件开发的纯粹性。

### 方案对比

1. 首先是模板，React 团队认为**React 团队认为引入模板是一种不佳的实现。 因为模板分离了技术栈，而非关注点的模板同时又引入了更多的概念。比如新的模板语法、模板指令等**
2. 其次是模板字符串，**模板字符串编写的结构会造成多次内部嵌套，使整个结构变得复杂，并且优化代码提示也会变得困难重重。**
3. 大括号不能为元素在树中开始和结束的位置，提供很好的语法提示。

## Babel 插件如何实现 JSX 到 JS 的编译

Babel 读取代码并解析，生成 AST，再将 AST 传入插件层进行转换，在转换时就可以将 JSX 的结构转换为 React.createElement 的函数。

```js
module.exports = function (babel) {
  var t = babel.types;

  return {
    name: "custom-jsx-plugin",

    visitor: {
      JSXElement(path) {
        var openingElement = path.node.openingElement;

        var tagName = openingElement.name.name;

        var args = [];
        args.push(t.stringLiteral(tagName));
        var attribs = t.nullLiteral();
        args.push(attribs);
        var reactIdentifier = t.identifier("React"); //object

        var createElementIdentifier = t.identifier("createElement");

        var callee = t.memberExpression(
          reactIdentifier,
          createElementIdentifier
        );

        var callExpression = t.callExpression(callee, args);

        callExpression.arguments = callExpression.arguments.concat(
          path.node.children
        );

        path.replaceWith(callExpression, path.node);
      },
    },
  };
};
```

## 如何避免生命周期中的坑

解题思路

1. 基于周期的梳理，确认生命周期函数的使用方式；
   挂载 更新 卸载
2. 基于职责的梳理，确认生命周期函数的适用范围。
   状态变更 错误处理

### 周期梳理

1. 挂载
   挂载阶段是指组件从初始化到完成加载的过程。
   constructor
   getDerivedStateFromProps
   UNSAFE_componentWillMount
   render
   componentDidMount
2. 更新
   UNSAFE_componentWillReceiveProps
   getDerivedStateFromProps
   shouldComponentUpdate
   UNSAFE_componentWillUpdate
   render
   getSnapshotBeforeUpdate
   componentDidUpdate
3. 卸载
   componentWillUnmount

![](./宝典-react生命周期.png)

### 职责梳理

#### 什么情况下会触发重新渲染。

##### 函数组件

**函数组件任何情况下都会重新渲染**。它并没有生命周期，但官方提供了一种方式优化手段，那就是 React.memo。
React.memo 并不是阻断渲染，而是跳过渲染组件的操作并直接复用最近一次渲染的结果，这与 shouldComponentUpdate 是完全不同的。

##### React.Component

如果不实现 shouldComponentUpdate 函数，那么有两种情况触发重新渲染。

1. 当 state 发生变化时。这个很好理解，是常见的情况。
2. 父级重新渲染。无论 Props 有没有变化，只要传入就会引发重新渲染。

##### React.PureComponent

PureComponent 默认实现了 shouldComponentUpdate 函数。所以仅在 props 与 state 进行浅比较后，确认有变更时才会触发重新渲染。

#### 渲染中发生报错后会怎样？又该如何处理？错误边界

错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，如下 React 官方所给的示例：

```js
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error) {
    // 更新 state 使下一次渲染能够显示降级后的 UI
    return { hasError: true };
  }
  componentDidCatch(error, errorInfo) {
    // 你同样可以将错误日志上报给服务器
    logErrorToMyService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // 你可以自定义降级后的 UI 并渲染
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
```

无论是 React，还是 React Native，如果没有错误边界，在用户侧看到的现象会是这样的：在执行某个操作时，触发了 Bug，引发了崩溃，页面突然白屏。

但渲染时的报错，只能通过 **componentDidCatch 捕获**。这是在做线上页面报错监控时，极其容易忽略的点儿。

### react 中某个组件的状态变了，但是内部的一个子组件并没有变化，那么这个子组件会重新渲染吗？

“重新渲染”和“更新过程”是有区别的，只要明白这两个规则就好了。

1. 一个组件如果重新渲染，那么它的子组件也会开始更新过程；
2. 任何一个组件的 shouldComponentUpdate 函数如果返回 false，那更新过程就中止了；

假如题主说的“某个组件”为 X，它的子组件为 Y，当 X 的状态改变时，其实连 X 也未必会重新渲染，要看 X 的 shouldComponentUpdate 如何实现，如果返回 false，X 就不会被重新渲染了，Y 当然更不会。

现在假设 shouldComponentUpdate 没有从中作梗，X 开始了正常重新渲染，那么作为子组件的 Y 肯定会开始更新过程，不过，如果 Y 的 shouldComponentUpdate 返回 false 的话，那 Y 的更新过程也会被中止，不会重新渲染。所以，关键要看组件的 shouldComponentUpdate 如何实现。

作者：程墨 Morgan
链接：https://www.zhihu.com/question/49641418/answer/160970947
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## React 的请求应该放在哪里，为什么

对于异步请求，应该放在 componentDidMount 中去操作。从时间顺序来看，除了 componentDidMount 还可以有以下选择：

1. constructor：可以放，但从设计上而言不推荐。constructor 主要用于初始化 state 与函数绑定，并不承载业务逻辑。而且随着类属性的流行，constructor 已经很少使用了。

2. componentWillMount：已被标记废弃，在新的异步渲染架构下会触发多次渲染，容易引发 Bug，不利于未来 React 升级后的代码维护。

所以 React 的请求放在 componentDidMount 里是最好的选择。

## 函数组件和类组件的区别

1. 作为组件而言，类组件和函数组件在使用和呈现上没有任何不同，性能上在现代浏览器上也不会有明显差异

2. 但是在开发是的心智模型确存在巨大差异，类组件是基于面向对象编程的，主打的是继承、生命周期等核心概念。而函数组件内核是函数式编程，而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。

3. 之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。

4. 其次继承并不是组件最佳的设计模式，官方更推崇**组合优于继承**的设计概念，所以类组件在这方面的优势也在淡出。

5. 性能优化上，类组件主要依靠 shouldComponentUpdate  阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。

6. 从上手程度而言，类组件更容易上手，从未来趋势上看，由于 React Hooks 的推出，函数组件成了社区未来主推的方案。

7. 类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。

## 如何设计组件

React 社区中非常经典的分类模式：

- 把只作展示、独立运行、不额外增加功能的组件，称为哑组件，或无状态组件，还有一种叫法是展示组件；

- 把处理业务逻辑与数据状态的组件称为有状态组件，或灵巧组件，灵巧组件一定包含至少一个灵巧组件或者展示组件

从分类中可以看出展示组件的复用性更强，灵巧组件则更专注于业务本身。

React 组件应从设计与工程实践两个方向进行探讨。

从设计上而言，社区主流分类的方案是展示组件与灵巧组件。

1. **展示组件内部没有状态管理，仅仅用于最简单的展示表达。展示组件中最基础的一类组件称作代理组件。代理组件常用于封装常用属性、减少重复代码**。很经典的场景就是引入 Antd 的 Button 时，你再自己封一层。如果未来需要替换掉 Antd 或者需要在所有的 Button 上添加一个属性，都会非常方便。基于代理组件的思想还可以继续分类，分为样式组件与布局组件两种，分别是将样式与布局内聚在自己组件内部。

2. **灵巧组件由于面向业务，其功能更为丰富，复杂性更高，复用度低于展示组件。最经典的灵巧组件是容器组件。在开发中，我们经常会将网络请求与事件处理放在容器组件中进行。容器组件也为组合其他组件预留了一个恰当的空间。还有一类灵巧组件是高阶组件。高阶组件被 React 官方称为 React 中复用组件逻辑的高级技术，它常用于抽取公共业务逻辑或者提供某些公用能力。**常用的场景包括检查登录态，或者为埋点提供封装，减少样板代码量。高阶组件可以组合完成链式调用，如果基于装饰器使用，就更为方便了。高阶组件中还有一个经典用法就是反向劫持，通过重写渲染函数的方式实现某些功能，比如场景的页面加载圈等。但高阶组件也有两个缺陷，第一个是静态方法不能被外部直接调用，需要通过向上层组件复制的方式调用，社区有提供解决方案，使用 hoist-non-react-statics 可以解决；第二个是 refs 不能透传，使用 React.forwardRef API 可以解决。

从工程实践而言，通过文件夹划分的方式切分代码。我初步常用的分割方式是将页面单独建立一个目录，将复用性略高的 components 建立一个目录，在下面分别建立 basic、container 和 hoc 三类。这样可以保证无法复用的业务逻辑代码尽量留在 Page 中，而可以抽象复用的部分放入 components 中。其中 basic 文件夹放展示组件，由于展示组件本身与业务关联性较低，所以可以使用 Storybook 进行组件的开发管理，提升项目的工程化管理能力。
