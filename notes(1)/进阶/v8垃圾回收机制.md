## 为什么需要垃圾回收

chrome 中 v8 被限制了内存使用，

1. 表层原因是，V8 最初为浏览器而设计，不太可能遇到用大量内存的场景
2. 深层原因是，V8 的垃圾回收机制的限制（如果清理大量的内存垃圾是很耗时间，这样回引起 JavaScript 线程暂停执行的时间，那么性能和应用直线下降）

前面说到**栈内的内存，操作系统会自动进行内存分配和内存释放**，而堆中的内存，由 JS 引擎（如 Chrome 的 V8）手动进行释放，当我们代码的按照正确的写法时，会使得 JS 引擎的垃圾回收机制无法正确的对内存进行释放（内存泄露），从而使得浏览器占用的内存不断增加，进而导致 JavaScript 和应用、操作系统性能下降。

## chrome 垃圾回收算法

在 JavaScript 中，其实绝大多数的对象存活周期都很短，大部分在经过一次的垃圾回收之后，内存就会被释放掉，而少部分的对象存活周期将会很长，一直是活跃的对象，不需要被回收。为了提高回收效率，**V8 将堆分为两类新生代和老生代，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。**

新生区通常只支持 1 ～ 8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

- 副垃圾回收器 - Scavenge：主要负责\**新生代*的垃圾回收。
- 主垃圾回收器 - Mark-Sweep & Mark-Compact：主要负责老生代的垃圾回收。

### 1. 新生代

1. 存放的是生存时间短的对象
2. 容量较小，通常只支持 1~8M 的容量
3. 使用副垃圾回收器，scavenge

### 2. 老生代

1. 存放的是生存时间长的对象
2. 容量较大
3. 主垃圾回收器 - Mark-Sweep & Mark-Compact

## 新生代垃圾回收器 scavenge

在 JavaScript 中，**任何对象的声明分配到的内存，将会先被放置在新生代中**，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。在新生代中，主要使用 Scavenge 算法进行垃圾回收，Scavenge 算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。

### from-to space

Scavange 算法将新生代堆分为两部分，分别叫 from-space 和 to-space，工作方式也很简单，就是**将 from-space 中存活的活动对象复制到 to-space 中，并将这些对象的内存有序的排列起来，然后将 from-space 中的非活动对象的内存进行释放，完成之后，将 from space 和 to space 进行互换**，这样可以使得新生代中的这两块区域可以重复利用。

1. 标记活动和非活动对象
2. 复制 from space 的活动对象到 to space
3. 释放 from space 中的非活动对象的内存
4. 将 from space 和 to space 角色互换

### 垃圾回收器是怎么知道哪些对象是活动对象和非活动对象的呢

#### 可达性

[参考链接](https://segmentfault.com/a/1190000018605776)

“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中

从初始的根对象（window，global）的指针开始，这个根指针对象被称为根集（root set），从这个根集向下搜索其子节点，被搜索到的子节点说明该节点的引用对象可达，并为其留下标记，然后递归这个搜索的过程，直到所有子节点都被遍历结束，那么没有被标记的对象节点，说明该对象没有被任何地方引用，可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。

**1. 有一组基本的固有可达值，由于显而易见的原因无法删除。例如:**

本地函数的局部变量和参数
当前嵌套调用链上的其他函数的变量和参数
全局变量
还有一些其他的，内部的
这些值称为根。

**2. 如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。**

例如，如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为可达性， 它引用的那些也是可以访问的，详细的例子如下。

JavaScript 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，并删除那些不可访问的对象

##### 一个引用

下面是最简单的例子:

```js
// user 具有对象的引用
let user = {
  name: "John",
};
```

这里箭头表示一个对象引用。全局变量“user”引用对象 {name:“John”} (为了简洁起见，我们将其命名为 John)。John 的 “name” 属性存储一个基本类型，因此它被绘制在对象中。

如果 user 的值被覆盖，则引用丢失:

```js
user = null;
```

现在 John 变成不可达的状态，没有办法访问它，没有对它的引用。垃圾回收器将丢弃 John 数据并释放内存。

###### 两个引用

现在让我们假设我们将引用从 user 复制到 admin:

```js
// user 具有对象的引用
let user = {
  name: "John",
};

let admin = user;
```

现在如果我们做同样的事情:

```js
user = null;
```

该对象仍然可以通过 admin 全局变量访问，所以它在内存中。如果我们也覆盖 admin，那么它可以被释放。

###### 相互关联的对象

现在来看一个更复杂的例子， family 对象：

```js
function marry(man, woman) {
  woman.husban = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman,
  };
}

let family = marry(
  {
    name: "John",
  },
  {
    name: "Ann",
  }
);
```

到目前为止，所有对象都是可访问的。

现在让我们删除两个引用:

```js
delete family.father;
delete family.mother.husband;
```

仅仅删除这两个引用中的一个是不够的，因为所有对象仍然是可访问的。

但是如果我们把这两个都删除，那么我们可以看到 John 不再有传入的引用:

输出引用无关紧要。只有传入的对象才能使对象可访问，因此，John 现在是不可访问的，并将从内存中删除所有不可访问的数据。

### 新生代中的对象什么时候变成老生代的对象呢？

在新生代中，还进一步进行了细分，分为**nursery 子代和 intermediate 子代**两个区域，**一个对象第一次分配内存时会被分配到新生代中的 nursery 子代，如果进过下一次垃圾回收这个对象还存在新生代中，这时候我们移动到 intermediate 子代，再经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升。**

## 老生代垃圾回收器 Mark-Sweep & Mark-Compact

### Mark-Sweep

Mark-Sweep 处理时分为两阶段，标记阶段和清理阶段，看起来与 Scavenge 类似，不同的是，Scavenge 算法是复制活动对象，而由于在老生代中活动对象占大多数，所以 Mark-Sweep 在标记了活动对象和非活动对象之后，直接把非活动对象清除。**标记阶段：对老生代进行第一次扫描，标记活动对象**,. **清理阶段：对老生代进行第二次扫描，清除未被标记的对象，即清理非活动对象**

- 垃圾回收器获取根并“标记”(记住)它们。
- 然后它访问并“标记”所有来自它们的引用。
- 然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。
- 以此类推，直到有未访问的引用(可以从根访问)为止。
- 除标记的对象外，所有对象都被删除。

看似一切 perfect，但是还遗留一个问题，被清除的对象遍布于各内存地址，产生很多内存碎片。

### Mark-Compact

由于 Mark-Sweep 完成之后，老生代的内存中产生了很多内存碎片，若不清理这些内存碎片，如果出现需要分配一个大对象的时候，这时所有的碎片空间都完全无法完成分配，就会提前触发垃圾回收，而这次回收其实不是必要的。

为了解决内存碎片问题，Mark-Compact 被提出，它是在是在 Mark-Sweep 的基础上演进而来的，相比 Mark-Sweep，Mark-Compact 添加了活动对象整理阶段，**将所有的活动对象往一端移动，移动完成后，直接清理掉边界外的内存**。

### 增量标记

为了避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况,垃圾回收的 3 种基本算法都需要**将应用逻辑暂停下来,待执行完垃圾回收后再恢复执行应用逻辑,这种行为被称为“全停顿"**，长时间的"全停顿"垃圾回收会让用户感受到明显的卡顿，带来体验的影响。以 1.5 GB 的垃圾回收堆内存为例,V8 做一次小的垃圾回收需要 50 毫秒以上,做一次非增量式的垃圾回收甚至要 1 秒以上。这是垃圾回收中引起 JavaScript 线程暂停执行的时间,在 这样的时间花销下,应用的性能和响应能力都会直线下降。

为了降低全堆垃圾回收带来的停顿时间,V8 先从标记阶段入手,**将原本要一口气停顿完成的动作改为增量标记(incremental marking),也就是拆分为许多小“步进”,每做完一“步进” 就让 JavaScript 应用逻辑执行一小会儿,垃圾回收与应用逻辑交替执行直到标记阶段完成**

### 惰性清理 - Lazy sweeping

增量标记只是对活动对象和非活动对象进行标记，惰性清理用来真正的清理释放内存。当增量标记完成后，**假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理的过程延迟一下，让 JavaScript 逻辑代码先执行，也无需一次性清理完所有非活动对象内存，垃圾回收器会按需逐一进行清理，直到所有的页都清理完毕。**

### 并发 - Concurrent

并发式 GC 允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于 JavaScript 代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行写屏障操作。

### 并行 - Parallel

并行式 GC 允许主线程和辅助线程同时执行同样的 GC 工作，这样可以让辅助线程来分担主线程的 GC 工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。

## V8 当前垃圾回收机制

2011 年，V8 应用了增量标记机制。直至 2018 年，Chrome64 和 Node.js V10 启动并发标记（Concurrent），同时在并发的基础上添加并行（Parallel）技术，使得垃圾回收时间大幅度缩短。

### 副垃圾回收器

V8 在新生代垃圾回收中，使用并行（parallel）机制，在整理排序阶段，也就是将活动对象从 from-to 复制到 space-to 的时候，启用多个辅助线程，并行的进行整理。由于多个线程竞争一个新生代的堆的内存资源，可能出现有某个活动对象被多个线程进行复制操作的问题，为了解决这个问题，V8 在第一个线程对活动对象进行复制并且复制完成后，都必须去维护复制这个活动对象后的指针转发地址，以便于其他协助线程可以找到该活动对象后可以判断该活动对象是否已被复制。

### 主垃圾回收器

V8 在老生代垃圾回收中，如果堆中的内存大小超过某个阈值之后，会启用并发（Concurrent）标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以 s 及对这个对象的引用，而在 JavaScript 代码执行时候，并发标记也在后台的辅助进程中进行，当堆中的某个对象指针被 JavaScript 代码修改的时候，写入屏障（write barriers）技术会在辅助线程在进行并发标记的时候进行追踪。

当并发标记完成或者动态分配的内存到达极限的时候，主线程会执行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次的扫描根集以确保所有的对象都完成了标记，由于辅助线程已经标记过活动对象，主线程的本次扫描只是进行 check 操作，确认完成之后，某些辅助线程会进行清理内存操作，某些辅助进程会进行内存整理操作，由于都是并发的，并不会影响主线程 JavaScript 代码的执行。

##### 原文链接

[深入理解谷歌最强 V8 垃圾回收机制](https://zhuanlan.zhihu.com/p/259579683)
