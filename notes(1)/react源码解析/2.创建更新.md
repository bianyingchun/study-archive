### ReactDom.render();

核心代码

```javascript
const ReactDom: Object = {
  // ....
  render(
    element: React$Element<any>, //传入的React组件
    container: DOMContainer, //挂载的容器节点
    callback: ?Function //挂载后的回调函数
  ) {
    return legacyRenderSubtreeIntoContainer(
      null,
      element,
      container,
      false,
      callback
    );
  },
  //...
};
```

#### legacyRenderSubtreeIntoContainer

核心工作

1. root = 创建 ReactRoot
2. 调用 root.render();

```javascript
function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component<any, any>, //null
  children: ReactNodeList, //传入进来需要挂在的class component
  container: DOMContainer, //根节点
  forceHydrate: boolean, //false
  callback: ?Function //挂载完成后的回调函数
) {
  // ......
  // 是否存在根节点   初次渲染是不存在根节点的
  let root: Root = (container._reactRootContainer: any);
  if (!root) {
    // 1、创建ReactRoot 赋值给container._reactRootContainer和root（这里发生了很多事，一件很重要很重要的事   生成了fiber结构树。。）
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate
    );
    // ......
  } else {
    // ......
    // 2、调用root.render()
    root.render(children, callback);
  }
  return DOMRenderer.getPublicRootInstance(root._internalRoot);
}
```

### legacyCreateRootFromDOMContainer

1. 清除所有子节点
2. 创建 new ReactRoot 节点

```javascript
function legacyCreateRootFromDOMContainer(
  container: DOMContainer, //根节点
  forceHydrate: boolean //false,
): Root {
  //  服务端渲染相关 是否合并原先存在的dom节点 一般是false
  const shouldHydrate =
    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
  // 1、清除所有子元素，通过container.lastchild循环来清除container的所有内容，因为我们的属于首次渲染，container里边不包含任何元素
  if (!shouldHydrate) {
    let warned = false;
    let rootSibling;
    while ((rootSibling = container.lastChild)) {
      // ......
      container.removeChild(rootSibling);
    }
  }
  // Legacy roots are not async by default.
  const isConcurrent = false;
  // 2、创建 new ReactRoot节点
  return new ReactRoot(container, isConcurrent, shouldHydrate);
}
```

### ReactRoot

从 ReactRoot 中， 我们把 createContainer 返回值赋给了 实例的\_internalRoot， 往下看 createContainer

```javascript
function ReactRoot(
  container: Container,
  isConcurrent: Boolean,
  hydrate: Boolean
) {
  const root = DomRenderer.createContainer(container, isConcurrent, hydrate);
  this._internalRoot = root;
}
```
